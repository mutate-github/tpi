#!/bin/bash
set -f
TPIVER="29.02.24"
# echo "version $TPIVER by Talgat Mukhametshin dba.almaty@gmail.com  last version: https://github.com/mutate-github/tpi"

# echo "tpi: "$* 
_P1_=$1
sid=$(awk -F/ '{print $1}' <<< "$_P1_")
PDB=$(awk -F/ '{print $2}' <<< "$_P1_")
if [ -n "$PDB" ]; then
  SET_PDB_="alter session set container=$PDB;"
fi

_P2_="$2"
if ( grep -q "@" <<< "$_P2_" ); then
  login_str="$_P2_"
  shift
fi
#echo "tpi_P1_: "$_P1_
#echo "tpi_P2_: "$_P2_
#echo "tpi_@: "$@

init_msg()
{
  a__="\"\" - ACTIVE | a - Allsess | in - INACTIVE | k - KILLED  | [access OBJECT] - active sess which accessing OBJECT | SPID\SID\OS_client_PID [PEEKED_BINDS OUTLINE all ALLSTATS ADVANCED last adaptive PREDICATE partition|p] [param_name] - sess param info from V\$SES_OPTIMIZER_ENV by [param_name]"
  p__="p [FALSE] [PAR1 PAR2 ..] | ph [FALSE] [PARAMETER] | services | dir - instance parameters or hidden parameters, [FALSE] - only changed parameters, v\$services, dba_directories" 
  db__="db [ nls|option|properties|fusage ] - v\$instance, v\$database, dba_registry, dba_registry_sqlpatch, nls_database_paramters, v\$option, database_properties information" 
  audit__="audit [login | maxcon [dd/mm/yy-HH:MI-HH:MI(hours)] [CNT] | 1017 [dd/mm/yy-HH:MI-HH:MI(hours)] [USR] | obj [dd/mm/yy-HH:MI-HH:MI(hours)] [OBJ] ] - DDL users audit, login - check all users for simple password, maxcon - max of db connections above CNT (def 100) for a period (def 1H), 1017 - failed login, obj - obj audit"
  health__="health [cr | hot] - Database health parameters (HWM sessions, Hit Ratio / Get Misses cache, System Events Waits, Consistent Read buffers in SGA | Hot buffers)"
  oratop__="oratop [ h | dhsh [dd/mm/yy-HH:MI-HH:MI(hours) - def3d] ] - Database and Instance parameters, h - history V\$SYSMETRIC_HISTORY V\$ACTIVE_SESSION_HISTORY, dhsh - dba_hist_sysmetric_history dba_hist_snapshot"
  sga__="sga - SGA information" 
  pga__="pga - PGA sessions information"
  size__="size [days | tbs [free] | temp | sysaux | df [io|usage|lastseg[TBS]] | maxseg TBS | fra | grows (days)] - Size of DB+archl (7 def), tablespaces, datafiles (HWM in DF+script), maxseg in all DB\TBS, FRA info + db_recovery_file_dest usage; ( alter system set \"_enable_space_preallocation\"=0 )"
  arch__="arch - archivelog, V\$LOG V\$ARCHIVE_DEST V\$ARCHIVE_DEST_STATUS GV\$MANAGED_STANDBY V\$STANDBY_LOG information"
  redo__="redo [logs] - redo information" 
  undo__="undo [recovery] - undo active transaction information, recovery information" 
  sesstat__="sesstat [ list | sess SESS_ID [STATNAME] | STATNAME ] - sesstat information, where 'list' - STATISTIC NAMES, sess SESS_ID - sesstat for session, STATNAME - name particular of STATISTIC NAME" 
  topseg__="topseg [SEGMENT_NAME] [OWNER] - top 20 segments statistics information from V\$SEGMENT_STATISTICS or SEGMENT_NAME statistics" 
  o__="o OBJECT_NAME | OBJECT_ID | invalid [OWNER] | ddl [last N hours] - dba_objects information" 
  s__="s SEGMENT_NAME [OWNER] - dba_segments information" 
  t__="t [part] TABLE_NAME [OWNER] - dba_tables, dba_part_tables, dba_tab_partitions, dba_tab_subpartitions information" 
  i__="i [part] INDEX_NAME | TABLE_NAME [OWNER] | candidate [TABLE_NAME|%] [TABLE_OWNER] - dba_indexes, dba_part_indexes, dba_ind_partitions, dba_ind_subpartitions information, candidate to rebulld" 
  l__="l LOB_NAME - dba_lobs information" 
  c__="c [ CONSTRAINT_NAME | T TABLE_NAME | PK PRIMARY_KEY | FK (TABLE_NAME [OWNER] | %) ]  - dba_constraints, dba_cons_columns information, PK - Who refs to the PK, FK - Tables with non-indexed foreign keys" 
  u__="u [ USERNAME [{sys|role|tab} PRIVILEGE] ]  - dba_users, dba_sys_privs, dba_role_privs, dba_tab_privs information"
  r__="r [ {role|granted_role} ROLE  ] - role_role_privs information"
  trg__="trg [ \"\" | [TRIGGER_NAME] [TRIGGER_OWNER] | t [TABLE_NAME] [TABLE_OWNER]  ]  - dba_triggers information, \"\" - LOGON or STARTUP triggers"
  profile__="profile [PROFILE] - profiles information"
  links__="links [LINK_NAME] - links information"
  latch__="latch - latch information"
  lock__="lock [lib | obj OBJECT_NAME] - blocking locks information, lib - library lock information"
  bind__="bind [SQL] - sql not using bind variable information"
  pipe__="pipe [PIPE_NAME] - pipes information, read PIPE_NAME" 
  longops__="longops [SID | MESSAGE | rman] - active session longops for SID or MESSAGE or rman backup elapsed time" 
  scheduler__="scheduler [JOB_NAME | run JOB_NAME [hours] | log JOB_NAME [hours] | autotask ] - dba_scheduler_jobs information, log | run JOB_NAME [hours] - dba_scheduler_job_log | dba_scheduler_job_run_details for JOB_NAME in last [hours]" 
  job__="job [OWNER] - dba_jobs information" 
  rman__="rman [DAYS|cfg|last] - RMAN backups | v\$rman_configuration information | last - hours passed since the last backup" 
  get_ddl__="get_ddl TYPE OBJECT (OWNER) - dbms_metadata.get_ddl extract dml, OBJECT - may be % or %mask%"
  trace__="trace [SID SERIAL LEVEL] [db {on|off}] - Trace for session, Level: 0-Disable, 1-Enable, 4-Enable with Binds, 8-Enable with Waits, 12-4+8, Trace all db sessions: on \ off"
  kill__="kill SID SERIAL - Kill session"
  exec__="exec - execute \"SQL Commands\"  Note: Must be escaped with \\ characters: * ; ' ! ( )      ( alter system set \"_ash_sample_all\"=true )"
  alert__="alert [num] - tail -num alert_[sid].log, default num = 100"
  report__="report [ash {text|html} -60] -for last hour, [awr {text|html} DD/MM/YYYY HH24_begin HH24_end], [awrdd {text|html} DD1/MM/YYYY HH24_begin HH24_end DD2/MM/YYYY HH24_begin HH24_end], [awrsql {text|html} DD/MM/YYYY HH24_begin HH24_end sql_id], [addm text DD/MM/YYYY HH24_begin HH24_end] - oracle reports"
  corrupt__="corrupt [{rowid|dba} ID] | [fb (FILE) (BLOCK)] - Find object by ROWID, Find object by DBA, Find DB Object in dba_extents by file/block, v\$database_block_corruption v\$nonlogged_block information"
  sql__="sql SQL_ID | SQLTEXT [plan SQL_ID] [sqlstat [SQL_ID|par|inv|fch|sor|exe|pio|lio|row|cpu|ela|iow|mem] [executions] ] - Find out sql_id by SQLTEXT\SQL_ID from V\$SQL, plan from VSQL_PLAN by sql_id, sqlstat from V\$SQLSTAT by sql_id"
  ash__="ash [dd/mm/yy-HH:MI-HH:MI(hours) - def1h] [ event | sess [SID SERIAL# [all|nosqlid] | SQL_ID] | where [FIELD CONDITION] | sql [top [event]] [all [event]] [SQL_ID|SQL_TEXT] | plan SQL_ID PHV [fmt display plan] | sqlstat [SQL_ID|par|inv|fch|sor|exe|pio|lio|row|cpu|ela|iow|mem] [executions] | temp [sizeMb] | (tmc)chart ] - Top SQL, Events, Sessions V\$ACTIVE_SESSION_HISTORY"
  dhash__="dhash [dd/mm/yy-HH:MI-HH:MI(hours) - def1h] [ event | sess [SID SERIAL# [all|nosqlid] | SQL_ID] | where [FIELD CONDITION] | sql [top [event]] [all [event]] [SQL_ID|SQL_TEXT] | plan SQL_ID PHV [fmt display plan] | sqlstat [SQL_ID|pio|lio|cpu|exe|ela|fch|sor|iow|row] [executions] | growseg [TBS] [SEGMENT] | segstat [SEGMENT] [OWNER] [SORT_COL] | temp [sizeMb] | (tmc)chart | iostat [df|redo|ctl|temp|arch|other] ] | awrinfo - Top SQL, Events, Sessions DBA_HIST_ACTIVE_SESS_HISTORY"
  spm__="spm [days def7 - baselines] [find %|SQL_HANDLE SQL_PLAN_NAME] [ blplan %|SQL_HANDLE (PLAN_NAME) | blexec [count] | bllpfcc SQL_ID PLAN_HASH_VALUE [SQL_HANDLE] | bllpfawr SQL_ID PLAN_HASH_VALUE MIN_SNAP_ID MAX_SNAP_ID | blchattr SQL_HANDLE PLAN_NAME ATTR VALUE | blchplan NEW_SQL_ID NEW_PHV OLD_SQLSET_NAME | blevolve SQL_HANDLE PLAN_NAME | sqlset_list SQLSET_NAME OWNER | sqlset_plan SQLSET_NAME SQL_ID [PHV] | sqlset_drop SQLSET_NAME | bldrop SQL_HANDLE (PLAN_NAME) | sqltune [SQL_ID | awr SQL_ID begin_snap end_snap]  | sqltune_report TASK_NAME | sqltune_accept TASK_NAME | sqltune_create_plan_bl TASK_NAME OWNER PLAN_HASH_VALUE | sqltune_list [TASK_NAME] [cnt] | sqltune_drop TASK_NAME | sql_profiles | sql_profile_chattr TASK_NAME ATTR VALUE  | sql_profile_drop NAME | hints profile|baseline|patch NAME | sqlpatch_list | sqlpatch_create SQL_ID 'HINTS\"\\'\"' | sqlpatch_alter PATCHNAME enable|disable | sqlpatch_drop PATCHNAME | report_sql_monitor SQL_ID ]"
}

init_msg

if [ -z "$sid" ]; then
  env | grep ORA
  ps -ef | grep [p]mon
  echo "Usage: $0 <DBSID/PDB> sess_id [p|ph [FALSE] <param>] [services] [dir] | a [SPID\SID\OS_client_PID] | lock | db | audit | health | oratop | sga | pga | size | arch | redo | undo | sesstat | topseg | o . | s . | t . | i . | l . | c . | u . | r. | trg . | profile | links | latch | bind | pipe | longops | scheduler | job | rman | get_ddl | trace | kill | exec | alert | report ash/awr | corrupt | sql | ash | dhash | spm"
  echo -e $a__"\n"$p__"\n"$db__"\n"$audit__"\n"$health__"\n"$oratop__"\n"$sga__"\n"$pga__"\n"$size__"\n"$arch__"\n"$redo__"\n"$undo__"\n"$sesstat__"\n"$topseg__"\n"$o__"\n"$s__"\n"$t__"\n"$i__"\n"$l__"\n"$c__"\n"$u__"\n"$r__"\n"$trg__"\n"$profile__"\n"$links__"\n"$latch__"\n"$lock__"\n"$bind__"\n"$pipe__"\n"$longops__"\n"$scheduler__"\n"$job__"\n"$rman__"\n"$get_ddl__"\n"$trace__"\n"$kill__"\n"$exec__"\n"$alert__"\n"$report__"\n"$corrupt__"\n"$sql__"\n"$ash__"\n"$dhash__"\n"$spm__"\n"
  exit
  echo "NOT EXIT"
fi

ORACLE_SID=$sid
export ORACLE_SID
#NLS_LANG=AMERICAN_AMERICA.CL8MSWIN1251
#export NLS_LANG
shift
ID="$1"
# echo "ID: "$ID
# ALL=$*
ALL=$(echo $*)
# echo "tpi ALL: "$ALL

dec2ascii()
{
  RES=""
  for i in $(sed 's|/| |g' <<< "$*"); do
     RES="${RES}$(printf \\$(printf '%03o' $i))"
  done
  echo $RES
}

xor()
{
  KEY=$1
  shift
  RES=""
  for i in $(sed 's|/| |g' <<< "$*"); do
    RES="$RES/$(($i ^$KEY))"
  done
  echo $RES
}

if [ -n "$login_str" ]; then
  ls1=$(awk -F@ '{print $1}' <<< "$login_str")
  ls2=$(awk -F@ '{print $2}' <<< "$login_str")
  ls1=$(xor 127 $ls1)
  ls1=$(dec2ascii $ls1)
  login_str=${ls1}"@"\'${ls2}\'
  SP="eval sqlplus -S $login_str"
else
  SP="eval sqlplus -S '/ as sysdba'"
fi
# echo "tpi_SP: "$SP

cd /tmp

logf()
{
cat $LOGF  | tr -d \~
rm -f $LOGF
rm -f $LOGINSQL >/dev/null 2>&1
}


is_number()
{
if [ -z "$1" ]; then
 echo 0
 return
fi
case "$1"  in
  *[!0-9]*)  echo 0 ;;
  *)         echo 1 ;;
esac
}


db_version()
{
VALUE=$($SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select substr(version,1,instr(version,'.')-1) from v$instance where rownum=1;
END
)
tr -d '\r' <<< "$VALUE"
}

db_is_pdb()
{
VALUE=$($SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select value from v$system_parameter where name ='enable_pluggable_database';
END
)
tr -d '\r' <<< "$VALUE"
}

db_is_open()
{
VALUE=$($SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select status from v$instance where rownum=1;
END
)
tr -d '\r' <<< "$VALUE"
}

case $(db_is_open) in
OPEN)
NLS_VALUE=$($SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select case when value like '%UTF%' then value else 'CL8MSWIN1251' end from nls_database_parameters where parameter='NLS_CHARACTERSET';
END
)
;;
*) : ;;
esac

NLS_VALUE=$(tr -d '\r' <<< "$NLS_VALUE")
NLS_LANG=AMERICAN_AMERICA.$NLS_VALUE
# NLS_LANG=AMERICAN_AMERICA.AL32UTF8
export NLS_LANG
WINCP="CL8MSWIN1251"

LOGF="/tmp/tpilog_$$.txt"

export ORACLE_PATH=/tmp
LOGINSQL=/tmp/login.sql
if [ ! -f "$LOGINSQL" ]; then
cat << CREATELOGINSQL > $LOGINSQL
$SET_PDB_
set echo off
set timing off
set feedback off
/*
begin
 case 
   when dbms_db_version.version in  ('9','10') then null;
   when dbms_db_version.version = 11 then execute immediate 'alter session set "_optimizer_use_feedback"=false';
   when dbms_db_version.version = 12 then  
      execute immediate 'alter session set optimizer_adaptive_features=false';
      execute immediate 'alter session set optimizer_adaptive_plans=false';
      execute immediate 'alter session set optimizer_adaptive_statistics=false';
      execute immediate 'alter session set "_optimizer_use_feedback"=false';
   else null ;
 end case;
 exception when others then raise_application_error(sqlcode, sqlerrm(sqlcode));
end;
/
*/
alter session set statistics_level=basic;
alter session set nls_date_format='dd/mm/yyyy hh24:mi:ss';
--alter session set optimizer_features_enable = '10.2.0.4';
--alter session set optimizer_index_cost_adj = 100;
--alter session set optimizer_index_caching  = 10;
--alter session set optimizer_mode  = 'FIRST_ROWS';
--alter session set optimizer_max_permutations = 1000;
--alter session set optimizer_dynamic_sampling = 0;
--alter session set "_optimizer_ignore_hints"=true;
exec dbms_application_info.set_module('tpi script','oracle');
set timing on
CREATELOGINSQL
fi

init_sql_sess()
{
SQL_SESS="
set lines 300 pages 1000
set echo off feed off veri off tab off timing on
col spid for a8
col sid for 99999
col serial# for 999999
col username for a20 truncated
col osuser for a17 truncated
col machine for a17 truncated
col pma for a60 heading 'PROGRAM / MODULE / ACTION' truncated
col pgau for 99999
col logon_time for a11 heading 'LOGON'
col last_call_et for 999999 heading 'LAST'
col status for a1 heading 'S' truncated
col command_name for a6 heading 'CMD' truncated
col sql_id for a13
col event for a27 truncated
col sw for 999999
col oot for a40 heading 'ACCESS OBJECT' truncated
SELECT /*+ OPT_PARAM('_optimizer_adaptive_plans' 'false') */   /*+ NO_MONITOR */
       p.spid, s.sid, s.serial#, /* s.audsid,*/ s.username,
       s.osuser,
       replace(s.machine,CHR(0),'') machine,
       s.program||' / '||s.module||' / '|| $SQLACTION_
       trunc(p.pga_used_mem/1024/1024) pgau, $SQLCMD1_ $SQL_ID_
       w.event /*,w.p1text,w.p1,w.p2text,w.p2*/,
       case when w.seconds_in_wait>8640000 then w.seconds_in_wait/60/60/24*-1 else w.seconds_in_wait/60/60 end sw,
       to_char(s.logon_time,'dd/mm hh24:mi') logon_time,
       case when s.last_call_et>864000 then s.last_call_et/60/60/24*-1 else s.last_call_et end last_call_et, s.status  $access_p1_str
   FROM v\$session s, v\$process p, v\$session_wait w  $SQLCMD2_  $access_p2_str
   WHERE p.addr = s.paddr $access_p3_str $SQLCMD3_
       AND s.sid=w.sid AND p.spid IS NOT NULL AND s.type <> 'BACKGROUND' AND s.username IS NOT NULL $SQL_STATUS $SQL_TRACE
   order by to_char(s.last_call_et,'0000000.00') desc, s.osuser,w.event, to_char(s.logon_time,'hh24:mi') ;
"
}

active_sessions()
{
P1_="$1"
P2_="$2"

shopt -s nocasematch
case "$P1_" in
  access) access_p1_str=",a.owner||'.'||a.object||' '||a.type oot" ; access_p2_str=",v\$access a" ; access_p3_str="and s.sid=a.sid and a.OBJECT = upper('$P2_')" ; P1_="a" ;;
       k)    SQL_STATUS="AND s.status in ('KILLED','SNIPED')  " ;;
      in)    SQL_STATUS="AND s.status in ('INACTIVE')  " ;;
       a)    SQL_STATUS="AND s.status like '%' " ;;
       *)    SQL_STATUS="AND s.status = 'ACTIVE' " ;;
esac

case "$(db_version)" in
 9|10) SQL_ID_=""
    SQLACTION_="s.action pma,"
    SQLCMD1_=""
    SQLCMD2_=""
    SQLCMD3_=""
    ;;
 *) SQL_ID_="DECODE (s.plsql_subprogram_id, NULL, s.sql_id, NULL) sql_id,"
    SQLACTION_="CASE when '$NLS_VALUE'='$WINCP' then s.action when replace(REGEXP_REPLACE(convert(UNISTR(ASCIISTR(s.action)), '$NLS_VALUE','$WINCP'), '[-*\/_0-9a-zA-Z]', ''), ' ') is null then UTL_RAW.CAST_TO_VARCHAR2(UTL_RAW.CONVERT(UTL_RAW.CAST_TO_RAW(nvl(s.action,' ')),'AMERICAN_AMERICA.$NLS_VALUE', 'AMERICAN_AMERICA.$WINCP')) else s.action end pma,"
    SQLCMD1_="c.command_name, "
    SQLCMD2_=", v\$sqlcommand c "
    SQLCMD3_="and s.command = c.command_type "
    SQLCMD4_='alter session set "_optimizer_cartesian_enabled"=false;'
    ;;
esac

init_sql_sess

$SP <<EOF >$LOGF
set timing off
$SQLCMD4_
$SQL_SESS
EOF
logf
}


process_info()
{
P1_=$(echo $* | awk '{print $1}')
P2_=$(echo $* | awk '{print $2}')
case "$P2_" in
  p)  P3_=$(echo $* | awk '{print $3}' | tr '[:lower:]' '[:upper:]') ;;
  *)  shift; ALL="$*" ;;
esac

CODE11_="
  if (s.sql_id is not null) then
    dbms_output.put_line(chr(126)||'Explain plan from dbms_xplan.display_cursor:');
    for c1 in (select plan_table_output from   table(dbms_xplan.display_cursor(s.sql_id,s.sql_child_number,'-predicate $ALL')) ) loop
      dbms_output.put_line(chr(126)||chr(32)||c1.plan_table_output);
    end loop;
  end if;
"
CODE11_2_="
-- Binds for verison 10g and above
-- for c1 in ( select distinct sql_id, name, VALUE_STRING from V\$SQL_BIND_CAPTURE where sql_id=s.sql_id and hash_value=s.sql_hash_value and child_number=s.sql_child_number order by 2 ) loop
--    dbms_output.put_line(chr(126)||'Bind variables: v\$sql_bind_capture     NAME: '|| c1.name ||'  VALUE: '||c1.VALUE_STRING);
-- end loop;
"
CODE9_="
  dbms_output.put_line(chr(126)||'Current SQL statement:');
  for c1 in ( select * from sys.v_\$sqltext
              where HASH_VALUE = s.sql_hash_value order by piece) loop
    dbms_output.put_line(chr(126)||chr(32)||c1.sql_text);
  end loop;

  for c1 in ( select * from sys.v_\$sqltext
              where HASH_VALUE = s.sql_hash_value and rownum=1) loop
    dbms_output.put_line(chr(126)||'HASH_VALUE: '||c1.hash_value);
  end loop;
"
CODE9_2_="
  execute immediate 'create or replace view dynamic_plan_table as select rawtohex(address) || ''_'' || child_number statement_id, sysdate timestamp, operation, options, object_node,
  object_owner, object_name, 0 object_instance, optimizer,  search_columns, id, parent_id, position, cost, cardinality, bytes, other_tag, partition_start,
  partition_stop, partition_id, other, distribution, cpu_cost, io_cost, temp_space, access_predicates, filter_predicates from v\$sql_plan';
begin
  SELECT GV\$Session.SQL_Address||'_'|| To_Char(GV\$SQL.Child_Number) into STR_ FROM GV\$Session, X\$KGLLK, GV\$SQL
  WHERE  X\$KGLLK.Inst_Id = GV\$Session.Inst_Id AND X\$KGLLK.KGLLKSNM = GV\$Session.SId AND X\$KGLLK.KGLHDPAR = GV\$Session.SQL_Address AND X\$KGLLK.KGLNAHSH = GV\$Session.SQL_Hash_Value
  AND X\$KGLLK.KGLHDNSP = 0 AND X\$KGLLK.KGLHDPAR != X\$KGLLK.KGLLKHDL AND GV\$SQL.Address = X\$KGLLK.KGLHDPAR AND GV\$SQL.Hash_Value = X\$KGLLK.KGLNAHSH AND GV\$SQL.Child_Address = X\$KGLLK.KGLLKHDL AND GV\$Session.SID=s.sid;
exception when no_data_found THEN null;
 return;
end;
  dbms_output.put_line(chr(126)||'Explain plan from dbms_xplan.display for: s.sql_address=' || s.sql_address||' , s.sql_hash_value=' || s.sql_hash_value || ' ,  SQLADDR_CHILD: '||STR_);
  if (s.sql_hash_value is not null) then
    for c1 in (select /*+ RULE */ plan_table_output from table(dbms_xplan.display('dynamic_plan_table', STR_, 'serial')) ) loop
      dbms_output.put_line(chr(126)||chr(32)||c1.plan_table_output);
    end loop;
  end if;
"

case "$(db_version)" in
8)  echo "Oracle Version 8..." ;;
9)  CMD1_=$CODE9_ 
    CMD2_=$CODE9_2_ ;;
*)  CMD1_=$CODE11_ 
    CMD2_=$CODE11_2_
    CMD3_="select owner||'.'||object_name||' / '||object_id into STR_ from dba_objects where object_id=s.PLSQL_ENTRY_OBJECT_ID;" 
    CMD4_="begin select sql_id into  STR2_ from sys.v_\$sqltext where HASH_VALUE = s.prev_hash_value and rownum=1; exception when others then null; end;" ;;
esac

case "$P2_" in
p)
$SP <<EOF >$LOGF
set serveroutput on size 500000
set echo off feed off veri off tab off
set lines 230
set pages 100
ttitle left "Session parameters  V\$SES_OPTIMIZER_ENV :"
column NAME for a40 
column SQL_FEATURE for a25 
select SID,ID,NAME,SQL_FEATURE,ISDEFAULT,VALUE from V\$SES_OPTIMIZER_ENV where sid=$P1_ and upper(name) like '%$P3_%';
EOF
;;
*)
$SP <<EOF >$LOGF
set serveroutput on size 500000
set echo off feed off veri off tab off
set lines 230
DECLARE
  id varchar2(20);
  STR_ varchar2(60);
  STR2_ varchar2(60);
  v_sid number;
  s sys.v_\$session%ROWTYPE;
  p sys.v_\$process%ROWTYPE;
BEGIN
  select '$ID' into id from dual;
  begin
    select s.sid into v_sid
      from sys.v_\$process p, sys.v_\$session s
     where p.addr = s.paddr
       and (p.spid = id or s.sid = id or s.process = id /* or s.serial# = id or s.audsid = id */ ) and rownum=1;
  exception
    when too_many_rows then
      dbms_output.put_line(chr(126)||'There are more than one session !!! Set parameter OSID:');
      for i in (select p.spid, s.audsid, s.serial#, s.username, s.status, s.machine
                  from   sys.v_\$process p, sys.v_\$session s
                 where p.addr = s.paddr and (p.spid = id or s.sid = id or s.process = id /* or s.serial# = id or s.audsid = id */)) loop
        dbms_output.put_line(chr(126)||i.spid||' / '||i.audsid||' / '||i.serial#||' => '||i.username||' '||i.status||' '||i.machine);
      end loop;
      return;
    when no_data_found then
      dbms_output.put_line(chr(126)||'Unable to find process id '||id||'!!!');
      return;
    when others then
      dbms_output.put_line(chr(126)||sqlerrm);
      return;
  end;

  select * into s from sys.v_\$session where sid  = v_sid;
  select * into p from sys.v_\$process where addr = s.paddr;
  begin
    null; 
    $CMD3_
  exception
    when no_data_found then null;
  end;

  dbms_output.put_line(chr(126)||'===============================================================================');
  dbms_output.put_line(chr(126)||'SID / Serial                        : '|| s.sid||'  '||s.serial#);
  dbms_output.put_line(chr(126)||'SPID / Program / Parent SID         : '|| p.spid||' / '||p.program || ' / ' || to_number(substr(to_char(s.ownerid, 'XXXXXXXX'),length(to_char(s.ownerid, 'XXXXXXXX'))-3 ),'XXXX') ); 
  dbms_output.put_line(chr(126)||'OS_client_PID / AUDSID              : '|| s.process || ' / ' || s.audsid);
  dbms_output.put_line(chr(126)||'s.terminal / p.terminal             : '|| s.terminal || ' / ' || p.terminal);
  dbms_output.put_line(chr(126)||'Username / OSUser / Machine         : '|| s.username || ' / ' ||  s.osuser||' / '||s.machine);
  dbms_output.put_line(chr(126)||'Program / Module / Action           : '|| s.program||' / '||s.module||' / '||s.action);
  dbms_output.put_line(chr(126)||'Object_name / PLSQL_ENTRY_OBJECT_ID : '|| STR_);
  dbms_output.put_line(chr(126)||'Status Flags                        : '|| s.status||' '||s.server||' '||s.type);
  dbms_output.put_line(chr(126)||'Tran Active                         : '|| nvl(s.taddr, 'NONE'));
  dbms_output.put_line(chr(126)||'Login Time                          : '|| to_char(s.logon_time, 'Dy HH24:MI:SS'));
  dbms_output.put_line(chr(126)||'Last Call                           : '|| to_char(sysdate-(s.last_call_et/60/60/24), 'Dy HH24:MI:SS') || ' - ' || to_char(s.last_call_et/60, '9999990.0') || ' min');
  dbms_output.put_line(chr(126)||'Lock / Latch / Latch Spin           : '|| nvl(s.lockwait, 'NONE')||' / '||nvl(p.latchwait, 'NONE') || ' / ' || nvl(p.latchspin, 'NONE'));

    for c1 in ( select w.*, case when event like '%latch%' then ', LatchName: '||l.name else '' end name  from sys.v_\$session_wait w, sys.v_\$latchname l where w.p2=l.latch#(+) and w.sid = s.sid) loop
    dbms_output.put_line(chr(126)||c1.state||': '||c1.event||', '||c1.p1text||'='||c1.p1||', '||c1.p2text||'='||c1.p2||', '||c1.p3text||'='||c1.p3||c1.name );
    for c2 in ( select  BLOCK_GETS, CONSISTENT_GETS, PHYSICAL_READS, BLOCK_CHANGES from v\$sess_io where sid=s.sid ) loop
       dbms_output.put_line(chr(126)||'V\$SESS_IO: BLOCK_GETS='||c2.BLOCK_GETS||'  CONSISTENT_GETS='||c2.CONSISTENT_GETS||'  PHYSICAL_READS='||c2.PHYSICAL_READS||'  BLOCK_CHANGES='||c2.BLOCK_CHANGES);
    end loop;
  end loop;

  $CMD1_
  $CMD2_

  $CMD4_
  dbms_output.put_line(chr(126)||'Previous SQL statement for SQL_ID: '||STR2_);
  for c1 in ( select * from sys.v_\$sqltext where HASH_VALUE = s.prev_hash_value order by piece) loop
    dbms_output.put_line(chr(126)||chr(32)||c1.sql_text);
  end loop;
  dbms_output.put_line(chr(126)||'===============================================================================');
END;
/
spool off
exit
EOF
;;
esac
logf
}



lock()
{
P1_="$1"
P2_="$2"
SETP_="set echo off feed off veri off tab off 
set lines 230 pages 100
column Action format a10
column SID format 99999
column serail# format 9999999
column PID format a10
column username format a30
column name format a30
column object_name format a30
column lmode format a15
column request format a15
column TYPE format a4
column last_call_et heading 'ET(min)' format a10
PROMPT 0: None
PROMPT 1: Null (NULL)
PROMPT 2: Row-S (SS) Row Share
PROMPT 3: Row-X (SX) Row Exclusive
PROMPT 4: Share (S) Share
PROMPT 5: S/Row-X (SSX) Share/Row Exclusive
PROMPT 6: Exclusive (X)"

shopt -s nocasematch
case "$P1_" in
lib) $SP <<'END' > $LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column sid for 999999
column serial# for 9999999
column m for 9
column r for 9
column username for a10
column status for a1
column osuser for a13
column machine for a15
column program for a35
column Object for a30
column event for a25
column s_w for 9999
column spid for a16
column logon_time for a20 wrap
prompt "-- kglpnmod M  (0: no lock; 1: null; 2: shared; 3: exclusive)"
SELECT /* +rule */ 'kill -9 '||pr.spid spid, s.sid, s.serial#, sw.event, sw.seconds_in_wait s_w,
ob.kglnaown||'.'||ob.kglnaobj "Object", p.kglpnmod "M", p.kglpnreq "R",
s.username,substr(s.status,1,1) status,s.osuser,s.machine,s.program,to_char(s.logon_time,'dd/mm/yyyy hh24:mi:ss') logon_time
FROM x$kglpn p, sys.v_$session s, sys.v_$process pr, x$kglob ob, sys.v_$session_wait sw
WHERE p.kglpnuse=s.saddr and pr.addr = s.paddr and ob.kglhdadr=p.kglpnhdl
--and (sw.event like 'lib%')
and sw.event in ('library cache load lock','library cache lock','cursor: pin S wait on X','row cache lock')
and sw.p1raw = ob.kglhdadr;
END
;;
obj) $SP <<END > $LOGF
$SETP_
SELECT /*+ rule */ DECODE(w.request,0,'HOLDER: ','Waiter: ') Action, w.sid, P1.spid "PID", s1.status, s1.username, /*w.id1, w.id2,*/ -- w.lmode, w.request,
DECODE(w.lmode, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive') lmode,
DECODE(w.request, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive') request,
w.type, o.name, to_char(s1.last_call_et/60, '9999990.0') last_call_et
FROM V\$LOCK w, sys.obj$ o, sys.v_\$session s1, sys.v_\$process p1
WHERE (w.id1, w.id2, w.type) IN (SELECT id1, id2, type FROM V\$LOCK /* WHERE request>0*/)
and upper(o.name) = upper('$P2_') and w.lmode not in (0,1)
and o.obj# (+) = s1.row_wait_obj# and w.sid = S1.sid (+) and S1.paddr = P1.addr (+)
ORDER BY w.id1, w. request, last_call_et desc;
END
;;
*) $SP <<END > $LOGF
$SETP_
SELECT /*+ rule */ DECODE(w.request,0,'HOLDER: ','Waiter: ') Action, w.sid, s1.serial#, P1.spid "PID", s1.status, s1.username, /*w.id1, w.id2,*/ -- w.lmode, w.request,
DECODE(w.lmode, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive') lmode,
DECODE(w.request, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive') request,
w.type, o.name, to_char(s1.last_call_et/60, '9999990.0') last_call_et
FROM V\$LOCK w, sys.obj$ o, sys.v_\$session s1, sys.v_\$process p1
WHERE (w.id1, w.id2, w.type) IN (SELECT id1, id2, type FROM V\$LOCK WHERE request>0)
and o.obj# (+) = s1.row_wait_obj# and w.sid = S1.sid (+) and S1.paddr = P1.addr (+)
ORDER BY w.id1, w.request, last_call_et desc;
END
;;
esac
logf
}


health()
{
P1_=$(awk '{print $1}' <<< "$ALL")
case "$P1_" in 
cr)
$SP <<'EOF' >$LOGF
set lines 230 pages 100
ttitle left "Consistent read buffers (>100) v$bh in SGA group by owner,object_name,object_type"
set lines 230 pages 100 timing on
col owner for a30
col dirty for a5
col object_name for a30
col object_type for a10
select d.owner, d.object_name, d.object_type, b.dirty, count(*) cnt
  from v$bh b, dba_objects d
where b.objd = d.data_object_id
   and d.owner not in ('SYS', 'SYSTEM')
   and b.status = 'cr'
group by d.owner, d.object_name, d.object_type, b.dirty
having count(*) > 100
order by cnt desc;
EOF
;;
hot)
$SP <<'EOF' >$LOGF
set lines 230 pages 100
ttitle left "Hot buffers in buffer cache  avg(tch)>100 and count(buffers)>20, 'cache buffers chains' latch contention:" skip 1
column owner for a20
column avg_touches format 999
column object_type format a30
column object_name format a30
column buffers format 999,999
select b.owner, object_type, object_name, blocks, count(1) buffers, avg(tch) avg_touches
from x$bh a, dba_objects b, dba_segments s
where a.obj=b.object_id and b.object_name=s.segment_name and b.owner not in('SYS','SYSTEM')
group by b.owner, object_name, object_type, blocks, obj
having avg(tch) > 100 and count(1) > 20
order by avg_touches desc;
ttitle off
EOF
;;
*)
$SP <<'EOF' >$LOGF
set lines 230 pages 100
set heading on
set feedback off
set termout off
set heading on
set termout on

ttitle left "v$license information about session HWM:"
select sessions_current,sessions_highwater,cpu_count_current from v$license;
ttitle off

ttitle left "Cache usage:"
col name for a70
col Remarks for a70
select 'Data Dictionary cache' Name, round((SUM(GETS - GETMISSES - USAGE - FIXED)) / SUM(GETS) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$ROWCACHE
union all
select 'Library cache' Name, round((SUM(PINS - RELOADS)) / SUM(PINS) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$LIBRARYCACHE
union all
select 'Index usage ratio' Name, round(sum(decode(name,'table fetch by rowid',value,0)) / sum(decode(name,'table fetch by rowid',value,'table scans (short tables)',value,'table scans (long tables)',value,0)) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$SYSSTAT
union all
select 'Memory usage in Sorts ratio' Name, round(sum(decode(name,'sorts (memory)',value,0)) / sum(decode(name,'sorts (memory)',value,'sorts (disk)',value,0)) * 100,4) Ratio, 'Ratio sorts in memory to total sorts' Remarks
    from V$SYSSTAT
union all
select 'Buffer cache hit ratio' Name, round((1 - sum(decode(name,'physical reads',value,0)) / sum(decode(name,'db block gets',value,'consistent gets',value,0))) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$SYSSTAT
union all
select 'Buffer pool: ' || Name || ' block_size: '|| block_size || ' hit ratio' Name, round((1 - physical_reads / decode(db_block_gets+consistent_gets,0,'',db_block_gets+consistent_gets) ) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$BUFFER_POOL_STATISTICS
union all
select 'Average buffers scanned' Name, round(1 + sum(decode(name,'free buffer inspected',value,0)) / sum(decode(name,'free buffer requested',value,0)),4), 'Target ~ 1..2, if above -- too low buffers' Remarks
    from V$SYSSTAT
union all
select 'Average dirty buffers' Name, round(sum(decode(name,'dirty buffers inspected',value,0)) / sum(decode(name,'free buffer inspected',value,0)),4), 'Target ~ ??, if too much durty -- too low buffers' Remarks
    from V$SYSSTAT
union all
select 'consistent reads - undo records applied / consistent read rollbacks', round((select value from V$SYSSTAT where name='transaction tables consistent reads - undo records applied') / 
  decode((select value from V$SYSSTAT where name='transaction tables consistent read rollbacks'),0,1,(select value from V$SYSSTAT where name='transaction tables consistent read rollbacks')),4) ratio, 'Less is better' Remarks
    from dual
union all
select 'Log Buffers space requests' Name, round(sum(decode(name,'redo log space requests',value,0))) Ratio,  'Target (..?)' Remarks
    from V$SYSSTAT
union all
select 'Shared pool free memory (MB)' Name, round(bytes/1024/1024,4) Ration, 'If much free mem -- maybe its redundant??' Remarks
    from V$SGASTAT
    where name = 'free memory' and pool = 'shared pool';
ttitle off

ttitle left "TOP 10 - v$system_event waits:" skip 1
column time_waited for 999999999999
select inst_id, event, time_waited, total_waits, total_timeouts, pct_mis
from (select inst_id, event, time_waited, total_waits, total_timeouts, round(total_timeouts/total_waits*100,3) pct_mis
from gv$system_event where event not in ('rdbms ipc message','smon timer',
'pmon timer','SQL*Net message from client',
'lock manager wait for remote message','ges remote message', 'client message',
'SQL*Net more data from client', 'pipe get', 'Null event', 'PX Idle Wait',
'single-task message', 'wakeup time manager','lreg timer','Streams AQ: deallocate messages from Streams Pool',
'OFS idle','AQPC idle','pman timer','wait for unread message on broadcast channel','DIAG idle wait')
order by time_waited desc)
where rownum <= 10
order by pct_mis desc;
ttitle off
EOF
;;
esac
logf
}

legend_oratop="prompt NCPU   - Number of CPU                                   AAS    - Average Active Sessions. (! if>#cpu)           IOMBPS - I/O megabytes per second (throughput)
prompt HCPUB  - Host cpu busy %(busy/busy+idle). (! if>90%)     AST    - Active user Sessions Total (ASCPU+ASIO+ASWA)   IOPS   - I/O requests per second
prompt CPUUPS - CPU Usage Per Sec                               ASCPU  - Active Sessions on CPU                         IORL   - I/O avg synch s/b/read latency in msec (! if>10ms)
prompt LOAD   - Current os load. (! if>2*#CPU and high cpu)     ASIO   - Active Sessions waiting on user I/O            LOGR   - Logical reads per sec
prompt DCTR   - DB CPU time ratio  % Cpu/DB_Time                ASWA   - Active Sessions Waiting, (! if>ASCPU+ASIO)     PHYR   - Physical reads per sec
prompt DWTR   - DB WAIT time ratio (! if>50 and high ASWA)      ASPQ   - Active Parallel Sessions                       PHYW   - Physical writes per sec
prompt SPFR   - Shared pool free %                              UTPS   - User transactions per sec                      TEMP   - Temp space used (Mb)
prompt TPGA   - Total pga allocated                             UCPS   - User calls per sec                             DBTM   - Database Time Per Sec
prompt SCT    - Session Count Total                             SSRT   - Sql service response time (T/call)"

SET_COL_ORATOP="
col BEGIN_TIME for a17 heading '1|BEGIN_TIME'
col NCPU for 999 heading '2|NCPU'
col HCPUB for 9999 heading '3|HCPUB'
col CPUUPS for 99999 heading '4|CPUUPS'
col LOAD for 999 heading '5|LOAD'
col DCTR for 999 heading '6|DCTR'
col DWTR for 999 heading '7|DWTR'
col SPFR for 99999 heading '8|SPFR'
col TPGA for 99999 heading '9|TPGA'
col SCT for 9999 heading '10|SCT'
col AAS for 9999 heading '11|AAS'
col AST for 9999 heading '12|AST'
col ASCPU for 9999 heading '13|ASCPU'
col ASIO for 9999 heading '14|ASIO'
col ASWA for 9999 heading '15|ASWA'
col ASPQ for 9999 heading '16|ASPQ'
col UTPS for 99999 heading '17|UTPS'
col UCPS for 9999999 heading '18|UCPS'
col SSRT for 9999999 heading '19|SSRT'
col IOMBPS for 99999 heading '20|IOMBPS'
col IOPS for 999999 heading '21|IOPS'
col IORL for 99999 heading '22|IORL'
col LOGR for 999999999 heading '23|LOGR'
col PHYR for 999999 heading '24|PHYR'
col PHYW for 999999 heading '25|PHYW'
col TEMP for 99999 heading '26|TEMP'
col DBTM for 99999 heading '27|DBTM'"

oratop()
{
case "$(db_version)" in
8|9|10)   echo "Oracle Version 8, 9, 10 oratop not supporting..." ; exit ;;
*)        :  ;;
esac

P1_=$(awk '{print $1}' <<< "$ALL")
case "$P1_" in
dhsh)
sysdate=$(date +%d/%m/%y\ %H:%M:%S)
if [ $(is_number $(echo $* | awk -F"/" '{print $2}')) -eq 0 ]; then
 DD_=$(date +%d/%m/%Y)
 HHB_=$(date +%H)
 HHE_=72     # 3 days
 INTERVAL_="between to_date('$sysdate','dd/mm/yy hh24:mi:ss') - interval '$HHE_' hour and sysdate"
else
 shift
 DD_=$(awk -F- '{print $1}' <<< "$*")
 HHB_=$(awk -F- '{print $2}' <<< "$*" )
 HHE_=$((awk -F- '{print $3}' | cut -d' ' -f1) <<< "$*")
 HHR_=$(echo $HHE_ | awk '$1!~/:/{print $1}')
# echo "$DD_   $HHB_    $HHE_   $HHR_"
 if [ -n "$HHR_" ]; then
   INTERVAL_="between to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') and to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') + interval '$HHR_' hour + interval '2' minute"
 else
   INTERVAL_="between to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') and to_date('$DD_ $HHE_','dd/mm/yy hh24:mi') + interval '2' minute"
 fi
fi

$SP <<EOF >$LOGF
set lines 230 pages 80 tab off
col BEGIN_TIME for a17 heading '1|BEGIN_TIME'
col AAS for 9999 heading '2|AAS'
col BCPUUPS for 99999 heading '3|BCPUUPS'
col CPUUPS for 99999 heading '4|CPUUPS'
col BLCHPT for 99999 heading '5|BLCHPT'
col ENQREQPT for 99999 heading '6|ENQREQPT'
col execps for 999999 heading '7|EXECPS'
col hcpuups for 99999 heading '8|HCPUUPS'
col IOMBPS for 99999 heading '9|IOMBPS'
col IOPS for 999999 heading '10|IOPS'
col IORL for 99999 heading '11|IORL'
col LOGRPT for 999999 heading '12|LOGRPT'
col lgnps for 99999 heading '13|LGNPS'
col netmbps for 99999 heading '14|NETMBPS'
col PHYR for 999999 heading '15|PHYR'
col PHYRPT for 99999 heading '16|PHYRPT'
col PHYW for 999999 heading '17|PHYW'
col redokbps for 999999 heading '18|REDOKBPS'
col redokbpt for 99999 heading '19|REDOKBPT'
col rsptimpt for 9999999 heading '20|RSPTIMPT'
col SSRT for 9999999 heading '21|SSRT'
col tparspt for 99999 heading '22|TPARSPT'
col UCPS for 9999999 heading '23|UCPS'
col UTPS for 99999 heading '24|UTPS'
col NCPU for 999 heading '25|NCPU'
col instance_number for 99 noprint
prompt "Stat from dba_hist_sysmetric_history dba_hist_snapshot in begin_interval_time $INTERVAL_"
select dhsh.*, oss.ncpu
from (
SELECT  to_char(sn.begin_interval_time,'dd/mm/yy-hh24:mi:ss') begin_time
  , sn.instance_number 
  , ROUND(avg(CASE WHEN metric_name = 'Average Active Sessions'                       THEN m.value END)) aas
  , nvl(ROUND(avg(CASE WHEN metric_name = 'Background CPU Usage Per Sec'                  THEN m.value END)),0) bcpuups
  , nvl(ROUND(avg(CASE WHEN metric_name = 'CPU Usage Per Sec'                             THEN m.value END)),0) cpuups
  , ROUND(AVG(CASE WHEN metric_name = 'DB Block Changes Per Txn'                      THEN m.value END)) blchpt
  , ROUND(AVG(CASE WHEN metric_name = 'Enqueue Requests Per Txn'                      THEN m.value END)) enqreqpt
  , ROUND(avg(CASE WHEN metric_name = 'Executions Per Sec'                            THEN m.value END)) execps
  , nvl(ROUND(avg(CASE WHEN metric_name = 'Host CPU Usage Per Sec'                        THEN m.value END)),0) hcpuups
  , ROUND(avg(CASE WHEN metric_name = 'I/O Megabytes per Second'                      THEN m.value END)) iombps
  , ROUND(avg(CASE WHEN metric_name = 'I/O Requests per Second'                       THEN m.value END)) iops
  , ROUND(AVG(CASE WHEN metric_name = 'Average Synchronous Single-Block Read Latency' THEN m.value END)) iorl
  , ROUND(AVG(CASE WHEN metric_name = 'Logical Reads Per Txn'                         THEN m.value END)) LOGRPT
  , ROUND(avg(CASE WHEN metric_name = 'Logons Per Sec'                                THEN m.value END)) lgnps
  , ROUND(AVG(CASE WHEN metric_name = 'Network Traffic Volume Per Sec'                THEN m.value END)/1048576) netmbps
  , ROUND(avg(CASE WHEN metric_name = 'Physical Reads Per Sec'                        THEN m.value END)) PHYR
  , ROUND(AVG(CASE WHEN metric_name = 'Physical Reads Per Txn'                        THEN m.value END)) PHYRPT
  , ROUND(avg(CASE WHEN metric_name = 'Physical Writes Per Sec'                       THEN m.value END)) PHYW
  , ROUND(avg(CASE WHEN metric_name = 'Redo Generated Per Sec'                        THEN m.value END)/1024) redokbps
  , ROUND(AVG(CASE WHEN metric_name = 'Redo Generated Per Txn'                        THEN m.value END)/1024) redokbpt
  , ROUND(AVG(CASE WHEN metric_name = 'Response Time Per Txn'                         THEN m.value END)*10000) rsptimpt
  , ROUND(AVG(CASE WHEN metric_name = 'SQL Service Response Time'                     THEN m.value END)*10000) ssrt
  , ROUND(AVG(CASE WHEN metric_name = 'Total Parse Count Per Txn'                     THEN m.value END)) tparspt
  , ROUND(avg(CASE WHEN metric_name = 'User Calls Per Sec'                            THEN m.value END)) ucps
  , ROUND(avg(CASE WHEN metric_name = 'User Transaction Per Sec'                      THEN m.value END)) utps
FROM   dba_hist_snapshot sn, dba_hist_sysmetric_history m
WHERE  sn.snap_id = m.snap_id
AND sn.dbid    = m.dbid
AND sn.instance_number = m.instance_number
AND begin_interval_time $INTERVAL_  --sn.begin_interval_time > SYSDATE - 3
GROUP BY    sn.begin_interval_time, sn.instance_number 
ORDER BY    sn.begin_interval_time) dhsh, (SELECT inst_id, VALUE ncpu FROM gv\$osstat WHERE   stat_name = 'NUM_CPUS') oss
 where dhsh.instance_number=oss.inst_id order by to_date(begin_time,'dd/mm/yy-hh24:mi:ss');
EOF
;;
h)
$SP <<EOF >$LOGF
set lines 230 pages 100 tab off
$legend_oratop
$SET_COL_ORATOP
SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */   /*+ NO_MONITOR */
      to_char(begin_time,'dd/mm/yy-hh24:mi:ss') begin_time, 
      ncpu,                           --  'NUM_CPUS'
      trunc(hcpu) hcpub,              --   %CPU      [m,N]: host cpu busy %(busy/busy+idle). (red if > 90%)
      trunc(dcpu) cpuups,             --  'CPU Usage Per Sec'  'CentiSeconds Per Second'
      trunc(load) load,               --   LOAD      [m,N]: current os load. (red if > 2*#cpu and high cpu)
      trunc(dbcp) dctr,               --   DCTR      [m,N]: database cpu time ratio    % Cpu/DB_Time
      trunc(dbwa) dwtr,               --   DWTR      [m,N]: database wait time ratio. (red if > 50 and high ASW)
      trunc(sgfr) spfr,               --   %FR       [s,N]: shared pool free %
      round(upga/1024/1024,0) tpga,   --   PGA       [s,N]: total pga allocated
      sct,                            --   Session Count Total
      trunc(saas) aas,                --   AAS       [s,N]: Average Active Sessions. (red if > #cpu)
      ast,                            --   AST       [c,N]: Active user Sessions Total (ASC+ASI+ASW)
      ascpu,                          --?  ASCPU     [c,N]: active Sessions on CPU
      asio,                           --?  ASIO      [c,N]: active Sessions waiting on user I/O
      aswa,                           --?  ASWA      [c,N]: active Sessions Waiting, non-ASI (red if > ASC+ASI)
      aspq,                           --  'Active Parallel Sessions'
      trunc(utps) utps,               --   UTPS      [s,N]: user transactions per sec
      trunc(ucps) ucps,               --   UCPS    [c,m,N]: user calls per sec
      trunc(ssrt*10000) ssrt,         --   SSRT    [c,m,T]: sql service response time (T/call)
      trunc(mbps) iombps,             --   MBPS      [m,N]: i/o megabytes per second (throughput)
      trunc(iops) iops,               --   IOPS      [m,N]: i/o requests per second
      trunc(iorl) iorl,               --   IORL      [m,T]: avg synchronous single-block read latency in msec (red > 20ms)
      trunc(logr) logr,               --   LOGR      [s,N]: logical reads per sec
      trunc(phyr) phyr,               --   PHYR      [s,N]: physical reads per sec
      trunc(phyw) phyw,               --   PHYW      [s,N]: physical writes per sec
      round(temp/1024/1024,0) temp,   --   TEMP      [s,N]: temp space used (Mb)
      trunc(dbtm) dbtm                --   Database Time Per Sec
  FROM   (  SELECT  begin_time, end_time,
                     SUM(DECODE (metric_name, 'CPU Usage Per Sec', VALUE, 0)) dcpu,
                     SUM(DECODE (metric_name, 'Host CPU Utilization (%)', VALUE, 0)) hcpu,
                     SUM(DECODE (metric_name, 'I/O Megabytes per Second', VALUE, 0)) mbps,
                     SUM(DECODE (metric_name, 'SQL Service Response Time', VALUE, 0)) ssrt,
                     SUM(DECODE (metric_name, 'Average Synchronous Single-Block Read Latency', VALUE, 0)) iorl,
                     SUM(DECODE (metric_name, 'Current OS Load', VALUE, 0)) load,
                     SUM(DECODE (metric_name, 'Active Parallel Sessions', VALUE, 0)) aspq,
                     SUM(DECODE (metric_name, 'Database CPU Time Ratio', VALUE, 0)) dbcp,
                     SUM(DECODE (metric_name, 'Database Wait Time Ratio', VALUE, 0)) dbwa,
                     SUM(DECODE (metric_name, 'I/O Requests per Second', VALUE, 0)) iops,
                     SUM(DECODE (metric_name, 'Shared Pool Free %', VALUE, 0)) sgfr,
                     SUM(DECODE (metric_name, 'User Transaction Per Sec', VALUE, 0)) utps,
                     SUM(DECODE (metric_name, 'User Calls Per Sec', VALUE, 0)) ucps,
                     SUM(DECODE (metric_name, 'Average Active Sessions', VALUE, 0)) saas,
                     SUM(DECODE (metric_name, 'Session Count', VALUE, 0)) sct,
                     SUM(DECODE (metric_name, 'Total PGA Allocated', VALUE, 0)) upga,
                     SUM(DECODE (metric_name, 'Logical Reads Per Sec', VALUE, 0)) logr,
                     SUM(DECODE (metric_name, 'Physical Reads Per Sec', VALUE, 0)) phyr,
                     SUM(DECODE (metric_name, 'Physical Writes Per Sec', VALUE, 0)) phyw,
                     SUM(DECODE (metric_name, 'Temp Space Used', VALUE, 0)) temp,
                     SUM(DECODE (metric_name, 'Database Time Per Sec', VALUE, 0)) dbtm
              FROM   V\$SYSMETRIC_HISTORY
             WHERE   metric_name IN
                             ('CPU Usage Per Sec',
                              'Host CPU Utilization (%)',
                              'I/O Megabytes per Second',
                              'SQL Service Response Time',
                              'Average Synchronous Single-Block Read Latency',
                              'Current OS Load',
                              'Active Parallel Sessions',
                              'Database CPU Time Ratio',
                              'Database Wait Time Ratio',
                              'I/O Requests per Second',
                              'Shared Pool Free %',
                              'User Transaction Per Sec',
                              'User Calls Per Sec',
                              'Logical Reads Per Sec',
                              'Physical Reads Per Sec',
                              'Physical Writes Per Sec',
                              'Temp Space Used',
                              'Database Time Per Sec',
                              'Average Active Sessions',
                              'Session Count',
                              'Total PGA Allocated')
                     AND GROUP_ID in (2,3)
          GROUP BY  begin_time, end_time ),
          (SELECT inst_id id3, TO_NUMBER (VALUE) ncpu  FROM   gv\$osstat  WHERE   stat_name = 'NUM_CPUS')
 , ( select trunc(sample_time, 'mi') sample_time, trunc(avg(asct)) ast, nvl(round((avg(asct)/sum(asct))*sum(cpas)),0) ascpu, nvl(round((avg(asct)/sum(asct))*sum(ioas)),0) asio, nvl(round((avg(asct)/sum(asct))*sum(waas)),0) aswa
from(
SELECT cast(sample_time as date) sample_time,
  COUNT ( * ) asct,
  SUM(DECODE(wait_time, 0, 0, 1)) cpas,
  SUM(DECODE(wait_class, 'User I/O', 1, 0)) ioas,
  SUM(DECODE(wait_time, 0, DECODE (wait_class,'User I/O', 0, 1))) waas
FROM V\$ACTIVE_SESSION_HISTORY
WHERE SESSION_TYPE <> 'BACKGROUND' --AND user_id > 0
group by cast(sample_time as date)
order by sample_time
)
group by trunc(sample_time, 'mi')
order by sample_time
) act_sess
where act_sess.sample_time between begin_time and end_time
ORDER BY to_date(begin_time,'dd/mm/yy-hh24:mi:ss');
EOF
;;
*)
ACTION_=" CASE when '$NLS_VALUE'='$WINCP' then s.action when replace(REGEXP_REPLACE(convert(UNISTR(ASCIISTR(s.action)), '$NLS_VALUE','$WINCP'), '[-*\/_0-9a-zA-Z]', ''), ' ') is null then UTL_RAW.CAST_TO_VARCHAR2(UTL_RAW.CONVERT(UTL_RAW.CAST_TO_RAW(nvl(s.action,' ')),'AMERICAN_AMERICA.$NLS_VALUE', 'AMERICAN_AMERICA.$WINCP')) else s.action end "
$SP <<EOF >$LOGF
set lines 230 pages 100 numw 7 
set echo off feed off veri off tab off timing off
set serveroutput on
$legend_oratop
$SET_COL_ORATOP
SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */   /*+ NO_MONITOR */
      to_char(sysdate,'dd/mm/yy-hh24:mi:ss')  BEGIN_TIME,
      ncpu,                           --'NUM_CPUS'
--      inid,                         --   ID        [c,N]: inst_id (instance id)
      trunc(hcpu) HCPUB,              --   %CPU      [m,N]: host cpu busy %(busy/busy+idle). (red if > 90%)
      trunc(dcpu) CPUUPS,             --'CPU Usage Per Sec'  'CentiSeconds Per Second'
      trunc(load) load,               --   LOAD      [m,N]: current os load. (red if > 2*#cpu "&" high cpu)
      trunc(dbcp) DCTR,               --   DCTR      [m,N]: database cpu time ratio
      trunc(dbwa) DWTR,               --   DWTR      [m,N]: database wait time ratio. (red if > 50 "&" high ASW)
      trunc(sgfr) SPFR,               --   %FR       [s,N]: shared pool free %
      round(upga/1024/1024,0) TPGA,   --   PGA       [s,N]: total pga allocated
--      sct,                          --   SCT       from gv\$sysmetric metric_name, 'Session Count',
      isct SCT,                       --   UST       [c,N]: user Sessions Total (ACT/INA) from gv\$session
      trunc(saas) AAS,                --   AAS       [s,N]: Average Active Sessions. (red if > #cpu)
      asct AST,                       --   AST       [c,N]: Active user Sessions Total (ASC+ASI+ASW)
      cpas ASCPU,                     --?  ASC       [c,N]: active Sessions on CPU
      ioas ASIO,                      --?  ASI       [c,N]: active Sessions waiting on user I/O
      waas ASWA,                      --?  ASW       [c,N]: active Sessions Waiting, non-ASI (red if > ASC+ASI)
      aspq ASPQ,                      --'Active Parallel Sessions'
      trunc(utps) utps,               --   UTPS      [s,N]: user transactions per sec
      trunc(ucps) ucps,               --   UCPS    [c,m,N]: user calls per sec
      trunc(ssrt*10000) ssrt,         --   SSRT    [c,m,T]: sql service response time (T/call)
      trunc(mbps) iombps,             --   MBPS      [m,N]: i/o megabytes per second (throughput)
      trunc(iops) iops,               --   IOPS      [m,N]: i/o requests per second
      trunc(iorl) iorl,               --   IORL      [m,T]: avg synchronous single-block read latency. (red > 20ms)
      trunc(logr) logr,               --   LOGR      [s,N]: logical reads per sec
      trunc(phyr) phyr,               --   PHYR      [s,N]: physical reads per sec
      trunc(phyw) phyw,               --   PHYW      [s,N]: physical writes per sec
      round(temp/1024/1024,0) temp,   --   TEMP      [s,N]: temp space used
      trunc(dbtm) dbtm                --'Database Time Per Sec'
  FROM   (  SELECT   inst_id  inid,
                     SUM(DECODE (metric_name, 'CPU Usage Per Sec', VALUE, 0)) dcpu,
                     SUM(DECODE (metric_name, 'Host CPU Utilization (%)', VALUE, 0)) hcpu,
                     SUM(DECODE (metric_name, 'I/O Megabytes per Second', VALUE, 0)) mbps,
                     SUM(DECODE (metric_name, 'SQL Service Response Time', VALUE, 0)) ssrt,
                     SUM(DECODE (metric_name, 'Average Synchronous Single-Block Read Latency', VALUE, 0)) iorl,
                     SUM(DECODE (metric_name, 'Current OS Load', VALUE, 0)) load, 
                     SUM(DECODE (metric_name, 'Active Parallel Sessions', VALUE, 0)) aspq,
                     SUM(DECODE (metric_name, 'Session Count', VALUE, 0)) sct,
                     SUM(DECODE (metric_name, 'Database CPU Time Ratio', VALUE, 0)) dbcp,
                     SUM(DECODE (metric_name, 'Database Wait Time Ratio', VALUE, 0)) dbwa,
                     SUM(DECODE (metric_name, 'I/O Requests per Second', VALUE, 0)) iops
              FROM   gv\$sysmetric
             WHERE   metric_name IN
                             ('CPU Usage Per Sec',
                              'Host CPU Utilization (%)',
                              'I/O Megabytes per Second',
                              'SQL Service Response Time',
                              'Average Synchronous Single-Block Read Latency',
                              'Current OS Load',
                              'Active Parallel Sessions',
                              'Session Count',
                              'Database CPU Time Ratio',
                              'Database Wait Time Ratio',
                              'I/O Requests per Second')
                     AND GROUP_ID = 2
          GROUP BY   inst_id),
         (  SELECT   inst_id id1,
                     SUM(DECODE (metric_name, 'Shared Pool Free %', VALUE, 0)) sgfr,
                     SUM(DECODE (metric_name, 'User Transaction Per Sec', VALUE, 0)) utps,
                     SUM(DECODE (metric_name, 'User Calls Per Sec', VALUE, 0)) ucps,
                     SUM(DECODE (metric_name, 'Average Active Sessions', VALUE, 0)) saas,
                     SUM(DECODE (metric_name, 'Total PGA Allocated', VALUE, 0)) upga,
                     SUM(DECODE (metric_name, 'Logical Reads Per Sec', VALUE, 0)) logr,
                     SUM(DECODE (metric_name, 'Physical Reads Per Sec', VALUE, 0)) phyr,
                     SUM(DECODE (metric_name, 'Physical Writes Per Sec', VALUE, 0)) phyw,
                     SUM(DECODE (metric_name, 'Temp Space Used', VALUE, 0)) temp,
                     SUM(DECODE (metric_name, 'Database Time Per Sec', VALUE, 0)) dbtm
              FROM   gv\$sysmetric
             WHERE   metric_name IN
                             ('Shared Pool Free %',
                              'User Transaction Per Sec',
                              'User Calls Per Sec',
                              'Logical Reads Per Sec',
                              'Physical Reads Per Sec',
                              'Physical Writes Per Sec',
                              'Temp Space Used',
                              'Database Time Per Sec',
                              'Average Active Sessions',
                              'Total PGA Allocated')
                     AND GROUP_ID = 3
          GROUP BY   inst_id),
         (  SELECT   id2,
                     SUM (asct) asct,
                     SUM (isct) isct,
                     SUM (cpas) cpas,
                     SUM (ioas) ioas,
                     SUM (waas) waas
              FROM   (  SELECT 
                              inst_id id2,
                                 SUM(DECODE (status, 'ACTIVE', 1, 0)) asct, COUNT ( * ) isct,
                                 SUM(DECODE (status, 'ACTIVE', DECODE (wait_time, 0, 0, 1), 0)) cpas,
                                 SUM(DECODE (status, 'ACTIVE', DECODE (wait_class, 'User I/O', 1, 0), 0)) ioas,
                                 SUM(DECODE (status, 'ACTIVE', DECODE (wait_time, 0, DECODE (wait_class,'User I/O', 0, 1), 0), 0)) waas
                          FROM   gv\$session
                         WHERE       TYPE <> 'BACKGROUND'
                                 AND username IS NOT NULL
                                 AND schema# != 0
                      GROUP BY   inst_id
                      UNION ALL
                      SELECT  inst_id id2,
                                 0 asct,
                                 0 isct,
                                 0 cpas,
                                 0 ioas,
                                 0 waas
                          FROM   gv\$instance)
            GROUP BY  id2),
           (SELECT   inst_id id3, TO_NUMBER (VALUE) ncpu
              FROM   gv\$osstat
             WHERE   stat_name = 'NUM_CPUS')
   WHERE   id1 = inid AND id2 = inid AND id3 = inid AND ROWNUM <= 5
ORDER BY   dbtm DESC;

set numw 15
column event for a65 heading "EVENT   (Cumulative Top 5 Timed Events)"
column totwa for 999,999,999,999
column twsec for 999,999,999,999
column AVGMS for 999,999,999.00
column wclas for a15
-- ttitle left "Cumulative Top 5 Timed Events:"
SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */  /*+ NO_MONITOR */
         event,
         totwa,
         twsec,
         avgms,
         ROUND (ratio_to_report (twsec) OVER () * 100) pctwa,
         wclas
--         ,evtid
  FROM   (  SELECT
                  event,
                     SUM (total_waits) totwa,
                     SUM (time_waited) / 100 twsec,
                     AVG (average_wait) * 10 avgms,
                     wait_class wclas,
                     event_id evtid
              FROM   gv\$system_event
             WHERE   wait_class <> 'Idle'
          GROUP BY   event, wait_class, event_id
            HAVING   SUM (total_waits) > 0
          UNION
          SELECT
                  'DB CPU'
                   event,
                   0 totwa,
                   SUM (VALUE) / 100 twsec,
                   0 avgms,
                   NULL wclas,
                   19 evtid
            FROM   gv\$sysstat
           WHERE   name LIKE '%CPU used by this session%'
          ORDER BY   twsec DESC)
 WHERE   ROWNUM < 6;
ttitle off
-- ttitle left "Real-Time Top 5 Timed Events:"
column event for a65 heading "EVENT   (Real-Time Top 5 Timed Events)"
column totwa for 999,999,999,999
column twsec for 999,999,999,999
column AVGMS for 999,999,999.00
column wclas for a15
SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */  /*+ NO_MONITOR */
      event,
      totwa,
      twsec,
      avgms,
      ROUND (ratio_to_report (twsec) OVER () * 100) pctwa,
      wclas
--      ,evtid
  FROM   (  SELECT   sw .event,
                     SUM (se.total_waits) totwa,
                     SUM (se.time_waited) / 100 twsec,
                     SUM (se.time_waited) / (GREATEST (SUM (se.total_waits), 1) * 10)
                     avgms,
                     sw.wait_class wclas,
                     sw.event# evtid
              FROM   gv\$session_wait_class se  JOIN   gv\$session sw
                     ON se.inst_id = sw.inst_id AND se.sid = sw.sid
             WHERE   se.wait_class != 'Idle' AND sw.wait_class != 'Idle'
          GROUP BY   sw.event, sw.wait_class, sw.event#
            HAVING   SUM (se.total_waits) > 0
          UNION
          SELECT   'DB CPU' event,
                   0 totwa,
                   SUM (VALUE) / 100 twsec,
                   0 avgms,
                   NULL wclas,
                   19 evtid
            FROM  gv\$sesstat se JOIN  gv\$session s2
                   ON se.inst_id = s2.inst_id AND se.sid = s2.sid
           WHERE   se.statistic# = 19
                   AND se.VALUE > 0
                   AND s2.wait_class != 'Idle'
          ORDER BY   twsec DESC)
 WHERE   ROWNUM < 6;
ttitle off

column PID4 for a8   HEADING "PPID"
column SID4 for 99999 HEADING "SID"
column SERIAL for 99999 HEADING "SERIAL"
column USR4 for a16  HEADING "USERNAME"
column PRG4 for a22  HEADING "PROGRAM"
column MODL for a22  HEADING "MODULE"
column ACTN for a22  HEADING "ACTION"
column pma for a60   HEADING "PROGRAM / MODULE / ACTION"
column PGAU for 9999 HEADING "PGA"
column OPN for a6    HEADING "CMD"
column SQID for a13  HEADING "SQLID"
column PLSQL_ENTRY for a32  HEADING "PLSQL_ENTRY" truncate
column ST4 for a1
column SU4 for a3    HEADING "STE"
column EV4 for a24   HEADING "EVENT/*LATCH"
-- column WC4 for a11   HEADING "WAIT_CLASS"
column SIW for 99999999 HEADING "W/T s"
column lcet for 99999999 HEADING "LCET m"
ttitle left "Database active sessions:"
  SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */ /*+ NO_MONITOR */
--           s.wait_time trm4,
--           s.inst_id id4,
           p.spid pid4,
           s.sid sid4,
           s.serial# serial,
           substr(DECODE (p.background, 1, 'B/G',DECODE (s.username, NULL, 'F/G', s.username)),1,16) usr4,
--           substr(DECODE (p.pname, NULL, s.program, p.pname),1,22) prg4,
--           substr(s.module,1,22) modl,
--           substr(s.action,1,22) actn,
--!           substr(DECODE(p.pname, NULL, s.program, p.pname)||' / '||case when s.module<>p.pname then s.module else '' end ||' / '||s.action,1,60) pma,
           substr(DECODE(p.pname, NULL, s.program, p.pname)||' / '||case when s.module<>p.pname then s.module else '' end ||' / '|| $ACTION_  ,1,60) pma,
--           substr(DECODE(p.pname, NULL, s.program, p.pname)||' / '||case when s.module<>p.pname then s.module else '' end ||' / '||convert(s.action, 'AL32UTF8','CL8MSWIN1251'),1,60) pma,
--           substr(DECODE(p.pname, NULL, s.program, p.pname)||' / '||case when s.module<>p.pname then s.module else '' end ||' / '||regexp_replace(s.action, '[^[:print:]]', ''), 1, 60) pma,
           trunc(p.pga_used_mem/1024/1024) pgau,
--           p.pga_alloc_mem pgac,
--           p.pga_freeable_mem pgaf,
--           x.pgax pgax,
           substr(c.command_name,1,6) opn,
           DECODE (s.plsql_subprogram_id, NULL, s.sql_id, NULL) sqid,
	   o.owner || CASE WHEN o.object_name is null THEN null ELSE '.' END || o.object_name PLSQL_ENTRY,
--           DECODE (s.final_blocking_session_status,'VALID', TO_CHAR (s.final_blocking_instance)|| ':' || TO_CHAR (s.final_blocking_session), NULL) bses,
           substr(s.status,1,1) st4,
           substr(DECODE(s.state,'WAITING',DECODE (s.wait_class, 'User I/O', 'I/O', s.state),'CPU'),1,3) su4,
           CASE
               WHEN s.state <> 'WAITING' AND s.time_since_last_wait_micro < 1000000
               THEN 'cpu runqueue'
               ELSE substr(event,1,24)
           END ev4,
--           substr(s.wait_class,1,11) wc4,
           s.wait_time_micro/1000000 siw,
           s.last_call_et/60 lcet
--           s.server sded,
--           s.service_name svcn,
--           DECODE (n.name, NULL, NULL, '*' || n.name) lp2n,
--           DECODE (s.row_wait_obj#, -1,NULL,SUBSTR (TO_CHAR (s.row_wait_file#)|| ':' || TO_CHAR (s.row_wait_block#),1,24)) fbon
     FROM  gv\$session s JOIN gv\$process p
       ON (p.inst_id = s.inst_id AND p.addr = s.paddr)
     LEFT OUTER JOIN  dba_objects o
       on  (s.PLSQL_ENTRY_OBJECT_ID=o.object_id)
     LEFT OUTER JOIN v\$sqlcommand c
       ON (s.command = c.command_type)
     LEFT OUTER JOIN v\$latchname n
       ON (s.p2 = n.latch#),
           (SELECT inst_id, MAX (pga_max_mem) pgax FROM gv\$process GROUP BY inst_id) x
   WHERE   x.inst_id = s.inst_id AND  s.status <> 'INACTIVE' AND s.type <> 'BACKGROUND' and s.username IS NOT NULL  -- and s.wait_class <> 'Idle'
ORDER BY lcet desc,  siw DESC;
EOF
;;
esac
logf
}


parameters()
{
P1_="$1"
shopt -s nocasematch
case "$P1_" in
services)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
set lines 230
col host_name    format a40
col service_name format a25
col network_name format a25
prompt v\$services:
select (select host_name from v\$instance) host_name, name service_name,  network_name from v\$services;
col name format a25
prompt gv\$active_services:
select service_id,name,  network_name, creation_date from  gv\$active_services order by service_id;
EOF
;;
dir)
$SP <<EOF >$LOGF
set echo off feed off veri off tab off pages 50
set lines 230
col OWNER for a20
col DIRECTORY_NAME for a30
col DIRECTORY_PATH for a80
prompt dba_directories:
SELECT * FROM dba_directories order by owner,directory_name;
EOF
;;
ph)
shift
if ( grep -q "FALSE" <<< "$1" ); then 
  S0_="and isdefault='FALSE'"
  shift
  P2_="FALSE"
fi
P1_=$( tr '[:upper:]' '[:lower:]' <<<  "$1" )

$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column parameter for a43
column Description for a70
column "Sess Value" for a40
column "DefSessVal" for a10
column "Inst Value" for a40
column "DefInstVal" for a10
SELECT a.ksppinm  "Parameter", a.ksppdesc "Description", b.ksppstvl "Sess Value", b.ksppstdf "DefSessVal", c.ksppstvl "Inst Value", c.ksppstdf "DefInstVal"
FROM  x\$ksppi a, x\$ksppcv b, x\$ksppsv c WHERE  a.indx = b.indx AND a.indx = c.indx AND a.ksppinm LIKE '%$P1_%' and c.ksppstdf like  nvl('$P2_','%')
order by a.ksppinm;
EOF
;;
p)
shift
if ( grep -q "FALSE" <<< "$1" ); then S0_="and isdefault='FALSE'"; shift; fi
P2_="$( tr '[:upper:]' '[:lower:]' <<<  "$@" )"
if ( grep -q ' ' <<< "$P2_" ) ; then 
  P2_=$( echo "('"$P2_"')" | sed "s/ /','/g") 
  S1_="name in $P2_"
else 
  S1_="name like '%"$P2_"%'"
fi

$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column name for a43
column type for a11
column isdefault for a9
column ISMODIFIED for a10
column value for a50
column Description for a70
select name,decode(type,'1','Boolean',2,'String',3,'Integer',4,'Parameter file',5,'Reserved',6,'Big integer') type,value,isdefault,ISMODIFIED,description from v\$system_parameter where $S1_ $S0_ order by name;
EOF
;;
esac
logf
}



db()
{
P1_="$1"
shopt -s nocasematch
case "$P1_" in
properties)
$SP <<EOF > $LOGF
set lines 230
set echo off feed off veri off tab off pages 240
prompt
prompt database_properties:
set pages 50
column PROPERTY_NAME for a40
column PROPERTY_VALUE for a40
column DESCRIPTION for a55
SELECT PROPERTY_NAME,PROPERTY_VALUE,DESCRIPTION FROM database_properties order by PROPERTY_NAME;
EOF
;;
nls)
$SP <<'END' > $LOGF
set lines 230
set echo off feed off veri off tab off pages 240
column parameter for a30
column value for a40
select * from nls_database_parameters order by parameter;
END
;;
option)
$SP <<'END' > $LOGF
set lines 230
set echo off feed off veri off tab off pages 240
column parameter for a50
column value for a20
select * from v$option order by parameter;
END
;;
fusage)
$SP <<'END' > $LOGF
set lines 230
set echo off feed off veri off tab off pages 120
prompt
prompt DBA_FEATURE_USAGE_STATISTICS:
column name for a70
column verion for a10
column detected_usages for 9999999
column currently_used for 999999
column first_usage_date for a20
column last_usage_date for a20
--select name,version,detected_usages,currently_used,first_usage_date,last_usage_date from DBA_FEATURE_USAGE_STATISTICS where version=(select version from v$instance) and  detected_usages>0 order by name;
select u1.name, u1.version, u1.detected_usages, u1.currently_used,first_usage_date,last_usage_date
from   dba_feature_usage_statistics u1
where  u1.version = (select max(u2.version) from   dba_feature_usage_statistics u2 where  u2.name = u1.name)
and    u1.detected_usages > 0
and    u1.version=(select version from v$instance)
and    u1.dbid = (select dbid from v$database)
order by name;
END
;;
*)
 SQL_TEXT="select dbid,name,to_char(created,'dd/mm/yyyy') created,log_mode, resetlogs_time,open_mode,database_role,current_scn,protection_level,switchover_status,force_logging,supplemental_log_data_min,FLASHBACK_ON,platform_name from v\$database;"
SQL_TEXT12="prompt DBA_REGISTRY_SQLPATCH:
      col INSTALL_ID for 99
      col action for a10
      col action_time for a10
      col status for a9
      col flags for a2
      col DESCRIPTION for a28
      col LOGFILE    for a27
      col RU_LOGFILE    for a27
      col PATCH_DIRECTORY for a10 noprint
      col SOURCE_BUILD_DESCRIPTION for a15
      col TARGET_BUILD_DESCRIPTION for a15
      col SOURCE_BUILD_TIMESTAMP for a10  noprint
      col TARGET_BUILD_TIMESTAMP for a10
"
 REL=$(db_version)
 VERSION="VERSION" ; BANNER="BANNER"
 case $REL in
   9|10|11)  SQL_TEXT="select dbid,name,to_char(created,'dd/mm/yyyy') created,log_mode, resetlogs_time,open_mode,database_role,protection_level,switchover_status,force_logging,supplemental_log_data_min from v\$database;" ;;
   12)       SQL_TEXT12_=$SQL_TEXT12; SQL_TEXT_2="select PATCH_ID, PATCH_UID VERSION, ACTION, STATUS, ACTION_TIME, DESCRIPTION from DBA_REGISTRY_SQLPATCH order by action_time;"  ;;
   18|19|21) SQL_TEXT12_=$SQL_TEXT12; SQL_TEXT_2="select PATCH_ID, PATCH_UID, PATCH_TYPE, ACTION, STATUS, ACTION_TIME, DESCRIPTION, LOGFILE, RU_LOGFILE, SOURCE_VERSION, SOURCE_BUILD_DESCRIPTION, TARGET_VERSION, TARGET_BUILD_DESCRIPTION, TARGET_BUILD_TIMESTAMP from DBA_REGISTRY_SQLPATCH order by action_time;"
	      VERSION="VERSION_FULL" ; BANNER="BANNER_FULL" ;;
  esac
$SP <<EOF > $LOGF
set lines 230 timing off
set echo off feed off veri off tab off pages 50
show pdbs
prompt v\$instance:
column instance_name for a15
column host_name for a30
column version for a10
column status for a10
column ARCHIVER for a10
column LOGINS for a10
column DATABASE_STATUS for a15
column instance_role for a20
select INSTANCE_NAME, HOST_NAME, $VERSION, STARTUP_TIME,STATUS, ARCHIVER, LOGINS, DATABASE_STATUS, INSTANCE_ROLE from v\$instance;
prompt
prompt v\$database:
column current_scn for 99999999999999
column resetlogs_time for a19 heading "RESLOGTIME"
column dbid for 99999999999
column name for a8
column created for a10
column LOG_MODE for a13
column open_mode for a20
column database_role for a20 heading "DB_ROLE"
column protection_level for a20 heading "PROTECTION_LEVEL"
column switchover_status for a15 heading "SWITCH_STATUS"
column force_logging for a8 heading "FORCELOG"
column supplemental_log_data_min for a8 heading "SUPPLLOG"
column FLASHBACK_ON for a9 heading "FLASHB_ON"
column platform_name for a28
$SQL_TEXT
col banner for a81
col banner_full for a91
select $BANNER from v\$version;
EOF

$SP <<END >> $LOGF
set lines 230 timing off
set echo off feed off veri off tab off pages 40 
column COMP_ID for a10
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'DD/MM/YYYY HH24:MI:SS';
column COMP_NAME for a40
column VERSION  for a12
column VERSION_FULL  for a12
column STATUS for a12
column MODIFIED for a20
column SCHEMA for a15
column procedure for a45
prompt
prompt DBA_REGISTRY:
select comp_id, comp_name, $VERSION, status, modified, schema, procedure from dba_registry;
column action_time for a19
column action for a15
column namespace for a15
column version for a15
column comments for a70
column BUNDLE_SERIES for a20
prompt
prompt REGISTRY\$HISTORY:
select * from sys.registry\$history;
$SQL_TEXT12_
$SQL_TEXT_2
END
;;
esac
logf
}



audit()
{
P1_="$1"
shift
sysdate=$(date +%d/%m/%y\ %H:%M:%S)
if [ $(is_number $(awk -F"/" '{print $1}' <<< "$*")) -eq 0 ]; then
 DD_=$(date +%d/%m/%Y)
 HHB_=$(date +%H)
 HHE_=1
 INTERVAL_="between to_date('$sysdate','dd/mm/yy hh24:mi:ss') - interval '$HHE_' hour and sysdate"
else
 DD_=$(awk -F- '{print $1}' <<< "$*")
 HHB_=$(awk -F- '{print $2}' <<< "$*")
 HHE_=$((awk -F- '{print $3}' | cut -d' ' -f1) <<< "$*")
 HHR_=$(awk '$1!~/:/{print $1}' <<< "$HHE_")
 if [ -n "$HHR_" ]; then
   INTERVAL_="between to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') and to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') + interval '$HHR_' hour +  interval '2' minute"
 else
   INTERVAL_="between to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') and to_date('$DD_ $HHE_','dd/mm/yy hh24:mi') + interval '2' minute"
 fi
fi


case "$P1_" in
1017)
[[ -n "$2" ]] && USR_="$2" || USR_="%"
$SP <<EOF > $LOGF
set lines 230
set echo off feed off veri off tab off pages 240 numw 6
column OS_USERNAME for a20
column USERNAME for a30
column USERHOST for a30
column TERMINAL for a30
column dd for a20
PROMPT "dba_audit_trail for username like $USR_ and returncode in ('1017','28000') for a period $INTERVAL_ :"
select username, os_username, userhost, terminal, cast(timestamp as date) date_time, action_name, returncode from dba_audit_trail 
where username like '$USR_'
--and userhost='VL20-SRV64'
and timestamp $INTERVAL_
and returncode in ('1017','28000') 
and returncode <> '0'
order by date_time;
EOF
;;
obj)
[[ -n "$2" ]] && OBJ_="$2" || OBJ_="%"
$SP <<EOF > $LOGF
set lines 230
set echo off feed off veri off tab off pages 240 numw 6
column date_time for a20
column owner for a20
column obj_name for a35
column action_name  for a17
column OS_USERNAME for a20
column USERNAME for a30
column USERHOST for a30
column TERMINAL for a30
PROMPT "dba_audit_trail for obj_name like $OBJ_ for a period $INTERVAL_ :"
select cast(timestamp as date) date_time, owner||'.'||obj_name obj_name, action_name, username, os_username, userhost, terminal
from dba_audit_trail
where obj_name like upper('$OBJ_')
and timestamp $INTERVAL_
order by date_time;
EOF
;;
maxcon)
[[ -n "$2" ]] && CNT_="$2" || CNT_="100"
$SP <<EOF > $LOGF
set lines 230
set echo off feed off veri off tab off pages 240 numw 6
col OS_USERNAME for a30
col USERNAME for a20
col USERHOST  for a40
col TERMINAL for a20
col hh24 for a15
PROMPT "dba_audit_trail where from the db connections above $CNT_ for a period $INTERVAL_ grouped by hour:"
select username,os_username,userhost,terminal, to_char(cast(timestamp as date), 'dd/mm/yyyy hh24') hh24, count(*) count
from dba_audit_trail
where timestamp $INTERVAL_
and action=100
group by username,os_username,userhost,terminal,to_char(cast(timestamp as date), 'dd/mm/yyyy hh24') 
having count(*) >= $CNT_
order by hh24, count desc;
EOF
;;
login)
LST='
ADAMS/wood
ADMIN/jetspeed
ADMIN/welcome
ADMINISTRATOR/admin
ALHRO/xxx
ALHRW/xxx
ANDY/swordfish
ANONYMOUS/invalid
APPLSYS/apps
APPLSYS/fnd
APPLSYSPUB/fndpub
APPLSYSPUB/pub
APPLYSYSPUB/fndpub
APPLYSYSPUB/pub
APPLYSYSPUB/unknown
APPS_MRC/apps
APPUSER/apppassword
ATM/sampleatm
AURORA$JIS$UTILITY$/invalid
AURORA$ORB$UNAUTHENTICATED/invalid
BLAKE/paper
BRUGERNAVN/adgangskode
BRUKERNAVN/password
CALVIN/hobbes
CDEMO82/cdemo83
CDEMO82/unknown
CIS/zwerg
CISINFO/zwerg
CLARK/cloth
CLKANA/unknown
CLKRT/unknown
CQSCHEMAUSER/password
CQUSERDBUSER/password
CTXSYS/change_on_install
CTXSYS/unknown
DATA_SCHEMA/laskjdf098ksdaf09
DBI/mumblefratz
DCM/unknown
DDIC/199220706
DIANE/passwo1
DISCOVERER5/unknown
DPF/dpfpass
DSGATEWAY/unknown
EARLYWATCH/support
EJSADMIN/ejsadmin_password
ESTOREUSER/estore
FOO/bar
FROSTY/snowman
HR/change_on_install
HR/unknown
INTERNAL/oracle
INTERNAL/sys_stnt
IP/dip
IX/change_on_install
JAKE/passwo4
JILL/passwo2
JONES/steel
JWARD/airoplane
LIBRARIAN/shelves
MARK/passwo3
MASCARM/manager
MASTER/password
MDDEMO_CLERK/clerk
MDDEMO_CLERK/mgr
MDDEMO_MGR/mgr
MMO2/mmo3
MMO2/unknown
MODTEST/yes
MTS_USER/mts_password
NNEUL/nneulpass
NOMEUTENTE/password
NOME_UTILIZADOR/senha
NOM_UTILISATEUR/mot_de_passe
NUME_UTILIZATOR/parol
OAIHUB902/unknown
OAS_PUBLIC/unknown
OCM_DB_ADMIN/unknown
ODM_MTR/mtrpw
OE/change_on_install
OE/unknown
OEM_REPOSITORY/unknown
OLAPSVR/instance
OLAPSYS/manager
OMWB_EMULATION/oracle
ORACACHE/unknown
ORADBA/oradbapass
ORANGE/unknown
ORCLADMIN/welcome
ORD_SERVER/ods
OSE$HTTP$ADMIN/invalid
OSSAQ_HOST/unknown
OSSAQ_PUB/unknown
OSSAQ_SUB/unknown
OWF_MGR/unknown
PLSQL/supersecret
PM/change_on_install
PM/unknown
PORTAL/unknown
PORTAL30/portal31
PORTAL_APP/unknown
PORTAL_DEMO/unknown
PORTAL_PUBLIC/unknown
QS/change_on_install
QS/unknown
QS_ADM/change_on_install
QS_ADM/unknown
QS_CB/change_on_install
QS_CB/unknown
QS_CBADM/change_on_install
QS_CBADM/unknown
QS_CS/change_on_install
QS_CS/unknown
QS_ES/change_on_install
QS_ES/unknown
QS_OS/change_on_install
QS_OS/unknown
QS_WS/change_on_install
QS_WS/unknown
REPORTS_USER/oem_temp
REP_MANAGER/demo
REP_OWNER/demo
REP_USER/demo
SAP/06071992
SAP/sapr3
SAPR3/sap
SCOTT/tiger
SCOTT/tigger
SH/change_on_install
SH/unknown
SLIDE/slidepw
SPOT/pots
STRAT_USER/strat_passwd
SYS/0racle
SYS/change_on_install
SYS/manager
SYS/oracle
SYS/syspass
SYSADMIN/unknown
SYSMAN/oem_temp
SYSTEM/0racle
SYSTEM/change_on_install
SYSTEM/manager
SYSTEM/oracle
SYSTEM/systempass
TALBOT/mt6ch5
TEC/tectec
TEST/passwd
THINSAMPLE/thinsamplepw
TRACESVR/trace
UDDISYS/unknown
USER_NAME/password
USUARIO/clave
UTLBSTATU/utlestat
VIF_DEVELOPER/vif_dev_pwd
VPD_ADMIN/akf7d98s2
VRR1/unknown
VRR1/vrr2
WEBSYS/manager
WEBUSER/your_pass
WIRELESS/unknown
WKPROXY/change_on_install
WKPROXY/unknown
WKSYS/change_on_install
WK_PROXY/unknown
WK_SYS/unknown
XDB/change_on_install
'
FNAME="tpi_check_passwd.sh"
if [ -n "${ls2}" ]; then
  TNS="@\"${ls2}"
else 
  TNS="\""
  COND1="and username <> 'SYS'"
fi
echo "set lines 350 pages 0 echo off termout off feedback off" >> login.sql
$SP  <<EOF > /dev/null 
set lines 350 pages 0 echo off termout off feedback off echo off timing off
col cmd for a350
spool $FNAME
select q'[echo "select ']'||username||'/'||lower(username)||' - CONNECTED'' from dual;" | sqlplus -S '||username||'/'||lower(username)||'${TNS}'||decode(username,'SYS',' as sysdba')||'"' cmd  from dba_users  where account_status='OPEN' $COND1 order by username;
spool off
EOF

for U in $LST; do
  username=$(echo $U | awk -F"/" '{print $1}')
  if [ "$username" = "SYS" ]; then
      echo "echo 'select "${U}" cmd dual;' | sqlplus -S ${U}${TNS} as sysdba\"" >> $FNAME
  else
     echo "echo 'select "${U}" cmd dual;' | sqlplus -S ${U}${TNS}\"" >> $FNAME
  fi
done

echo "Wait... Check users for account_status='OPEN' and simple password:"
chmod u+x $FNAME
./$FNAME | egrep ' \- CONNECTED'  > $LOGF
rm $FNAME login.sql
;;
*)
$SP <<EOF > $LOGF
set lines 230
set echo off feed off veri off tab off pages 240
select 'AUDIT '||m.name||decode(u.name,'PUBLIC',' ',' BY "'||u.name||'"')||
       decode(nvl(a.success,0)  + (10 * nvl(a.failure,0)),
       1, ' BY SESSION WHENEVER SUCCESSFUL ',
       2, ' BY ACCESS WHENEVER SUCCESSFUL ',
       10,' BY SESSION WHENEVER NOT SUCCESSFUL ',
       11,' BY SESSION ',   -- default
       20,' BY ACCESS WHENEVER NOT SUCCESSFUL ',
       22,' BY ACCESS',' /* not possible */ ')||' ;'
 "AUDIT STATEMENT"
        FROM audit$ a, user$ u, sys.stmt_audit_option_map m
        WHERE a.user# = u.user# AND a.option# = m.option#
              and bitand(m.property, 1) != 1  and a.proxy# is null
              and a.user# <> 0
        UNION
select 'AUDIT '||m.name||decode(u1.name,'PUBLIC',' ',' BY "'||u1.name||'"')||
       ' ON BEHALF OF '|| decode(u2.name,'SYS','ANY',u2.name)||
       decode(nvl(a.success,0)  + (10 * nvl(a.failure,0)),
       1,' WHENEVER SUCCESSFUL ',
       2,' WHENEVER SUCCESSFUL ',
       10,' WHENEVER NOT SUCCESSFUL ',
       11,' ',   -- default
       20, ' WHENEVER NOT SUCCESSFUL ',
       22, ' ',' /* not possible */ ')||';'
 "AUDIT STATEMENT"
     FROM audit$ a, user$ u1, user$ u2, sys.stmt_audit_option_map m
     WHERE a.user# = u2.user# AND a.option# = m.option# and a.proxy# = u1.user#
              and bitand(m.property, 1) != 1  and a.proxy# is not null
UNION
select 'AUDIT '||p.name||decode(u.name,'PUBLIC',' ',' BY "'||u.name||'"')||
       decode(nvl(a.success,0)  + (10 * nvl(a.failure,0)),
       1,' BY SESSION WHENEVER SUCCESSFUL ',
       2,' BY ACCESS WHENEVER SUCCESSFUL ',
       10,' BY SESSION WHENEVER NOT SUCCESSFUL ',
       11,' BY SESSION ',   -- default
       20, ' BY ACCESS WHENEVER NOT SUCCESSFUL ',
       22, ' BY ACCESS',' /* not possible */ ')||' ;'
 "AUDIT STATEMENT"
        FROM audit$ a, user$ u, sys.system_privilege_map p
        WHERE a.user# = u.user# AND a.option# = -p.privilege
              and bitand(p.property, 1) != 1 and a.proxy# is null
         and a.user# <> 0
UNION
select 'AUDIT '||p.name||decode(u1.name,'PUBLIC',' ',' BY "'||u1.name||'"')||
       ' ON BEHALF OF '|| decode(u2.name,'SYS','ANY',u2.name)||
       decode(nvl(a.success,0)  + (10 * nvl(a.failure,0)),
       1,' WHENEVER SUCCESSFUL ',
       2,' WHENEVER SUCCESSFUL ',
       10,' WHENEVER NOT SUCCESSFUL ',
       11,' ',   -- default
       20, ' WHENEVER NOT SUCCESSFUL ',
       22, ' ',' /* not possible */ ')||';'
 "AUDIT STATEMENT"
   FROM audit$ a, user$ u1, user$ u2, sys.system_privilege_map p
   WHERE a.user# = u2.user# AND a.option# = -p.privilege and a.proxy# = u1.user#
              and bitand(p.property, 1) != 1 and a.proxy# is not null;
EOF
;;
esac
logf
}


sga()
{
$SP <<'EOF' >$LOGF
set lines 230 numw 15
set echo off feed off veri off tab off pages 60 timing off
prompt Size of total v$sga:
SELECT round(sum(value)/1024/1024,2) TOTAL_SGA_MB FROM v$sga;
col component for a40
prompt Size of v$sga_dynamic_components :
BREAK ON REPORT
COMPUTE sum OF CURRENT_SIZE_Mb on report
COMPUTE sum OF MIN_SIZE_Mb on report
COMPUTE sum OF MAX_SIZE_Mb on report
select COMPONENT,CURRENT_SIZE/1024/1024 CURRENT_SIZE_Mb, MIN_SIZE/1024/1024 MIN_SIZE_Mb, MAX_SIZE/1024/1024 MAX_SIZE_Mb from v$sga_dynamic_components;


prompt Size of db_cache_size:
col name for a20
col resize_state for a20
select name,block_size,resize_state,current_size,buffers,target_size,target_buffers,prev_size,prev_buffers from V$BUFFER_POOL;

prompt 
prompt Sizes in v$sgastat:
col Mbytes for 999999999999
col pool for a20
select * from v$sgastat where pool is null;
select to_number(p.value) value, v$sgastat.pool, v$sgastat.bytes,
case when p.value<>0 then round((v$sgastat.bytes/p.value)*100,2) else round(to_number(p.value),2) end "Percent Free"
from v$sgastat, v$system_parameter p
where v$sgastat.name = 'free memory'
and p.name = 'shared_pool_size';


prompt
prompt Sizes in v$sga_resize_ops:
col oper_type for a20
col oper_mode for a20
COL COMPONENT FORMAT A25
COL INITIAL_SIZE FORMAT A10
COL FINAL_SIZE FORMAT A10
SPOOL ASMM_RESIZE.TXT
select START_TIME, component, oper_type, oper_mode, initial_size/1024/1024 "INITIAL_MB", FINAL_SIZE/1024/1024 "FINAL_MB", END_TIME
from v$sga_resize_ops
where component in ('DEFAULT buffer cache', 'shared pool') and status = 'COMPLETE'
order by start_time, component;

prompt
prompt Shared pool details and autocalculate:
column remarks for a70
select /*+ rule */ to_number(value) shared_pool_size, 
                         sum_obj_size,
                         sum_sql_size, 
                         sum_user_size, 
(sum_obj_size + sum_sql_size+sum_user_size)* 1.3 min_shared_pool
  from (select sum(sharable_mem) sum_obj_size 
          from v$db_object_cache where type <> 'CURSOR'),
               (select sum(sharable_mem) sum_sql_size
          from v$sqlarea),
               (select sum(250 * users_opening) sum_user_size
          from v$sqlarea), v$system_parameter
 where name = 'shared_pool_size';

prompt 
prompt Shared pool usage:
column name for a40
select 'Data Dictionary cache' Name,
        round((SUM(GETS - GETMISSES - USAGE - FIXED)) / SUM(GETS) * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$ROWCACHE
union all
select 'Library cache' Name,
        round((SUM(PINS - RELOADS)) / SUM(PINS) * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$LIBRARYCACHE
union all
select 'Index usage ratio' Name,
        round(sum(decode(name,'table fetch by rowid',value,0))
            / sum(decode(name,'table fetch by rowid',value,'table scans (short tables)',value,'table scans (long tables)',value,0))
            * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$SYSSTAT
union all
select 'Memory usage in Sorts ratio' Name,
        round(sum(decode(name,'sorts (memory)',value,0))
            / sum(decode(name,'sorts (memory)',value,'sorts (disk)',value,0))
            * 100,4) Ratio,
        'Relatively of sorting in Memories to all sorting' Remarks
    from V$SYSSTAT
union all
select 'Cache hit ratio' Name,
        round((1 - sum(decode(name,'physical reads',value,0))
            / sum(decode(name,'db block gets',value,'consistent gets',value,0))
        ) * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$SYSSTAT
union all
select 'Buffer pool ' || Name || ' hit ratio' Name,
        round((1 - physical_reads
            / (db_block_gets+consistent_gets)
        ) * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$BUFFER_POOL_STATISTICS  where name in ('DEFAULT','KEEP')
union all
select 'Average buffers scanned' Name,
        round(1 + sum(decode(name,'free buffer inspected',value,0))
           / sum(decode(name,'free buffer requested',value,0)),4),
        'Must be 1..2, if more than 2 -- not enough buffers for server' Remarks
    from V$SYSSTAT
union all
select 'Average dirty buffers' Name,
        round(sum(decode(name,'dirty buffers inspected',value,0))
        / sum(decode(name,'free buffer inspected',value,1)),4),
        'Must be <, if too much "dirty" -- not enough buffers for server' Remarks
    from V$SYSSTAT
union all
select 'Shared pool free memory (MB)' Name,
        round(bytes/1024/1024,4) Ration,
        'If too much free memory -- may be excess of mem ?' Remarks
    from V$SGASTAT
    where name = 'free memory'
        and pool = 'shared pool';
EOF
logf
}

pga()
{
$SP <<'EOF' >$LOGF
set lines 170
set echo off feed off veri off tab off pages 80
COLUMN sid FORMAT 9999 HEADING 'SID'
COLUMN username FORMAT a15 HEADING 'Oracle User' JUSTIFY right TRUNC
COLUMN osuser FORMAT a15 HEADING 'O/S User' JUSTIFY right TRUNC
COLUMN program FORMAT a28 HEADING 'Session Program' TRUNC
COLUMN machine FORMAT a20 HEADING 'Machine' JUSTIFY right TRUNC
COLUMN session_pga_memory FORMAT 9,999,999,999 HEADING 'PGA Memory'
COLUMN session_pga_memory_max FORMAT 9,999,999,999 HEADING 'PGA Memory Max'
COLUMN session_uga_memory FORMAT 9,999,999,999 HEADING 'UGA Memory'
COLUMN session_uga_memory_max FORMAT 9,999,999,999 HEADING 'UGA Memory MAX'
SELECT /*+ RULE */
s.sid sid
, s.username
, s.osuser
, s.program
, s.machine 
, (select ss.value from v$sesstat ss, v$statname sn
where ss.sid = s.sid and
sn.statistic# = ss.statistic# and
sn.name = 'session pga memory') session_pga_memory
, (select ss.value from v$sesstat ss, v$statname sn
where ss.sid = s.sid and
sn.statistic# = ss.statistic# and
sn.name = 'session pga memory max') session_pga_memory_max
, (select ss.value from v$sesstat ss, v$statname sn
where ss.sid = s.sid and
sn.statistic# = ss.statistic# and
sn.name = 'session uga memory') session_uga_memory
, (select ss.value from v$sesstat ss, v$statname sn
where ss.sid = s.sid and
sn.statistic# = ss.statistic# and
sn.name = 'session uga memory max') session_uga_memory_max
FROM
v$session s
ORDER BY session_pga_memory DESC
/
EOF
logf
}

segment()
{
P1_="$1"
P2_="$2"
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 80
column owner for a20
column segment_name for a30
column segment_type for a15
column PARTITION_NAME for a50
column SEGMENT_SUBTYPE for a15
column max_size for 999,999,999,999
column tablespace_name for a22
ttitle left "Segment name from DBA_SEGMENTS:"
BREAK ON REPORT
COMPUTE SUM LABEL 'SUM' OF size_Mb on report
select tablespace_name, owner, segment_name, PARTITION_NAME, segment_type, SEGMENT_SUBTYPE, bytes/(1024*1024) size_Mb, blocks, max_size
from dba_segments where segment_name like upper('$P1_') and owner like nvl(trim('$P2_'),'%')
order by owner, segment_name, segment_type, PARTITION_NAME;

ttitle left "Table name from DBA_LOBS:"
column table_name for a30
column column_name for a30
select tablespace_name, owner, segment_name, table_name, column_name, partitioned, compression
from dba_lobs where table_name like upper('$P1_') and owner like nvl(trim('$P2_'),'%');

ttitle left "Lob segment name from DBA_SEGMENTS, DBA_LOBS:"
column index_name for a30
select s.tablespace_name, s.owner, s.segment_name, s.PARTITION_NAME, l.INDEX_NAME, s.segment_type, s.SEGMENT_SUBTYPE, s.bytes/(1024*1024) size_Mb, s.blocks, s.max_size
from dba_segments s, dba_lobs l where s.owner=l.owner and s.segment_name=l.segment_name and l.table_name like upper('$P1_') and s.owner like nvl(trim('$P2_'),'%')
order by owner, segment_name, segment_type, PARTITION_NAME;
EOF
logf
}

topseg()
{
P1_="$1"
P2_="$2"
if [ -n "$P1_" ]; then
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column owner for a25
column object_name for a35
column statistic_name for a35
column value for 99999999999999
SELECT OWNER, OBJECT_NAME, STATISTIC_NAME, VALUE FROM V\$SEGMENT_STATISTICS WHERE OBJECT_NAME = '$P1_' and owner like nvl('$P2_','%')  order by object_name, statistic_name;
EOF
else
$SP <<'EOF' >$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column owner for a15
column object_name for a35
column object_type for a20
column statistic_name for a25
column value for 99999999999999

prompt
prompt top row lock waits:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='row lock waits'
order by value desc
) where rownum<21;

prompt
prompt top buffer busy waits:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='buffer busy waits'
order by value desc
) where rownum<21;

prompt
prompt top logical reads:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='logical reads'
order by value desc
) where rownum<21;

prompt
prompt top physical reads\writes:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
-- where statistic_name='physical reads'
where statistic_name in ('physical reads','physical reads direct', 'physical writes','physical writes direct')
order by value desc
) where rownum<21;

prompt
prompt top space allocated:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='space allocated'
order by value desc
) where rownum<21;

prompt
prompt top ITL waits:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='ITL waits'
order by value desc
) where rownum<21;
EOF
fi
logf
}



object()
{
P1_="$1"
P2_="$2"
shopt -s nocasematch
case "$P1_" in 
  invalid)  
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 150
column owner for a30
column object_name for a30
column OBJECT_TYPE for a25
column status for a20
ttitle left "Invalid dba_objects for owner like nvl(upper('$P2_'),'%') :"
BREAK ON REPORT
COMPUTE SUM  LABEL 'SUM' OF count(*) on report
select owner, count(*)  from dba_objects where status!='VALID' and owner like nvl(upper('$P2_'),'%') group by owner order by owner;
column OBJECT_NAME for a30
select owner, object_name, object_type,status from dba_objects where status!='VALID' and owner like nvl(upper('$P2_'),'%') order by owner, object_type, object_name;

ttitle left "recompile commands for invalid objects owner like nvl(upper('$P2_'),'%') :"
column cmd for a230
select 'alter '||decode(object_type,'PACKAGE BODY','PACKAGE',object_type)||' "'||owner||'"."'|| object_name||'" '||decode(object_type,'PACKAGE BODY','COMPILE BODY','COMPILE')||';' cmd from dba_objects
where status <> 'VALID' and owner like nvl(upper('$P2_'),'%') and (object_type like 'PACKAGE%' or object_type in ('PROCEDURE','FUNCTION','VIEW','JAVA CLASS','TRIGGER','MATERIALIZED VIEW'));
EOF
;;
  ddl)
 if [ -z "$P2_" ]; then P2_=3 ; fi
$SP <<EOF >$LOGF
set lines 230 pages 150 numw 15
col owner for a30
col object_name for a30
col subobject_name for a30
col object_id for 999999999
col data_object_id for 999999999
col object_type for a20
col created for a20
col last_ddl_time for a20
col status for a8
col temporary for a2
ttitle left "Last 50 dba_objects where last_ddl_time > sysdate-($P2_/24):"
select * from (
select owner,object_name,subobject_name,object_id,data_object_id,object_type,created,last_ddl_time,status,temporary 
from dba_objects where last_ddl_time > sysdate-($P2_/24)
--and object_type = 'TABLE PARTITION'
order by last_ddl_time  desc
) where rownum<=50;
EOF
;;
  *)
if [ $(is_number $P1_) -eq 0 ]; then 
    SQL_="object_name like upper('$P1_') and owner like upper(nvl('$P2_','%'))"
else
    SQL_="object_id = '$P1_'"
fi
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
ttitle left "Objects from dba_objects where $SQL_:"
column object_name for a30
column owner for a30
column object_type for a20
select OBJECT_ID, owner, object_name, object_type, CREATED, LAST_DDL_TIME, STATUS from dba_objects where ${SQL_} ;
EOF
;;
esac
logf
}


table()
{
P1_="$1"
P2_=$(tr '[:lower:]' '[:upper:]' <<< "$2")
P3_=$(tr '[:lower:]' '[:upper:]' <<< "$3")
REL=$(db_version)
case $REL in
  8|9) SQL_TEXT1="" ; SQL_TEXT2="" ;;
  *)   SQL_TEXT1=" t.compression, t.compress_for, " ; SQL_TEXT2=" , HISTOGRAM " ;;
esac

shopt -s nocasematch
case "$P1_" in
part)
$SP <<EOF >$LOGF
set lines 230 numw 6 pages 60
col OWNER for a20
col TABLE_NAME for a30
col PARTITIONING_TYPE for a6
col SUBPARTITIONING_TYPE for a6
col PARTITION_COUNT for 9999999 heading "P_CNT"
col DEF_SUBPARTITION_COUNT for 99 heading "DEF_SUBP_CNT"
col PARTITIONING_KEY_COUNT for 99 heading "P_KEY_CNT"
col SUBPARTITIONING_KEY_COUNT for 99 heading "SUBP_KEY_CNT"
col STATUS for a8
col DEF_TABLESPACE_NAME for a20 heading "DEF_TBS"
col DEF_PCT_FREE for 99 heading "PCT_FR"
col DEF_PCT_USED for 99 heading "PCT_US"
col DEF_LOGGING for a6 heading "DEF_LOG"
col DEF_COMPRESSION for a8 heading "DEF_COMPR"
col DEF_COMPRESS_FOR for a8 heading "DEF_COM_FOR"
col INTERVAL for a30
prompt dba_part_tables:
select owner,table_name,partitioning_type,subpartitioning_type,partition_count,def_subpartition_count,partitioning_key_count,subpartitioning_key_count,
status,def_tablespace_name,def_pct_free,def_pct_used,def_logging,def_compression,def_compress_for, interval from dba_part_tables
where table_name = '$P2_' and owner like nvl('$P3_','%') order by owner,TABLE_NAME;

col table_owner for a20
col table_name for a30
col partition_name for a25
col high_value for a50 heading "HIGH_VALUE" 
col high_value_length for 99 heading "HVLEN"
col partition_position for 999 heading "PPOS"
col tablespace_name for a15
col logging for a4
col compression for a8
col compress_for for a8
col num_rows for 999999999 heading "ROWS"
col blocks for 999999
col empty_blocks for 9999 heading "EMPBL"
col avg_space for 9999 heading "AVGSP"
col chain_cnt for 9999 heading "CHCNT"
col avg_row_len for 9999 heading "AVGRLEN"
col sample_size for 999999999
col last_analyzed for a19
col interval for a4
col segment_created for a4  heading "SCR"
prompt dba_tab_partitions:
select table_owner,table_name,partition_name,high_value,/*high_value_length,*/partition_position,tablespace_name,logging,compression,compress_for, 
num_rows,blocks,/*empty_blocks,avg_space, chain_cnt,avg_row_len,sample_size,*/last_analyzed,interval,segment_created from DBA_TAB_PARTITIONS
where table_name = '$P2_' and table_owner like nvl('$P3_','%') order by table_owner,TABLE_NAME,partition_position;

set lines 230 
set long 10000
col table_owner for a20
col table_name for a30
col subpartition_name for a30
col high_value for a50 heading "HIGH_VALUE" 
col high_value_length for 99 heading "HVLEN"
col subpartition_position for 999 heading "PPOS"
col tablespace_name for a20
col logging for a4
col compression for a8
col compress_for for a8
col num_rows for 999999999 heading "ROWS"
col blocks for 999999
col empty_blocks for 9999 heading "EMPBL"
col avg_space for 9999 heading "AVGSP"
col chain_cnt for 9999 heading "CHCNT"
col avg_row_len for 9999 heading "AVGRLEN"
col sample_size for 999999999
col last_analyzed for a17
col interval for a4
col segment_created for a4  heading "SCR"
prompt dba_tab_subpartitions:
select table_owner,table_name,subpartition_name,high_value,/*high_value_length,*/subpartition_position,tablespace_name,logging,compression,compress_for, 
num_rows,blocks,/*empty_blocks,avg_space, chain_cnt,avg_row_len,sample_size,*/last_analyzed,interval,segment_created  from DBA_TAB_SUBPARTITIONS
where table_name = '$P2_' and table_owner like nvl('$P3_','%') order by table_owner,TABLE_NAME,subpartition_position;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 300
set echo off feed off veri off tab off pages 45
column owner for a20
column segment_name for a30
column table_name for a30
column logging for a6
column cache for a6
column num_rows for 9999999999
column avg_row_len for 999999
column "SIZE_MB" for 99999999
column "EST_MB" for 99999999
column "DIFF_MB" for 99999999
column segment_type for a20
column tablespace_name for a22
column compression for a11
column compress_for for a15
column partitioned for a4
column iot_type for a8
select t.tablespace_name, owner, table_name, t.logging, t.cache,  num_rows, avg_row_len,
ROUND((BLOCKS*tbs.block_size/1024/1024),0) "SIZE_MB", ROUND((NUM_ROWS*AVG_ROW_LEN/1024/1024),0) "EST_MB", ROUND((BLOCKS*tbs.block_size/1024/1024),0) - ROUND((NUM_ROWS*AVG_ROW_LEN/1024/1024),0) "DIFF_MB",
last_analyzed, $SQL_TEXT1 partitioned, iot_type, temporary
from dba_tables t, dba_tablespaces tbs where t.tablespace_name=tbs.tablespace_name(+) and table_name like upper('$P1_') and owner like nvl('$P2_','%') order by owner;

prompt
prompt indexes:
column index_type for a15
column index_name for a33
column compression for a15
column UNIQUENESS for a10
column blevel for 99
column distinct_keys for 99999999999
column status for a10
column VISIBILITY for a9
select tablespace_name, owner, index_name, index_type, uniqueness, blevel, distinct_keys, status, num_rows, last_analyzed, compression, partitioned,VISIBILITY
from dba_indexes where table_name like upper('$P1_') and owner like nvl('$P2_','%') order by owner,index_name;

prompt
prompt index_columns:
column index_owner for a20
column index_name for a33
column COLUMN_NAME for a30
select index_owner,index_name,column_name,column_position,column_length,descend
from dba_ind_columns where table_name like upper('$P1_') and table_owner like nvl('$P2_','%') order by index_owner,index_name,column_position;
/*
prompt
prompt constraints:
column owner for a20
column r_owner for a20
column CONSTRAINT_NAME for a30
column R_CONSTRAINT_NAME for a25
col STATUS for a10
col DEFERRABLE for a15
col DEFERRED for a15
col VALIDATED for a15
select OWNER,CONSTRAINT_NAME,CONSTRAINT_TYPE, R_OWNER,R_CONSTRAINT_NAME, STATUS,DEFERRABLE,DEFERRED,VALIDATED,LAST_CHANGE,INVALID
from dba_constraints where table_name = upper('$P1_') and owner like nvl('$P2_','%') order by owner,CONSTRAINT_NAME;
*/
prompt
prompt columns statistic information:
col owner for a20
col table_name for a25
col COLUMN_NAME for a30
col NUM_DISTINCT for 999999999999
col NUM_NULLS for 999999999999
col NUM_BUCKETS for 99999
col SAMPLE_SIZE for 999999999999
col low_value for a15
col high_value for a15
col HISTOGRAM for a30
select OWNER,COLUMN_NAME,NUM_DISTINCT,DENSITY,NUM_NULLS,NUM_BUCKETS,LAST_ANALYZED,SAMPLE_SIZE,GLOBAL_STATS,USER_STATS,AVG_COL_LEN $SQL_TEXT2
from dba_tab_col_statistics where table_name like upper('$P1_') and owner like nvl('$P2_','%') order by owner,table_name,COLUMN_NAME;
EOF
;;
esac
logf
}


index()
{
P1_="$1"
P2_=$(tr '[:lower:]' '[:upper:]' <<< "$2")
P3_=$(tr '[:lower:]' '[:upper:]' <<< "$3")

shopt -s nocasematch
case "$P1_" in
candidate)
[[ -n "$P2_" && "$P2_" != "%" ]] && TABLE_="$2" || TABLE_="%"
[[ -n "$P3_" && "$P3_" != "%" ]] && OWNER_="$3" || OWNER_="%"
$SP <<EOF >$LOGF
set lines 250 pages 10000  echo off feed off veri off tab off timing off
CREATE OR REPLACE FUNCTION index_saving_function(index_owner IN VARCHAR2, index_name VARCHAR2)
RETURN NUMBER
AUTHID current_user
AS
  unformatted_blocks NUMBER;
  unformatted_bytes NUMBER;
  fs1_blocks NUMBER;
  fs1_bytes NUMBER;
  fs2_blocks NUMBER;
  fs2_bytes NUMBER;
  fs3_blocks NUMBER;
  fs3_bytes NUMBER;
  fs4_blocks NUMBER;
  fs4_bytes NUMBER;
  full_blocks NUMBER;
  full_bytes NUMBER;
  dbms_space_bytes NUMBER;
  used_bytes NUMBER;
  alloc_bytes NUMBER;
BEGIN
  dbms_space.space_usage(UPPER(index_owner), UPPER(index_name), 'INDEX', unformatted_blocks, unformatted_bytes, fs1_blocks, fs1_bytes, fs2_blocks,
  fs2_bytes, fs3_blocks, fs3_bytes, fs4_blocks, fs4_bytes, full_blocks, full_bytes);
  dbms_space_bytes:=unformatted_bytes+fs1_bytes+fs2_bytes+fs3_bytes+fs4_bytes+full_bytes;
  dbms_space.create_index_cost(dbms_metadata.get_ddl('INDEX', UPPER(index_name), UPPER(index_owner)), used_bytes, alloc_bytes);
  IF (dbms_space_bytes <> 0) THEN
    RETURN trunc(100 * (dbms_space_bytes - alloc_bytes) / dbms_space_bytes);
  ELSE
    RETURN 0;
  END IF;
END;
/
alter session set "_optimizer_cartesian_enabled"=false;
set timing on
prompt set echo on timing on
prompt alter session set ddl_lock_timeout=360;;
prompt alter session force parallel ddl parallel 16;;
prompt alter session set "_scn_wait_interface_max_timeout_secs"=1;;
prompt --CMD                                                                                         OWNER.TABLE_NAME                              OWNER.INDEX_NAME                                     BYTES_MB    PERCENT_GAIN
prompt -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
set serveroutput on
begin
for i in (select /*+ NO_QUERY_TRANSFORMATION */ cmd, owner, index_name, table_owner, table_name, bytes_MB, index_saving_function(owner,index_name) percent_gain from (
      SELECT i.owner,i.index_name, i.table_owner, i.table_name, 'alter index '||i.owner||'.'||i.index_name||' rebuild online; ' cmd, s.bytes/1024/1024 bytes_MB
      FROM dba_indexes i, dba_segments s 
      WHERE i.owner=s.owner and i.index_name=s.segment_name and s.bytes/1024/1024 > 50
      and i.owner like '$OWNER_' --and table_name in ('J$1110','J$1102','X$JOURNAL','J$3501','J$1104','J$1109','J$1120','J$11033','J$11038','J$1112','J$11071','J$11072','J$9700' )
      and table_name like '$TABLE_'
      and i.owner not in ('SYS','SYSTEM','OUTLN','DBSNMP','ORDSYS','ORDPLUGINS','MDSYS','CTXSYS','MTSSYS','WMSYS')
--    and s.tablespace_name='APEX_7388326897049623'
      and index_type = 'NORMAL' and temporary='N'
      and last_analyzed IS NOT NULL
      and partitioned='NO'
      and num_rows > 100000
       ) where index_saving_function(owner,index_name) > 30
      order by bytes_MB, percent_gain desc) loop
     dbms_output.put_line(rpad('--',90)|| rpad('--  '||i.TABLE_OWNER||'.'||i.TABLE_NAME,50)||rpad(i.OWNER||'.'||i.INDEX_NAME,50)||' '||lpad(i.BYTES_MB,10)||' '||lpad(i.PERCENT_GAIN,5) );
     dbms_output.put_line(rpad('alter index '||i.owner||'.'||i.index_name||' rebuild online;',90));
     dbms_output.put_line(rpad('alter index '||i.owner||'.'||i.index_name||' noparallel;',90));
end loop;
end;
/
EOF
;;
part)
$SP <<EOF >$LOGF
set lines 230 numw 6
set echo off feed off veri off tab off pages 70
col OWNER for a20
col INDEX_NAME for a30
col TABLE_NAME for a30
col PARTITIONING_TYPE for a6
col SUBPARTITIONING_TYPE for a6
col PARTITION_COUNT for 9999999 heading "P_CNT"
col PARTITIONING_KEY_COUNT for 99 heading "P_KEY_CNT"
col SUBPARTITIONING_KEY_COUNT for 99 heading "SUBP_KEY_CNT"
col DEF_TABLESPACE_NAME for a20 heading "DEF_TBS"
col DEF_PCT_FREE for 99 heading "PCT_FR"
prompt DBA_PART_INDEXES
select owner,index_name,table_name,partitioning_type,subpartitioning_type,partition_count,partitioning_key_count,subpartitioning_key_count, def_tablespace_name,def_pct_free 
from dba_part_indexes where (table_name='$P2_' or  index_name='$P2_') and owner like nvl('$P3_','%') order by owner,table_name,index_name;

col index_owner for a20
col index_name for a30
col partition_name for a30
col high_value for a25 heading "HIGH_VALUE" 
--col high_value_length for 99 heading "HVLEN"
col partition_position for 9999 heading "PPOS"
col status for a8
col tablespace_name for a20
col pct_free for 999 heading "PFRE"
col compression for a8
col blevel for 999 heading "BLEV"
col leaf_blocks for 9999999 heading "LEAF_B"
col distinct_keys for 999999 heading "DIS_KEYS"
col num_rows for 999999999 heading "ROWS"
col last_analyzed for a19
col global_stats  for a3 heading "GLST"
col interval for a4
col segment_created for a4  heading "SCR"
prompt DBA_IND_PARTITIONS
select index_owner,index_name,partition_name,high_value,/*high_value_length,*/ partition_position, status,tablespace_name, pct_free,compression,
blevel, leaf_blocks,distinct_keys,num_rows,last_analyzed,global_stats,interval,segment_created 
from DBA_IND_PARTITIONS where index_name='$P2_' and index_owner like nvl('$P3_','%') order by index_owner,index_name,partition_position;

col subpartition_position for 999 heading "PPOS"
prompt DBA_IND_SUBPARTITIONS
select index_owner,index_name,partition_name,high_value,/*high_value_length,*/subpartition_position, status,tablespace_name, pct_free,compression,
blevel, leaf_blocks,distinct_keys,num_rows,last_analyzed,global_stats,interval,segment_created 
from DBA_IND_SUBPARTITIONS where index_name='$P2_' and index_owner like nvl('$P3_','%') order by index_owner,index_name,subpartition_position;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 80
prompt
column tablespace_name for a15
column owner for a20
column index_type for a15
column table_name for a33
column index_name for a33
column compression for a12
column UNIQUENESS for a10
column distinct_keys for 9999999999
column num_rows for 9999999999
column status for a10
column partitioned for a4
column degree for a2
column VISIBILITY for a9
prompt dba_indexes for index_name like $P1_ and owner like nvl('$P2_','%')
select tablespace_name,table_name,owner,index_name,index_type,uniqueness,distinct_keys, status, num_rows, last_analyzed, compression, partitioned, degree, VISIBILITY
from dba_indexes where owner like nvl('$P2_','%') and index_name like upper('$P1_') order by owner,index_name;

set longc 100000000
column index_owner for a30
column index_name for a30
column table_owner for a30
column table_name for a30
column column_expression for a50
column column_position for 99
prompt dba_ind_expressions for index_name like $P1_ and owner like nvl('$P2_','%')
select index_owner,index_name,table_owner,table_name,column_expression,column_position from dba_ind_expressions where table_owner like nvl('$P2_','%') and index_name like upper('$P1_') order by table_owner,table_name,index_name,column_position;

col cmd for a230
prompt recompile cmd for  index_name like $P1_ and owner like nvl('$P2_','%')
select 'ALTER INDEX "'||owner||'"."'||index_name||'" REBUILD online;'cmd from dba_indexes where owner like nvl('$P2_','%') and index_name like upper('$P1_') and status='UNUSABLE';
EOF
;;
esac
logf
}



constraint()
{
P1_="$1"
P2_="$2"
P3_="$3"
P4_="$4"

SET_COLUMNS="column owner for a17
column table_name for a25
column constraint_name for a25
column column_name for a20
column position for 99 heading 'P'
column constraint_type for a2
column search_condition for a30
column r_owner for a17
column r_constraint_name for a25
column delete_rule for a10
column status for a9
column deferrable for a14
column deferred for a10
column validated for a13
column last_change for a19"

shopt -s nocasematch
case "$P1_" in
t)
$SP <<EOF >$LOGF
set lines 230 pages 60
set echo off feed off veri off tab off
set longc 100000000
prompt
prompt dba_constraints dba_cons_columns for table: $P2_
$SET_COLUMNS
select col.owner,col.table_name,col.constraint_name,column_name,position,c.constraint_type,c.search_condition,
c.r_owner,c.r_constraint_name,c.delete_rule,c.status, /*c.deferrable,c.deferred,*/ c.validated,c.last_change
from DBA_CONS_COLUMNS col, dba_constraints c
where c.owner=col.owner and c.table_name=col.table_name and c.constraint_name=col.constraint_name
--and c.owner='DMS'
and col.table_name='$P2_'
order by col.table_name, col.constraint_name, col.position;
EOF
;;
pk)
$SP <<EOF >$LOGF
set lines 230 pages 60
column owner for a30
column constraint_name for a30
column table_name for a30
PROMPT
PROMPT What Foregin Key references to PK: $P2_
select owner, constraint_name, table_name from all_constraints where constraint_type='R' and r_constraint_name='$P2_';
PROMPT
PROMPT Script to disable the restriction that refers to the PK: $P2_:
select 'alter table '||owner||'.'||table_name||' disable constraint '|| constraint_name||';' script from dba_constraints where constraint_type='R' and r_constraint_name='$P2_';
EOF
;;
fk)
$SP <<EOF >$LOGF
set lines 230 pages 60
column owner for a20
column table_name for a30
column constraint_name for a30
column columns for a22
column create_index_ddl for a123
PROMPT Tables with non-indexed foreign keys: Table: $P2_:
SELECT   owner, table_name,
           constraint_name,
              cname1
           || NVL2 (cname2, ',' || cname2, NULL)
           || NVL2 (cname3, ',' || cname3, NULL)
           || NVL2 (cname4, ',' || cname4, NULL)
           || NVL2 (cname5, ',' || cname5, NULL)
           || NVL2 (cname6, ',' || cname6, NULL)
           || NVL2 (cname7, ',' || cname7, NULL)
           || NVL2 (cname8, ',' || cname8, NULL)
               columns,
               'create index '||owner||'.'||'IDX_'||constraint_name||'_'||rownum||' on '||owner||'.'||table_name||'('||cname1|| NVL2 (cname2, ',' || cname2, NULL)|| NVL2 (cname3, ',' || cname3, NULL)|| NVL2 (cname4, ',' || cname4, NULL)|| NVL2 (cname5, ',' || cname5, NULL)|| NVL2 (cname6, ',' || cname6, NULL)|| NVL2 (cname7, ',' || cname7, NULL)|| NVL2 (cname8, ',' || cname8, NULL)||') tablespace '||(select  tablespace_name from dba_indexes where table_name like '$P2_' and owner like '%$P3_%' and rownum=1)||';' create_index_ddl
    FROM   (  SELECT   b.owner, b.table_name,
                       b.constraint_name,
                       MAX (DECODE (position, 1, column_name, NULL)) cname1,
                       MAX (DECODE (position, 2, column_name, NULL)) cname2,
                       MAX (DECODE (position, 3, column_name, NULL)) cname3,
                       MAX (DECODE (position, 4, column_name, NULL)) cname4,
                       MAX (DECODE (position, 5, column_name, NULL)) cname5,
                       MAX (DECODE (position, 6, column_name, NULL)) cname6,
                       MAX (DECODE (position, 7, column_name, NULL)) cname7,
                       MAX (DECODE (position, 8, column_name, NULL)) cname8,
                       COUNT ( * ) col_cnt
                FROM   (SELECT   SUBSTR (table_name, 1, 30) table_name,
                                 SUBSTR (constraint_name, 1, 30) constraint_name,
                                 SUBSTR (column_name, 1, 30) column_name,
                                 position
                          FROM   dba_cons_columns) a, dba_constraints b
               WHERE   a.constraint_name = b.constraint_name and b.owner like '%$P3_%'  and b.table_name like '$P2_'
                       AND b.constraint_type = 'R'
            GROUP BY   b.owner, b.table_name, b.constraint_name) cons
   WHERE   col_cnt >
               ALL (  SELECT   COUNT ( * )
                        FROM   dba_ind_columns i
                       WHERE   i.table_name = cons.table_name and i.table_owner like '%$P3_%' and i.table_name like '$P2_'
                               AND i.column_name IN
                                          (cname1,
                                           cname2,
                                           cname3,
                                           cname4,
                                           cname5,
                                           cname6,
                                           cname7,
                                           cname8)
                               AND i.column_position <= cons.col_cnt
                    GROUP BY   i.index_name)
ORDER BY  owner, table_name, constraint_name, columns;
EOF
;;
*) 
$SP <<EOF >$LOGF
set lines 230 pages 60
set echo off feed off veri off tab off
set longc 100000000
prompt
prompt dba_constraints dba_cons_columns for constraint: $P1_
$SET_COLUMNS
select col.owner,col.table_name,col.constraint_name,column_name,position,c.constraint_type,c.search_condition,
c.r_owner,c.r_constraint_name,c.delete_rule,c.status, /*c.deferrable,c.deferred,*/ c.validated,c.last_change
from DBA_CONS_COLUMNS col, dba_constraints c 
where c.owner=col.owner and c.table_name=col.table_name and c.constraint_name=col.constraint_name
--and c.owner='DMS' 
and col.constraint_name='$P1_'
order by col.table_name, col.constraint_name, col.position;
EOF
;;
esac
logf
}



lob()
{
P1_=$1
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 40
column owner for a20
column segment_name for a30
column table_name for a30
column index_name for a30
column column_name for a30
column segment_type for a20
column tablespace_name for a15
column compression for a15
prompt
prompt Segment from dba_lobs where segment_name = upper('$P1_');
select owner,table_name,column_name,segment_name,tablespace_name,index_name,partitioned from dba_lobs where segment_name = upper('$P1_');
prompt
prompt Index from dba_lobs where index_name = upper('$P1_');
select owner,table_name,column_name,segment_name,tablespace_name,index_name,partitioned from dba_lobs where index_name = upper('$P1_');
EOF
logf
}



redo()
{
P1_="$1"
shopt -s nocasematch
case "$P1_" in
logs)
$SP <<'EOF' >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column member for a80
select group#, member, type, status from v$logfile order by group#,member;
column bytes for 99,999,999,999
select group#, bytes, status, archived, SEQUENCE# from v$log;
EOF
;;
*)
$SP <<'EOF' >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
prompt Top 25 ACTIVE Sessions Generating Lots of Redo v$session, v$sess_io:
col sid for 99999
col serial# for 9999999
col username for a25
col osuser for a25
col pma for a100
col changes for 999,999,999 heading "Changes Mb"
select * from (
--SELECT s.sid, s.serial#, s.username, s.osuser, REGEXP_REPLACE(CONVERT(s.program||' \ '||s.module||' \ '||s.action, 'AL32UTF8', 'CL8MSWIN1251'), '[^[:print:]]', '') pma, i.block_changes, round(i.block_changes * TO_NUMBER(x.value)/(1024*1024),0) changes
SELECT s.sid, s.serial#, s.username, s.osuser, s.program||' \ '||s.module||' \ '||s.action pma, i.block_changes, round(i.block_changes * TO_NUMBER(x.value)/(1024*1024),0) changes
FROM v$session s, v$sess_io i, sys.v_$system_parameter x
WHERE s.sid = i.sid and BLOCK_CHANGES > 0 and s.serial#<>'1' and s.type <> 'BACKGROUND' and x.name  = 'db_block_size' and s.status='ACTIVE'
ORDER BY i.block_changes desc, 1, 2, 3, 4
) where rownum < 26;

prompt Top 25 ACTIVE Sessions Generating Lots of Redo v$session, v$transactionv Run the query multiple times and examine the delta between each occurrence of USED_UBLK and USED_UREC:
select * from (
SELECT s.sid, s.serial#, s.username, s.program, t.used_ublk, t.used_urec, t.start_time
FROM v$session s, v$transaction t
WHERE s.taddr = t.addr and s.status='ACTIVE'
ORDER BY 7 , 5 desc, 6 desc, 1, 2, 3, 4
) where rownum < 26;

prompt Top 25 Sessions Generating Lots of Redo  V$SESSION s, V$SESSTAT t, V$STATNAME sn, V$SQLAREA :
col program for a30
col sql_text for a130
select * from (
SELECT s.sid, s.serial#, s.username, s.program, ROUND(t.VALUE/(1024*1024)) AS "Redo Size MB", sa.sql_text
FROM V$SESSION s, V$SESSTAT t, V$STATNAME sn, V$SQLAREA sa
WHERE s.sid = t.sid
AND t.statistic# = sn.statistic#
AND sn.name = 'redo size'
AND s.type <> 'BACKGROUND'
AND sa.sql_id(+) = s.sql_id
AND ROUND(t.VALUE/(1024*1024)) != 0
ORDER BY t.VALUE DESC
) where rownum < 26;
EOF
esac
logf
}


undo()
{
P1_="$1"
shopt -s nocasematch
case "$P1_" in
recovery) 
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
prompt
prompt Recovering transactions v\$fast_start_transactions:
col usn for 9999
col estimated for a19 heading "Estimated time"
select usn, state, xid, pid, rcvservers,
--undoblockstotal "TotalBlk", undoblocksdone "DoneBlk", undoblockstotal-undoblocksdone "ToDoBlk",
round(undoblockstotal * TO_NUMBER(x.value)/(1024*1024),2) "Total Mb", round(undoblocksdone * TO_NUMBER(x.value)/(1024*1024),2) "Done Mb", round((undoblockstotal-undoblocksdone) * TO_NUMBER(x.value)/(1024*1024),2) "ToDo Mb",
decode(cputime,0,'unknown',sysdate+(((undoblockstotal-undoblocksdone) / (undoblocksdone / cputime)) / 86400)) estimated, sysdate
from v\$fast_start_transactions, sys.v_\$system_parameter x where x.name  = 'db_block_size' and state='RECOVERING' order by undoblockstotal desc;

prompt
prompt If v\$fast_start_transactions not work then x\$ktuxe:
col sysdate for a22
col ktuxesiz for 999999999 heading "Rollback Blk"
col undo for 9,999,999.00 heading "Undo Mb"
select ktuxeusn, to_char(sysdate,'DD/MM/YYYY HH24:MI:SS') "SYSDATE", ktuxesiz, round(ktuxesiz*8192/(1024*1024),2) undo, ktuxesta
from x\$ktuxe where ktuxecfl = 'DEAD' and ktuxesiz>0;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
prompt
prompt Sessions with active transactions v\$session, v\$transaction, dba_undo_extents (F: 0-triansaction, 8-rollback), estimate USED_UBLK: (used_later / (used_now - used_later)) :
col sid for 99999
col serial# for 9999999
col username for a20
col osuser for a15
col segment_name for a23
col used_ublk for 999999999
col undo for 9999,999 heading "Undo Mb"
col extent_id for 99999 heading "ExtCNT"
col pma for a65 heading "PROGRAM \ MODULE \ ACTION"
col flag for a1
col status for a10
col last_call_et for a25
SELECT s.sid, s.serial#, s.username, s.osuser, u.segment_name, t.XID, substr(to_char(t.flag,'0000000X'),length(to_char(t.flag,'0000000X'))-1,1) flag, count(u.extent_id) extent_id, t.used_ublk,
round(t.used_ublk * TO_NUMBER(x.value)/(1024*1024),2) undo, s.program||' \ '||s.module||' \ '||s.action pma, u.status,
to_char(sysdate-(s.last_call_et/60/60/24), 'Dy HH24:MI:SS') || ' - ' || ltrim(to_char(s.last_call_et/60, '9999990.0')) || ' min' last_call_et
FROM v\$session s, v\$transaction t, dba_undo_extents u, sys.v_\$system_parameter x
WHERE --s.taddr = t.addr 
s.saddr = t.ses_addr
and u.segment_name like '_SYSSMU'||t.xidusn||'_%$' and u.status = 'ACTIVE' 
and x.name  = 'db_block_size'
GROUP BY s.sid, s.serial#, s.username, s.osuser, u.segment_name, t.xid, to_char(t.flag,'0000000X'), t.used_ublk, round(t.used_ublk * TO_NUMBER(x.value)/(1024*1024),2), s.program||' \ '||s.module||' \ '||s.action, u.status, s.last_call_et
ORDER BY t.used_ublk desc, s.sid, s.serial#, s.username;
EOF
;;
esac
logf
}



sesstat()
{
P1_="$1"
P2_="$2"
SET_COL='set lines 230
set echo off feed off veri off tab off pages 70
col sid for 99999
col serial# for 999999
col username for a25
col osuser for a20
col module for a50
col action for a30
col name for a70
col CLASS for a10
col value for 999999999999999999'

case "$P1_" in
list)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
select statistic#, name, decode(class, 1, 'User', 2, 'Redo', 4, 'Enqueue', 8, 'Cache', 16, 'OS', 32, 'RAC', 64, 'SQL', 128, 'Debug', 'Unknown') CLASS from v\$statname;
EOF
;;
sess)
shift
shift
ALL="$*"
echo "sess) ALL: " $ALL
$SP <<EOF >$LOGF
$SET_COL
prompt
prompt Top 60 Session event for SID = $P2_ and name like "$ALL%":
select * from (
select b.sid, s.serial#, s.username, s.osuser, s.module, a.name, decode(class, 1, 'User', 2, 'Redo', 4, 'Enqueue', 8, 'Cache', 16, 'OS', 32, 'RAC', 64, 'SQL', 128, 'Debug', 'Unknown') CLASS, b.value
from v\$statname a, v\$sesstat b, v\$session s where a.statistic#=b.statistic#
and s.sid=b.sid and s.serial#<>'1' and s.sid = '$P2_' and name like '$ALL%' order by value desc
) where rownum < 61;
EOF
;;
*)
echo "*) ALL: " $ALL
$SP <<EOF >$LOGF
$SET_COL
prompt
prompt Sessions of top 60 event $P1:
select * from (
select b.sid, s.serial#, s.username, s.osuser, s.module, a.name, decode(class, 1, 'User', 2, 'Redo', 4, 'Enqueue', 8, 'Cache', 16, 'OS', 32, 'RAC', 64, 'SQL', 128, 'Debug', 'Unknown') CLASS, b.value
from v\$statname a, v\$sesstat b, v\$session s where a.statistic#=b.statistic#
and s.sid=b.sid and s.serial#<>'1' and name like '$ALL%' order by value desc
) where rownum < 61;
EOF
;;
esac
logf
}




dbsize()
{
CNT=$1
if [ -z "$CNT" ]; then
 CNT=7
fi
$SP <<EOF >$LOGF
set echo off feed off veri off tab off pages 60 timing off

ttitle left "Archived logs Switches information and SizeGb from v\$arhived_log by last $CNT days:"
alter session set nls_date_format='dd/mm/yy';
set pages 999 lines 230
col Day for a3
col thread# for 999
col TotalSwitch for 9999 heading "Total|Switch"
col TotalSizeGb for 999,999.99 heading "Total|Size GB"
col h00 format 999.9
col h01 format 999.9
col h02 format 999.9
col h03 format 999.9
col h04 format 999.9
col h05 format 999.9
col h06 format 999.9
col h07 format 999.9
col h08 format 999.9
col h09 format 999.9
col h10 format 999.9
col h11 format 999.9
col h12 format 999.9
col h13 format 999.9
col h14 format 999.9
col h15 format 999.9
col h16 format 999.9
col h17 format 999.9
col h18 format 999.9
col h19 format 999.9
col h20 format 999.9
col h21 format 999.9
col h22 format 999.9
col h23 format 999.9
col AvgGb for 9999.00
SELECT TRUNC (first_time) "Date", THREAD# , TO_CHAR (first_time, 'Dy') "Day",
COUNT (1) "TotalSwitch", sum(round((blocks * block_size)/(1024*1024*1024),2)) "TotalSizeGb",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '00', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h00",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '01', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h01",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '02', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h02",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '03', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h03",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '04', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h04",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '05', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h05",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '06', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h06",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '07', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h07",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '08', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h08",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '09', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h09",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '10', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h10",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '11', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h11",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '12', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h12",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '13', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h13",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '14', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h14",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '15', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h15",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '16', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h16",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '17', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h17",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '18', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h18",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '19', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h19",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '20', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h20",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '21', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h21",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '22', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h22",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '23', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h23",
ROUND ( sum((blocks * block_size)/(1024*1024*1024)) / 24, 2) AvgGb
FROM v\$archived_log
WHERE thread# = 1 and dest_id=(select dest_id from V\$ARCHIVE_DEST where status='VALID' and archiver='ARCH' and valid_type in ('ONLINE_LOGFILE','ALL_LOGFILES'))
AND first_time > sysdate - $CNT
GROUP BY TRUNC (first_time),"THREAD#" , TO_CHAR (first_time, 'Dy')
ORDER BY 1,2;

ttitle left "Archive logs dest information from v\$arhive_dest:"
column status for a10
column dest_name for a30
column destination for a90
select dest_name, status, destination from v\$archive_dest where status<>'INACTIVE';

column Db_size_Gb format 999,999,999,999
ttitle left "Overall database size:"
column DB_size_MB format 999,999,999,999.00
column tablespace_name format a35

BREAK ON REPORT
COMPUTE SUM LABEL 'SUM' OF DB_size_MB on report
select tablespace_name, sum(bytes/(1024*1024)) DB_size_MB from dba_data_files
group by tablespace_name order by tablespace_name;
ttitle off

select tablespace_name, sum(bytes/(1024*1024)) DB_size_MB from dba_temp_files
group by tablespace_name order by tablespace_name;
ttitle off
EOF
logf
}


grows()
{
CNT=$1
if [ -z "$CNT" ]; then
 CNT=7
fi
$SP <<EOF >$LOGF
set lines 230 pages 60
set echo off feed off veri off tab off 
col Month for a10
PROMPT Database grows size information from v\$datafile by last year:
select to_char(creation_time, 'RRRR MM') "Month",
trunc(sum(bytes)/1024/1024/1024) "Growth in Gb"
from sys.v_\$datafile
where creation_time > SYSDATE-365
group by to_char(creation_time, 'RRRR MM')
order by 1;
PROMPT
PROMPT "DBA_HIST_SEG_STAT: The database grows for $CNT days:"
PROMPT
set serveroutput on
Declare
  v_BaselineSize  number(20);
  v_CurrentSize   number(20);
  v_TotalGrowth   number(20);
  v_Space         number(20);
  v_Space2        number(20);
  cursor usageHist is
          select a.snap_id, SNAP_TIME, sum(TOTAL_SPACE_ALLOCATED_DELTA) over ( order by a.SNAP_ID) ProgSum
      from
        (select ccast, max(snap_id) snap_id, sum(TOTAL_SPACE_ALLOCATED_DELTA) TOTAL_SPACE_ALLOCATED_DELTA from (
            select SNAP_ID, trunc(row_number() over (order by snap_id ) ) ccast,
            sum(SPACE_ALLOCATED_DELTA) TOTAL_SPACE_ALLOCATED_DELTA
            from DBA_HIST_SEG_STAT
            group by SNAP_ID
            having sum(SPACE_ALLOCATED_TOTAL)>0
            order by 1
            )
        group by ccast
        order by ccast
         ) a,
          (select distinct SNAP_ID, to_char(END_INTERVAL_TIME,'DD-Mon-YYYY HH24:Mi') SNAP_TIME from DBA_HIST_SNAPSHOT where end_interval_time > sysdate-$CNT ) b
      where a.snap_id=b.snap_id;
Begin
    select sum(SPACE_ALLOCATED_DELTA) into v_TotalGrowth from DBA_HIST_SEG_STAT;
    select sum(bytes) into v_CurrentSize from dba_segments;
    v_BaselineSize := v_CurrentSize - v_TotalGrowth ;

    dbms_output.put_line('SNAP_TIME                    Database Size(MB)      Grows Size(MB)');
    v_Space2:=0;
    for row in usageHist loop
            v_Space := (v_BaselineSize + row.ProgSum)/(1024*1024);
            v_Space2 := v_Space-v_Space2;
        dbms_output.put_line(row.SNAP_TIME || '  ' || to_char(v_Space,'999,999,999,999,999')|| '           ' || to_char(v_Space2,'999,999,999') );
            v_Space2 := v_Space;
    end loop;
end;
/
EOF
logf
}



tbs()
{
P1_="$1"
shopt -s nocasematch
case "$P1_" in
free)
$SP <<EOF >$LOGF
set lines 230 pages 60
set echo off feed off veri off tab off 
select a.tablespace_name as "Tablespace Name",
       round(maxbytes/1024 / 1024) "Max. Bytes (MB)",
       round(a.bytes_alloc / 1024 / 1024) "Allocated (MB)",
       round(nvl(b.bytes_free, 0) / 1024 / 1024) "Free (MB)",
       round((a.maxbytes - nvl(b.bytes_free, 0)) / 1024 / 1024) "Used (MB)",
       round(((nvl(b.bytes_free, 0)) / a.maxbytes) * 100,2) "% Free",
       100 - round(((nvl(b.bytes_free, 0)) / a.maxbytes) * 100,2) "% Used"
from  ( select  f.tablespace_name,
               sum(f.bytes) bytes_alloc,
               sum(decode(f.autoextensible, 'YES', f.maxbytes, 'NO', f.bytes)) maxbytes
            from dba_data_files f
            group by tablespace_name) a,
      ( select tablespace_name, sum(free) bytes_free from
          ( select d.tablespace_name, d.file_name, case when autoextensible='YES' then (d.maxbytes-d.bytes)+nvl(f.bytes,0) else nvl(f.bytes,0) end free
               from (select tablespace_name, file_id, sum(bytes) bytes from dba_free_space
           group by tablespace_name,file_id) f, dba_data_files d where f.file_id(+)=d.file_id )
          group by tablespace_name
      ) b
where a.tablespace_name = b.tablespace_name (+)
union all
select f.tablespace_name,
round(sum(f.total_bytes/(1024*1024))) total,
sum(s.used_blocks*f.block_size/(1024*1024)),
round(sum(f.total_bytes/(1024*1024))-sum(s.used_blocks*f.block_size/(1024*1024))) free,
sum(s.used_blocks*f.block_size/(1024*1024)),
round(((sum(f.total_bytes)-sum(s.used_blocks*f.block_size))/sum(f.total_bytes))*100) free_per,
100-round(((sum(f.total_bytes)-sum(s.used_blocks*f.block_size))/sum(f.total_bytes))*100) used_per from
( select tablespace_name, block_size, sum(total_bytes) total_bytes from (
 select f.tablespace_name, case when autoextensible='YES' then f.maxbytes else f.user_bytes end total_bytes, t.block_size from dba_temp_files f, dba_tablespaces t
 where t.contents='TEMPORARY' and f.tablespace_name=t.tablespace_name )
group by tablespace_name, block_size ) f,
 v\$sort_segment s
where f.tablespace_name=s.tablespace_name
group by f.tablespace_name
ORDER BY "% Used" desc;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 230 pages 60
column TABLESPACE_NAME for a30 
column BLOCK_SIZE for 99999
column status for a10
column contents for a10
column logging for a10
column EXTENT_MANAGEMENT for a10
column ALLOCATION_TYPE for a10
column SEGMENT_SPACE_MANAGEMENT for a10
column retention for a12
column DEF_TAB_COMPRESSION for a13
column encrypted for a10
select TABLESPACE_NAME,BLOCK_SIZE,status,contents,logging,EXTENT_MANAGEMENT,ALLOCATION_TYPE,SEGMENT_SPACE_MANAGEMENT,retention,DEF_TAB_COMPRESSION,encrypted from dba_tablespaces order by contents,TABLESPACE_NAME;
EOF
;;
esac
logf
}


temp()
{
$SP <<'EOF' >$LOGF
TTitle left "TEMP Tablespace Usage information:" skip 1
SET PAGESIZE 60
SET LINESIZE 230
COLUMN tablespace FORMAT A12
COLUMN temp_size FORMAT 99,999,999 heading "TEMP_SIZE Mb"
COLUMN spid FORMAT a8
COLUMN sid_serial FORMAT A15
COLUMN username FORMAT A20
COLUMN osuser FORMAT A20
COLUMN machine FORMAT A30
COLUMN program FORMAT A45
COLUMN STATUS FORMAT A8
SELECT b.tablespace,
        ROUND(((b.blocks*p.value)/1024/1024),2) temp_size,
        p.spid,
        a.sid||' '||a.serial# AS sid_serial,
        NVL(a.username, '(oracle)') AS username,
        a.osuser AS osuser,
        a.machine AS machine,
        a.program,
        a.status,
        a.sql_id
FROM gv$session a,
     v$process p,
     gv$sort_usage b,
     gv$system_parameter p
WHERE p.addr(+) = a.paddr
AND a.type <> 'BACKGROUND'
AND p.name  = 'db_block_size'
AND a.saddr = b.session_addr
AND a.inst_id=b.inst_id
AND a.inst_id=p.inst_id
--and a.status<>'INACTIVE'
ORDER BY b.tablespace, b.blocks desc;

col free for 999,999 heading "FREE Mb"
col total for 999,999 heading "TOTAL Mb"
col used_per for 999.00
select f.tablespace_name, (sum(f.total_bytes/(1024*1024))-sum(s.used_blocks*f.block_size/(1024*1024))) free, sum(f.total_bytes/(1024*1024)) total,
100-(((sum(f.total_bytes)-sum(s.used_blocks*f.block_size))/sum(f.total_bytes))*100) used_per from
( select tablespace_name, block_size, sum(total_bytes) total_bytes from (
 select f.tablespace_name, case when autoextensible='YES' then f.maxbytes else f.user_bytes end total_bytes, t.block_size from dba_temp_files f, dba_tablespaces t
 where t.contents='TEMPORARY' and f.tablespace_name=t.tablespace_name )
group by tablespace_name, block_size ) f,
 v$sort_segment s
where f.tablespace_name=s.tablespace_name
group by f.tablespace_name;
EOF
logf
}


sysaux()
{
$SP <<'EOF' >$LOGF
SET LINESIZE 230 pages 100
col OCCUPANT_DESC for a70
PROMPT "v$sysaux_occupants:"
break on report
COMPUTE SUM OF space_usage_kbytes on report
select occupant_desc, space_usage_kbytes  from v$sysaux_occupants  where space_usage_kbytes > 0 order by space_usage_kbytes desc;
EOF
logf
}


df()
{
P1_="$1"
P2_=$(tr '[:lower:]' '[:upper:]' <<< "$2")
shopt -s nocasematch
case "$P1_" in
io)
$SP <<'EOF' >$LOGF
set lines 220
set echo off feed off veri off tab off pages 80
set numwidth 15
col file# for 999 heading "ID"
col name for a52 heading "File Name"
col phyrds for 9999999999 heading "Phy Reads"
col phywrts for 9999999999 heading "Phy Writes"
col phyblkrd for 9999999999 heading "Blk Reads"
col phyblkwrt for 9999999999 heading "Blk Writes"
col readtim for 999999999 heading "Read Time"
col writetim for 9999999999 heading "Write Time"
column "File Total" format 99,999,999,999,999
ttitle left "DataFile's Disk Activity information:"
select df.file#, name, phyrds, phywrts, phyblkrd, phyblkwrt, readtim, writetim,
       (sum(phyrds+phywrts+phyblkrd+phyblkwrt+readtim)) "File Total"
from v$filestat fs, v$datafile df
where fs.file# = df.file#
group by df.file#, df.name, phyrds, phywrts, phyblkrd, phyblkwrt, readtim, writetim
order by sum(phyrds+phywrts+phyblkrd+phyblkwrt+readtim) desc, df.name;
EOF
;;
usage)
$SP <<'EOF' >$LOGF
set lines 220
set echo off feed off veri off tab off pages 70
set numwidth 15
column "Total Bytes" format 9,999,999,999,999
column "SQL Blocks" format 999,999,999,999
column "VMS Blocks" format 999,999,999,999
column "Bytes Free" format 9,999,999,999,999
column "Bytes Used" format 9,999,999,999,999
column "% Free" format 9999.999
column "% Used" format 9999.999
break on report
compute sum of "Total Bytes" on report
compute sum of "SQL Blocks" on report
compute sum of "VMS Blocks" on report
compute sum of "Bytes Free" on report
compute sum of "Bytes Used" on report
compute avg of "% Free" on report
compute avg of "% Used" on report
TTitle left "Tablespace\Datafiles Usage information:" skip 1
select  substr(fs.FILE_ID,1,3) "ID#",
        fs.tablespace_name,
        df.bytes "Total Bytes",
        df.blocks "SQL Blocks",
        df.bytes/512 "VMS Blocks",
        sum(fs.bytes) "Bytes Free",
        (100*((sum(fs.bytes))/df.bytes)) "% Free",
        df.bytes-sum(fs.bytes) "Bytes Used",
    (100*((df.bytes-sum(fs.bytes))/df.bytes)) "% Used"
from sys.dba_data_files df, sys.dba_free_space fs
where df.file_id(+) = fs.file_id
group by fs.FILE_ID, fs.tablespace_name, df.bytes, df.blocks
order by fs.tablespace_name;
EOF
;;
lastseg)
echo $P2_
if [ -z "$P2_" ];then
 P2_="%"
fi
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
column owner for a15
column FILE_ID for 9999
column segment_name for a33
column segment_type for a20
column partition_name for a33
column tablespace_name for a22
select /*+ R ULE */ * from dba_extents eo where (eo.file_id, eo.block_id) in (select e.file_id, max(BLOCK_ID) from dba_extents e
where e.tablespace_name like upper('$P2_')
and e.file_id in (select f.file_id from dba_data_files f where f.tablespace_name like upper('$P2_') )
group by e.file_id)
order by eo.file_id;

prompt
prompt Smallest used position in datafiles:
set verify off
column file_name format a70 word_wrapped
column smallest format 999,990 heading "Smallest|Size|Poss."
column currsize format 999,990 heading "Current|Size"
column savings  format 999,990 heading "Poss.|Savings"
break on report
compute sum of savings on report

column value for a10 new_val blksize
select value from v\$system_parameter where name = 'db_block_size';

select a.file_id, file_name, ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) smallest, ceil( blocks*&&blksize/1024/1024) currsize,
       ceil( blocks*&&blksize/1024/1024) - ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) savings
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+) and a.tablespace_name like upper('$P2_');

column cmd format a150 word_wrapped
prompt
prompt Script with commands for resize datafiles:
select 'alter database datafile '''||file_name||''' resize ' ||
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 )  || 'm;' cmd
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+)
  and ceil( blocks*&&blksize/1024/1024) - ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) > 0
  and a.tablespace_name like upper('$P2_');
EOF
;;
*)
case $(db_is_open) in
 OPEN) SQL_="select ddf.tablespace_name,ddf.file_id,ddf.file_name,df.status,df.enabled, df.block_size, ddf.bytes, ddf.maxbytes, ddf.autoextensible from v\$datafile df, dba_data_files ddf where ddf.file_id=df.file# order by ddf.tablespace_name,ddf.file_name;
select ddf.tablespace_name,ddf.file_id,ddf.file_name,df.status,df.enabled, df.block_size, ddf.bytes, ddf.maxbytes, ddf.autoextensible from v\$tempfile df, dba_temp_files ddf where ddf.file_id=df.file# order by ddf.tablespace_name,ddf.file_name;"
 ;;
 *) SQL_="select dfh.tablespace_name,dfh.file#,dfh.name,df.status,df.enabled, df.block_size, dfh.bytes, dfh.recover, dfh.CHECKPOINT_CHANGE# from v\$datafile df, V\$DATAFILE_HEADER dfh where dfh.file#=df.file# order by CHECKPOINT_CHANGE# /* dfh.tablespace_name,dfh.name */;"
 ;;
esac
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 1000
set numwidth 15
column file_id for 999
column file# for 999
column block_size for 99999
column tablespace_name format a25
column file_name format a60
column name format a60
column status format a10
column enabled format a15
ttitle left "DataFiles information:"
$SQL_
EOF
;;
esac
logf
}


maxseg()
{
P1_="$1"
REL=$(db_version)
case $REL in
  8|9) SQL_TEXT1="" ;;
  *)   SQL_TEXT1=" , compression "  ;;
esac

$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 500
column OWNER for a30
column SEGMENT_NAME for a40
column SEGMENT_TYPE for a20
column compression for a15
column Mbytes for 999999999999999
select * from (
select tablespace_name, owner, segment_name, segment_type $SQL_TEXT1 , sum(bytes/(1024*1024)) Mbytes
 from  ( select s.tablespace_name, l.owner, l.table_name segment_name, segment_type $SQL_TEXT1 , bytes
    from  dba_lobs l, dba_segments s
    where s.segment_type = 'LOBSEGMENT'  and s.segment_name = l.segment_name and l.owner=s.owner and s.tablespace_name = upper('$P1_')
  union all
   select  s.tablespace_name,t.owner, t.table_name segment_name, segment_type $SQL_TEXT1 , bytes
    from  dba_tables t, dba_segments s
    where s.segment_name = t.table_name and t.owner=s.owner and s.tablespace_name = upper('$P1_')
  union all
   select  s.tablespace_name,i.owner, i.index_name segment_name, segment_type $SQL_TEXT1 , bytes
     from  dba_indexes i, dba_segments s
     where s.segment_name = i.index_name and i.owner=s.owner and s.tablespace_name = upper('$P1_') )
 group by tablespace_name,owner, segment_name, segment_type $SQL_TEXT1
 order by Mbytes desc
) where rownum <= 50
/
EOF
logf
}



fra()
{
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column NAME for a32
column DISPLAY_VALUE for a50
column DEFAULT_VALUE for a13
column ismodified for a10
column description for a57
select name,display_value,/*default_value,*/ismodified,description from SYS.V_\$PARAMETER
where name like 'db_recovery_file_dest%'  or name = 'db_flashback_retention_target';

ttitle left "View: V\$FLASH_RECOVERY_AREA_USAGE"
select * from V\$FLASH_RECOVERY_AREA_USAGE;
column name for a60
column space_limit for 999,999,999,999,999
column space_available for 999,999,999,999,999
column space_used for 999,999,999,999,999
column space_reclaimable for 999,999,999,999,999
ttitle left "View: v\$recovery_file_dest"
select name, space_limit, (space_limit - space_used + space_reclaimable) space_available, round((space_used - space_reclaimable)/space_limit * 100, 1) as pct_full from v\$recovery_file_dest;
select name,space_limit,space_used, space_reclaimable, number_of_files from v\$recovery_file_dest;
ttitle off
EOF
logf
}


arch()
{
$SP <<EOF >$LOGF
set lines 230
set pages 60

ttitle left "V\$LOG :"
col bytes for 999999999999
column status for a12
select group#,thread#,sequence#,bytes,archived,status from v\$log;

column "Archive_dest" for a50
ttitle left "V\$ARCHIVE_DEST :"
column DEST_ID for 99
column LOG_SEQUENCE for 999999999
column binding for a10
column target for a7
column compression for a7
column valid_type for a15
column valid_role for a12
column DESTINATION for a55
column ERROR for a75
SELECT DEST_ID, log_sequence,  STATUS, binding, target, compression, valid_type, valid_role, DESTINATION, ERROR FROM V\$ARCHIVE_DEST WHERE DEST_ID <= 10 and status <> 'INACTIVE';

ttitle left "V\$ARCHIVE_DEST_STATUS :"
column recovery_mode for a25
column database_mode for a15
SELECT DEST_ID, RECOVERY_MODE, status, database_mode, archived_thread#, archived_seq#, applied_seq# FROM V\$ARCHIVE_DEST_STATUS WHERE DEST_ID <= 10 and status <> 'INACTIVE';

ttitle left "V\$ARCHIVED_LOG transport lag archivelog standby:"
set linesize 230 pages 70
col THREAD format 999
col PRIMARY_SEQ format 9999999999
col STANDBY_THREAD format 999
col STANDBY_SEQ format 9999999999
col PRIMARY_TIME format a20
col STANDBY_COMPLETION_TIME format a23
col STANDBY_NEXT_TIME format a23
col SEQ_GAP format 9999999
col LAG_MINUTES format 9999999.99
SELECT   prim.thread# thread, prim.dest_id, tgt.status, prim.seq primary_seq, TO_CHAR (prim.tm, 'DD/MM/YYYY HH24:MI:SS') primary_time, tgt.thread# standby_thread, tgt.dest_id, tgt.seq standby_seq,
         TO_CHAR (tgt.tm, 'DD/MM/YYYY HH24:MI:SS') standby_next_time, prim.seq - tgt.seq seq_gap, (prim.tm - tgt.tm) * 24 * 60 lag_minutes
  FROM   (SELECT thread#, dest_id, MAX(sequence#) seq, MAX(next_time) tm FROM v\$archived_log where RESETLOGS_CHANGE#=(select RESETLOGS_CHANGE# from v\$database) GROUP BY thread#,dest_id) prim,
         (SELECT thread#, al.dest_id, ad.status, MAX(sequence#) seq, MAX(next_time) tm FROM v\$archived_log al, v\$archive_dest ad where al.dest_id=ad.dest_id and ad.target='STANDBY' and RESETLOGS_CHANGE#=(select RESETLOGS_CHANGE# from v\$database) and applied = 'YES' GROUP BY thread#, al.dest_id, ad.status) tgt
 WHERE   prim.thread# = tgt.thread# and prim.dest_id = tgt.dest_id order by prim.thread#, prim.dest_id;

column deleted format a7
column reclaimable format a11
col APPLIED for a9
col backup_count for 99999
col count(*) for 99999
col first_time for a15
col last_time for a15
col first_seq for 999999999
col last_seq for 999999999
ttitle left "Reclaimable v\$archived_log join x\$kccagf   exec dbms_backup_restore.refreshagedfiles; :"
select applied,deleted,backup_count
 ,decode(rectype,11,'YES','NO') reclaimable,count(*) 
 ,to_char(min(completion_time),'dd/mm/yy hh24:mi') first_time
 ,to_char(max(completion_time),'dd/mm/yy hh24:mi') last_time
 ,min(sequence#) first_seq,max(sequence#) last_seq
from v\$archived_log left outer join x\$kccagf using(recid)
where is_recovery_dest_file='YES' and deleted<>'YES'
group by applied,deleted,backup_count,decode(rectype,11,'YES','NO') order by min(sequence#);

ttitle left "GV\$MANAGED_STANDBY :"
col thread# for 99
col SEQUENCE# for 999999999
col PROCESS for a7
col PID for 999999999
col block# for 999999999
select thread#, sequence#, process, pid, status, block# from gv\$managed_standby order by THREAD#, SEQUENCE#, PROCESS;

--ttitle left "V\$STANDBY_LOG :"
--select group#,thread#,sequence#,bytes,used,archived,status from v\$standby_log;
EOF
logf
}


size()
{
P1_="$1"
P2_="$2"
shopt -s nocasematch
case "$P1_" in
  tbs)      shift; ALL=$*; tbs $ALL ;;
  temp)     temp ;;
  sysaux)   sysaux ;;
  df)       shift; ALL=$*; df $ALL ;;
  maxseg)   shift; ALL=$*; maxseg $ALL ;;
  fra)      fra ;;
  grows)    shift; ALL=$*; grows $ALL ;;
  *)        dbsize $P1_ ;;
esac
}


user()
{
P1_="$1"
P2_="$2"
shift
shift 
P3_="$*"
case "$(db_version)" in
8|9|10|11)  CMD1_="SELECT username, ACCOUNT_STATUS,lock_date,expiry_date,default_tablespace,TEMPORARY_TABLESPACE,created, profile FROM dba_users where upper(username) like upper('$P1_');" 
            CMD2_="select username,sysdba from v\$pwfile_users where username like upper('$P1_');" ;;
*)          CMD1_="SELECT username, ACCOUNT_STATUS,lock_date,expiry_date,default_tablespace,TEMPORARY_TABLESPACE,created, profile,cast(last_login as date) last_login FROM dba_users where upper(username) like upper('$P1_');" 
            CMD2_="select username,sysdba,sysoper,sysasm,sysbackup,sysdg,syskm,account_status,authentication_type from v\$pwfile_users where username like upper('$P1_');" ;;
esac
shopt -s nocasematch
case "$P2_" in 
sys)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50 timing off
column grantee for a30
column GRANTED_ROLE for a30
column privilege for a35
select * from dba_sys_privs s where grantee like upper('$P1_') and privilege like upper('$P3_') and not exists (select 1 from dba_roles where role=grantee);
EOF
;;
role)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50 timing off
column grantee for a30
column GRANTED_ROLE for a30
column privilege for a35
select * from dba_role_privs where grantee like upper('$P1_') and granted_role like upper('$P3_');
EOF
;;
tab)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50 timing off
column table_name for a30
column grantee for a30
column grantor for a20
column owner for a25
column PRIVILEGE for a20
column type for a15
select * from dba_tab_privs where grantee like upper('$P1_') and table_name like upper('%$P3_%');
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 300
set echo off feed off veri off tab off pages 50 timing off
set numwidth 15
column username for a30
column table_name for a20
column account_status for a20
column default_tablespace for a20
column TEMPORARY_TABLESPACE for a20
column profile for a20
column last_login for a19
$CMD1_
col name for a30
col lcount for 99999
col password_spare4 for a250
select name,lcount,password||';'||spare4 password_spare4 from user$ where name like upper('$P1_');

prompt
prompt v\$pwfile_users:
column sysdba for a10
column sysoper for a10
column sysasm for a10
column sysbackup for a10
column sysdg for a10
column syskm for a10
column authentication_type for a10
$CMD2_

prompt
prompt sys privs:
column grantee for a30
column GRANTED_ROLE for a30
column privilege for a35
select * from dba_sys_privs where grantee=upper('$P1_') order by privilege;

prompt
prompt role privs:
select * from dba_role_privs where grantee=upper('$P1_') order by granted_role;

prompt
prompt tab privs:
column table_name for a30
column grantee for a30
column grantor for a20
column owner for a25
column PRIVILEGE for a20
column type for a15
select * from dba_tab_privs where grantee=upper('$P1_') order by grantor, table_name, PRIVILEGE;

prompt
prompt tbs quotas:
col tablespace_name for a30
col username for a20
col Mbytes for 999999999 heading "SUM (Mb)"
break on report
COMPUTE SUM OF Mbytes on report
select tablespace_name, username, bytes/1024/1024 Mbytes, max_bytes, blocks, max_blocks from dba_ts_quotas where username=upper('$P1_') order by Mbytes desc;
EOF
;;
esac
logf
}


role()
{
P1_="$1"
P2_="$2"
shopt -s nocasematch
case "$P1_" in
  role)         COND1_="where role like upper('$P2_')" ;;
  granted_role) COND1_="where granted_role like upper('$P2_')" ;;
esac
$SP <<EOF >$LOGF
set lines 230 pages 80 echo off feed off veri off tab off
col owner for a30
select role,granted_role,admin_option from role_role_privs $COND1_ order by role,granted_role,admin_option;
EOF
logf
}


trigger()
{
P1_="$1"
SETCOL="set lines 230 pages 80 echo off feed off veri off tab off
col owner for a30
col TRIGGER_NAME for a30
col trigger_type for a20
col triggering_event for a33
col table_owner for a30
col TABLE_NAME for a30
col BASE_OBJECT_TYPE for a16 truncate
col status for a20
"
shopt -s nocasematch
case "$1" in
"")
$SP <<EOF >$LOGF
$SETCOL
select owner,trigger_name,trigger_type,triggering_event,base_object_type,table_owner,table_name,status from dba_triggers
where (triggering_event like 'LOGON%' or triggering_event like 'START%') order by triggering_event, owner, trigger_name;
EOF
;;
t) shift; P1_="$1"; P2_="$2"
$SP <<EOF >$LOGF
$SETCOL
select owner,trigger_name,trigger_type,triggering_event,base_object_type,table_owner,table_name,status from dba_triggers
where table_name like upper('$P1_') and table_owner like upper(nvl('$P2_','%')) order by triggering_event, owner, trigger_name;
EOF
;;
*)
P2_="$2"
$SP <<EOF >$LOGF
$SETCOL
select owner,trigger_name,trigger_type,triggering_event,base_object_type,table_owner,table_name,status from dba_triggers
where trigger_name like upper('$P1_') and owner like upper(nvl('$P2_','%')) order by triggering_event, owner, trigger_name;
EOF
;;
esac
logf
}


profile()
{
P1_="$1"
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
column PROFILE for a30
column RESOURCE_NAME for a30
column LIMIT for a30
select * from dba_profiles where profile like nvl(upper('$P1_'),'%') order by profile, RESOURCE_NAME;
EOF
logf
}

links()
{
P1_="$1"
REL=$(db_version)
case $REL in
9)  $SP <<EOF >$LOGF
set lines 300
set echo off feed off veri off tab off pages 0 timing off
select 'create database link '||l.name||' connect to '||l.userid||' identified by "'||l.password||'" using '''||l.host||''';' 
from sys.link$ l, sys.user$ u where l.owner#=u.user# and l.name=nvl('$P1_',l.name);
EOF
;;
*) $SP <<EOF >$LOGF
set lines 300
set echo off feed off veri off tab off pages 0 timing off
select 'create database link '||l.name||' connect to '||l.userid||' identified by values '''||l.passwordx||''' using '''||l.host||''';'
from sys.link$ l, sys.user$ u where l.owner#=u.user# and l.name=nvl('$P1_',l.name) order by l.name;
EOF
;;
esac

$SP <<EOF >>$LOGF
set lines 230
set echo off feed off veri off tab off pages 80 timing off
alter session set NLS_DATE_FORMAT='dd/mm/yyyy hh24:mi:ss';
column owner for a30
column name for a35
column userid for a30
column host for a45
column ctime for a20
select u.name owner,l.name,l.userid,l.host,l.ctime from sys.link$ l, sys.user$ u where l.owner#=u.user# and l.name=nvl('$P1_',l.name) order by owner, l.name;
prompt
EOF
logf
}

latch()
{
$SP <<'EOF' >$LOGF
set lines 230
set echo off feed off veri off tab off pages 140
ttitle left "Latch Contention information:" skip 1
column name for a40
column gets for 999999999999999
column misses for 999999999999
column im_gets for 999999999999
column im_misses for 999999999999
select n.name name, l.gets gets, l.misses misses, l.sleeps sleep ,
l.immediate_gets im_gets,l.immediate_misses im_misses,
round(decode(l.gets,0,0,misses/l.gets*100),3) pct,
round(decode(l.immediate_gets,0,0,l.immediate_misses/l.immediate_gets*100),3) im_pct
from v$latchname n, v$latchholder h, v$latch l
where l.latch#=n.latch#
and l.addr=h.laddr(+)
and (l.immediate_misses*100>0.5*l.immediate_gets
or misses*100>0.5*l.gets)
order by misses/l.gets desc;
ttitle off

DEF _lhp_what="sid,name,func"
DEF _lhp_sid="%"
DEF _lhp_name="%"
DEF _lhp_samples="100000"

SET VERIFY OFF
set feedback off echo off
COL name FOR A40 WRAP
COL latchprof_total_ms HEAD "Held ms" FOR 999999.999
COL latchprof_pct_total_samples head "Held %" format 999.99
COL latchprof_avg_ms   HEAD "Avg hold ms" FOR 999999.999
COL dist_samples       HEAD Gets
COL total_samples      HEAD Held
COL ksllwnam           FOR A40 TRUNCATE
COL ksllwlbl           FOR A20 TRUNCATE
COL objtype            FOR A20 TRUNCATE
COL object             FOR A17 WRAP JUST RIGHT
COL hmode              FOR A12 TRUNCATE
COL what               FOR A17 WRAP
COL func               FOR A40 TRUNCATE
COL timemodel          FOR A32 WORD_WRAP

BREAK ON lhp_name SKIP 1
DEF _IF_ORA_10_OR_HIGHER="--"
--PROMPT -- LatchProfX 2.03 by Tanel Poder ( https://blog.tanelpoder.com )
COL latchprof_oraversion NEW_VALUE _IF_ORA_10_OR_HIGHER NOPRINT
SET TERMOUT OFF
SELECT 
    DECODE(SUBSTR(BANNER, INSTR(BANNER, 'Release ')+8,1), 1, '', '--') latchprof_oraversion 
FROM v$version WHERE ROWNUM=1;
SET TERMOUT ON
WITH t1 AS (SELECT hsecs FROM v$timer),
    samples AS (
        SELECT /*+ ORDERED USE_NL(l.x$ksuprlat) USE_NL(s.x$ksuse) NO_TRANSFORM_DISTINCT_AGG */
            &_lhp_what
            &_IF_ORA_10_OR_HIGHER , COUNT(DISTINCT gets)        dist_samples
          , COUNT(*)                    total_samples
          , COUNT(*) / &_lhp_samples    total_samples_pct
        FROM 
            (SELECT /*+ NO_MERGE */ 1 FROM DUAL CONNECT BY LEVEL <= &_lhp_samples) s,
            (SELECT ksuprpid PID, ksuprsid SID, ksuprlnm NAME, ksuprlat LADDR, ksulawhr, 
                    TO_CHAR(ksulawhy,'XXXXXXXXXXXXXXXX') object
                    &_IF_ORA_10_OR_HIGHER , ksulagts GETS
                    &_IF_ORA_10_OR_HIGHER , lower(ksuprlmd) HMODE
             FROM x$ksuprlat) l,
            (SELECT
                    indx
                  , ksusesqh     sqlhash
                  , ksusesql     sqladdr 
                  &_IF_ORA_10_OR_HIGHER , CASE WHEN BITAND(ksusstmbv, POWER(2, 01)) = POWER(2, 01) THEN 'DBTIME '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 02)) = POWER(2, 02) THEN 'BACKGROUND '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 03)) = POWER(2, 03) THEN 'CONNECTION_MGMT '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 04)) = POWER(2, 04) THEN 'PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 05)) = POWER(2, 05) THEN 'FAILED_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 06)) = POWER(2, 06) THEN 'NOMEM_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 07)) = POWER(2, 07) THEN 'HARD_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 08)) = POWER(2, 08) THEN 'NO_SHARERS_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 09)) = POWER(2, 09) THEN 'BIND_MISMATCH_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 10)) = POWER(2, 10) THEN 'SQL_EXECUTION '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 11)) = POWER(2, 11) THEN 'PLSQL_EXECUTION '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 12)) = POWER(2, 12) THEN 'PLSQL_RPC '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 13)) = POWER(2, 13) THEN 'PLSQL_COMPILATION '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 14)) = POWER(2, 14) THEN 'JAVA_EXECUTION '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 15)) = POWER(2, 15) THEN 'BIND '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 16)) = POWER(2, 16) THEN 'CURSOR_CLOSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 17)) = POWER(2, 17) THEN 'SEQUENCE_LOAD '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 18)) = POWER(2, 18) THEN 'INMEMORY_QUERY '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 19)) = POWER(2, 19) THEN 'INMEMORY_POPULATE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 20)) = POWER(2, 20) THEN 'INMEMORY_PREPOPULATE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 21)) = POWER(2, 21) THEN 'INMEMORY_REPOPULATE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 22)) = POWER(2, 22) THEN 'INMEMORY_TREPOPULATE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 23)) = POWER(2, 23) THEN 'TABLESPACE_ENCRYPTION ' END timemodel
                  &_IF_ORA_10_OR_HIGHER , ksusesph planhash
                  &_IF_ORA_10_OR_HIGHER , ksusesch sqlchild
                  &_IF_ORA_10_OR_HIGHER , ksusesqi sqlid
             FROM x$ksuse) s,
            (SELECT indx, 
                    ksllwnam func, ksllwnam,
                    ksllwlbl objtype, ksllwlbl 
             FROM x$ksllw) w
        WHERE
            l.sid LIKE '&_lhp_sid'
        AND l.ksulawhr = w.indx (+)
        AND l.sid = s.indx
        AND (LOWER(l.name) LIKE LOWER('%&_lhp_name%') OR LOWER(RAWTOHEX(l.laddr)) LIKE LOWER('%&_lhp_name%'))
        GROUP BY
            &_lhp_what
        ORDER BY
            total_samples DESC
    ),
    t2 AS (SELECT hsecs FROM v$timer)
SELECT /*+ ORDERED */
    &_lhp_what
  , s.total_samples
  &_IF_ORA_10_OR_HIGHER , s.dist_samples
--  , s.total_samples_pct
  , s.total_samples / &_lhp_samples * 100 latchprof_pct_total_samples
  , (t2.hsecs - t1.hsecs) * 10 * s.total_samples / &_lhp_samples latchprof_total_ms
--  , s.dist_events
    &_IF_ORA_10_OR_HIGHER , (t2.hsecs - t1.hsecs) * 10 * s.total_samples / dist_samples / &_lhp_samples latchprof_avg_ms
  FROM
    t1,
    samples s,
    t2
  WHERE ROWNUM <= 40
/
EOF
logf
}

# rtpi 192.168.1.131 askona1 bind | egrep -v "SQL|------" | sed '/^$/d' | awk '{print "/home/oracle/tal/run_tpi.sh 192.168.1.131 askona1 bind  "sq substr($0,1,60) sq}' sq="~" | awk -F"'" '{print $1 }'| sed -e 's|"|\\"|g' -e 's|(|\\(|g' -e 's|)|\\)|g' -e "s|~|\'|g"
bind()
{
if [ -n "$ALL" ]; then
$SP <<EOF >>$LOGF
 set lines 200
 set echo off feed off veri off tab off pages 50
 prompt sql_text
 break on SQL_text
 column name for a5
 column VALUE_STRING for a25
 column SQL_text for a130
 column module for a16
 column SQL_ID for a14
 select a.module, a.SQL_ID, a.SQL_text, b.name, b.VALUE_STRING from v\$sqlarea a, V\$SQL_BIND_CAPTURE b
 where a.sql_id  = b.sql_id (+) and a.sql_text like '%$ALL%' and a.sql_text not like '%select a.module, a.SQL_ID, a.SQL_text%' and rownum < 11;
EOF
else
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 50
column sql for a60
select * from (
SELECT substr(sql_text,1,60) "SQL",
         count(*) ,
         sum(executions) "TotExecs"
    FROM v\$sqlarea
   WHERE executions < 5
   GROUP BY substr(sql_text,1,60)
  HAVING count(*) > 30
   ORDER BY 2 desc
) where rownum <60;
EOF
fi
logf
}


pipe()
{
if [ -n "$ALL" ]; then
$SP <<EOF >$LOGF
set lines 230
set serveroutput on
set echo off feed off veri off tab off pages 0
declare
v_pipe varchar2(32) := '$ALL';
v_p pls_integer;
v_data VARCHAR2(4000);
v_out clob;
begin
 v_out :='';
 v_p := DBMS_PIPE.RECEIVE_MESSAGE(v_pipe, 0);
        WHILE v_p = 0 LOOP
                DBMS_PIPE.UNPACK_MESSAGE(v_data);
                v_out := v_out || v_data ||chr(13)||chr(10);
                v_p := DBMS_PIPE.RECEIVE_MESSAGE(v_pipe, 0);
        END LOOP;
  dbms_output.put_line(v_out);
end;
/
EOF
else
  $SP <<'EOF' >$LOGF
  set lines 230
  set echo off feed off veri off tab off pages 40
  column name for a40
  select name,pipe_size from sys.V_$DB_PIPES
  where name not like '%LOCK%'
  order by pipe_size desc;
EOF
fi
logf
}

longops()
{
P1_="$1"
shopt -s nocasematch
case "$P1_" in
rman)
$SP <<EOF >$LOGF
set lines 230
col filename for a60
col bytes for 999999999999
PROMPT v\$block_change_tracking information:
select status, filename, bytes from v\$block_change_tracking;

COLUMN CLIENT_INFO FORMAT a30
COLUMN SID FORMAT 99999
COLUMN SPID FORMAT 999999
PROMPT
PROMPT RMAN sessions:
SELECT s.SID, p.SPID, s.CLIENT_INFO FROM V\$PROCESS p, V\$SESSION s WHERE p.ADDR = s.PADDR AND CLIENT_INFO LIKE 'rman%';
col dbsize_gbytes for 99,999,990.00 justify right head "DBSIZE_GB"
col input_gbytes for 99,999,990.00 justify right head "READ_GB"
col output_gbytes for 99,999,990.00 justify right head "WRITTEN_GB"
col output_device_type for a10 justify left head "DEVICE"
col complete for 990.00 justify right head "COMPLETE %"
col compression for 990.00 justify right head "COMPRESS|% ORIG"
col est_complete for a20 head "ESTIMATED COMPLETION"
col recid for 9999999 head "ID"
col start_time for a10
col end_time for a10
col est_complete for a10
col sysdate for a10
PROMPT
PROMPT v\$rman_status Estimate time of current backup if block_change_tracking is disabled:
col status for a10
col object_type for a15
select recid, status, object_type, start_time, end_time, output_device_type, dbsize_gbytes
, input_bytes/1024/1024/1024 input_gbytes, output_bytes/1024/1024/1024 output_gbytes
, (output_bytes/input_bytes*100) compression , ((mbytes_processed)/dbsize_gbytes/1024*100) complete
, to_char(start_time + (sysdate-start_time)/(mbytes_processed/dbsize_gbytes/1024),'DD/MM/YYYY HH24:MI:SS') est_complete , sysdate
from v\$rman_status rs, (select sum(bytes)/1024/1024/1024 dbsize_gbytes from v\$datafile)
where status like 'RUNNING%' and
output_device_type is not null
and start_time>sysdate-3 and mbytes_processed>0
order by  start_time;

PROMPT v\$rman_backup_job_details v\$rman_status Estimate time of current backup if block_change_tracking is enabled:
select df_total, df_backuped, round((df_backuped*100)/nvl(df_total,1),2) percent_complete, start_time
, to_char(start_time + (sysdate-start_time)/decode( (df_backuped/df_total), '0', '1', df_backuped/df_total) , 'DD/MM/YYYY HH24:MI:SS') est_complete
from (SELECT count(vbd.file#) df_backuped
FROM v\$rman_backup_job_details vrbjd, v\$backup_datafile vbd
WHERE vbd.file#>0 and vbd.completion_time BETWEEN vrbjd.start_time AND vrbjd.end_time
AND vrbjd.input_type <> 'ARCHIVELOG'
and vrbjd.start_time >= (select max(start_time) from v\$rman_status where status like 'RUNNING%' and operation like 'RMAN%')
), (select count(*) df_total from v\$datafile),
(select max(start_time) start_time from v\$rman_status where status like 'RUNNING%' and operation like 'RMAN%') ;
EOF
;;
*)
  case "$(is_number $P1_)" in
    0) SQL_="print_table('select b.* from v\$session a, v\$session_longops b where a.sid = b.sid and a.serial# = b.serial# and a.status=''ACTIVE'' and b.message like ''%$P1_%'' and SOFAR<>TOTALWORK order by b.sid,b.start_time');" ;;
    1) SQL_="print_table('select b.* from v\$session a, v\$session_longops b where a.sid = b.sid and a.serial# = b.serial# and a.status=''ACTIVE'' and a.sid = ''$P1_'' and SOFAR<>TOTALWORK order by b.sid,b.start_time');" ;;
  esac
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
set serveroutput on size 1000000
declare
procedure print_table( p_query in varchar2 )
is
    l_theCursor     integer default dbms_sql.open_cursor;
    l_columnValue   varchar2(4000);
    l_status        integer;
    l_descTbl       dbms_sql.desc_tab;
    l_colCnt        number;
begin
    dbms_sql.parse(  l_theCursor,  p_query, dbms_sql.native );
    dbms_sql.describe_columns( l_theCursor, l_colCnt, l_descTbl);
    for i in 1 .. l_colCnt loop
        dbms_sql.define_column(l_theCursor, i, l_columnValue, 4000);
    end loop;
    l_status := dbms_sql.execute(l_theCursor);
    while ( dbms_sql.fetch_rows(l_theCursor) > 0 ) loop
        for i in 1 .. l_colCnt loop
           dbms_sql.column_value( l_theCursor, i, l_columnValue );
           dbms_output.put_line( rpad( l_descTbl(i).col_name, 30 )
                                  || ': ' ||
                                  l_columnValue );
        end loop;
        dbms_output.put_line( '---------------------------------------------------' );
    end loop;
exception
    when others then
        dbms_sql.close_cursor( l_theCursor );
        RAISE;
end;

begin
 $SQL_
end;
/
EOF
;;
esac
logf
}


scheduler()
{
P1_="$1"
P2_="$2"
P3_="$3"
case "$P1_" in
log)
$SP <<EOF >$LOGF
prompt dba_scheduler_job_log for job_name like '$P2_' and LOG_DATE > nvl('$P3_',24) hours
set echo off feed off veri off tab off pages 140
set lines 230 pages 60 long 10000
col LOG_ID for 999999999
col LOG_DATE for a19
col OWNER for a20
col JOB_NAME for a30
col JOB_CLASS for a30
col OPERATION for a10
col STATUS for a10
col USER_NAME for a20
col ADDITIONAL_INFO for a50
select LOG_ID,cast(LOG_DATE as date) LOG_DATE,OWNER,JOB_NAME,JOB_CLASS,OPERATION,STATUS,USER_NAME,ADDITIONAL_INFO from DBA_SCHEDULER_JOB_LOG 
where job_name='$P2_' and LOG_DATE > sysdate - (1*(nvl('$P3_',24)/24)) order by LOG_DATE;
EOF
;;
run)
$SP <<EOF >$LOGF
prompt dba_scheduler_job_run_details for job_name like '$P2_' and ACTUAL_START_DATE > sysdate - (1*(nvl('$P3_',24)/24)) 
set echo off feed off veri off tab off pages 140
set lines 230
col owner for a25
col job_name for a30
col STATUS for a10
col SESSION_ID for a14
col SLAVE_PID for a10
col ERROR# for 9999999
col ACTUAL_START_DATE for a19
col RUN_DURATION for a20
select owner, job_name, STATUS, SESSION_ID, SLAVE_PID, ERROR#, cast(ACTUAL_START_DATE as date) ACTUAL_START_DATE, RUN_DURATION  from dba_scheduler_job_run_details 
where job_name like '$P2_' and ACTUAL_START_DATE > sysdate - (1*(nvl('$P3_',24)/24)) 
--and run_duration > interval '10' second
order by ACTUAL_START_DATE;
EOF
;;
autotask)
$SP <<EOF >$LOGF
set echo off feed off veri off tab off pages 140 timing off
set lines 230
col operation_name for a60
col client_name for a60
col status for a15
select operation_name, status from dba_autotask_operation order by operation_name; 
select client_name, status from dba_autotask_client order by client_name;
column WINDOW_NAME for a20
column duration for a20
column REPEAT_INTERVAL for a70
col LAST_START_DATE for a20
select window_name,REPEAT_INTERVAL,duration,cast(LAST_START_DATE as date) LAST_START_DATE,ENABLED from dba_scheduler_windows;
column CLIENT_NAME for a35
column JOB_NAME for a25
column JOB_STATUS for a10
column JOB_START_TIME for a20
column JOB_DURATION for a20
column JOB_INFO for a80
select client_name,JOB_NAME,JOB_STATUS,cast (JOB_START_TIME as date) JOB_START_TIME,JOB_DURATION, job_info from DBA_AUTOTASK_JOB_HISTORY
where JOB_START_TIME > systimestamp - 3 and client_name='auto optimizer stats collection' order by JOB_START_TIME;
EOF
;;
*)
$SP <<EOF >$LOGF
set echo off feed off veri off tab off pages 140
set lines 230
col owner for a15
col job_name for a30
col PROGRAM for a18
col JOB_ACTION for a100
col ENABLED for a7
col REPEAT_INTERVAL for a22
col LAST_START_DATE for a10
col LAST_RUN_DURATION for a14
select owner, job_name, (PROGRAM_OWNER || CASE when PROGRAM_OWNER is null then '' else '.' END || PROGRAM_NAME) PROGRAM, JOB_ACTION, ENABLED, REPEAT_INTERVAL,
cast(LAST_START_DATE as date) LAST_START_DATE, LAST_RUN_DURATION
from dba_scheduler_jobs where job_name like nvl('$P1_','%') --and ENABLED='TRUE'
order by owner, job_name;

prompt "View: dba_scheduler_running_jobs"
col elapsed_time for a16
col cpu_used for a16
col job_action for a50
select r.owner,r.job_name,r.session_id,r.slave_os_process_id,r.elapsed_time,r.cpu_used,s.job_action
from dba_scheduler_running_jobs r, dba_scheduler_jobs s
where s.owner=r.owner and s.job_name=r.job_name;
ttitle off
EOF
;;
esac
logf
}


job()
{
P1_=$1
$SP <<EOF >$LOGF
set lines 250
set echo off feed off veri off tab off pages 40
column job  for 999999999
column log_user  for a12
column last_date  for a10
column next_date  for a10
column interval for a15
column FAILURES for 999999
column WHAT for a100
select JOB, LOG_USER, LAST_DATE,NEXT_DATE,BROKEN,INTERVAL,FAILURES, WHAT from dba_jobs  where LOG_USER like upper('${P1_}%'); 

PROMPT join views  dba_jobs_running, dba_jobs, v\$process, v\$session
set lines 200
column spid for a18
column sid for 99999
column serial# for 999999
column job for 99999999
column username for a15
column schemaname for a15
column log_user for a15
column program for a20
column what for a40
column logon_time  for a10
select /*+rule*/ 'kill -9 '||p.spid spid, d_j.job,
  s.sid, s.serial#, p.program,  s.username,  s.schemaname, 
  d_j.log_user, d_j.what, s.logon_time, d_j.next_date
   from v\$process p, v\$session s, dba_jobs_running j, dba_jobs d_j
   where p.addr = s.paddr and j.sid=s.sid and d_j.job(+)=j.job ;
EOF
logf
}


rman()
{
P1_=$1
[ -z "$P1_" ] && P1_=7
shopt -s nocasematch
case "$P1_" in
cfg)
$SP <<EOF >$LOGF
set lines 250
set echo off feed off veri off tab off timing off pages 90
col name for a50
col value for a100
select * from v\$rman_configuration order by conf#;
EOF
;;
last)
$SP <<EOF >$LOGF
set lines 250
set echo off feed off veri off tab off timing off pages 9
select name,
  max(decode(input_type,'DB FULL',hours,-1))                                     last_full,
  max(decode(input_type,'DB INCR',decode(incremental_level,   0,hours,null),-1)) last_lev0,
  max(decode(input_type,'DB INCR',decode(incremental_level,   1,hours,null),-1)) last_lev1,
  max(decode(input_type,'DB INCR',decode(incremental_level,null,hours,null),-1)) last_bck,
  max(decode(input_type,'ARCHIVELOG',hours,-1))                                  last_arch,
  (select ceil((sysdate-max(completion_time))*24)  from  V\$BACKUP_SET_DETAILS where controlfile_included='YES') last_ctrl
from (
select /*+ rule */ (select name from v\$database) name, input_type, incremental_level, max(END_TIME) last, ceil((sysdate - max(END_TIME))*24) hours
  from V\$RMAN_BACKUP_JOB_DETAILS j, V\$BACKUP_SET_DETAILS  s
where s.session_recid = j.session_recid
  and s.session_stamp = j.session_stamp
  and s.session_key   = j.session_key
  and j.end_time > sysdate-30
  and j.status like 'COMPLETED%'
group by input_type, incremental_level
)
group by name;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 250
set echo off feed off veri off tab off pages 90
column filename for a90
select filename,status from v\$block_change_tracking;
PROMPT D - data file full backup, I - incremental backup, L - backup contains archived redo logs
column OUTPUT_DEVICE_TYPE for a18
column start_time for a20
column end_time for a20
column input_mbytes for 999999999
column output_mbytes for 999999999
column compress_ratio for 99999
column status for a25
column input_type for a10
column dow for a10
column time_taken_display for a18
column cf for 9999
column df for 9999
column d for 9999
column i0 for 9999
column i1 for 9999
select
  j.session_recid sess, j.session_stamp,
  to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time,
  to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time,
  (j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type,
  decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday',
                                     3, 'Tuesday', 4, 'Wednesday',
                                     5, 'Thursday', 6, 'Friday',
                                     7, 'Saturday') dow,
  trunc(j.elapsed_seconds) ela_sec, j.time_taken_display,
  x.cf, x.d0, x.i0, x.i1, x.i2, x.l --,ro.inst_id inst_id
from V\$RMAN_BACKUP_JOB_DETAILS j
  left outer join (select
                     d.session_recid, d.session_stamp,
                     sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) CF,
--                     sum(case when d.controlfile_included = 'NO' and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF,
--                     sum(case when d.backup_type = 'D' then d.pieces else 0 end) DF,
                     sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) D0,
                     sum(case when d.backup_type||d.incremental_level = 'I0' then d.pieces else 0 end) I0,
                     sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) I1,
                     sum(case when d.backup_type||d.incremental_level = 'I2' then d.pieces else 0 end) I2,
                     sum(case when d.backup_type = 'L' then d.pieces else 0 end) L
                   from
                     V\$BACKUP_SET_DETAILS d
                     join V\$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count
                   where s.input_file_scan_only = 'NO'
                   group by d.session_recid, d.session_stamp) x
    on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp
  left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id
                   from GV\$RMAN_OUTPUT o
                   group by o.session_recid, o.session_stamp)
    ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp
where j.start_time > trunc(sysdate)-7
--AND OUTPUT_DEVICE_TYPE NOT IN ('SBT_TAPE')
order by j.start_time;
EOF
;;
esac
logf
}


get_ddl()
{
echo "usage: get_ddl TYPE OBJECT OWNER"
if [ -n "$ALL" ]; then
type_=$(tr '[:lower:]' '[:upper:]' <<< "$1")
object_=$(tr '[:lower:]' '[:upper:]' <<< "$2")
owner_=$(tr '[:lower:]' '[:upper:]' <<< "$3")
echo "TYPE: "$type_"  OBJECT: "$object_"  OWNER: "$owner_

shopt -s nocasematch
case "$type_" in
 PACKAGE_SPEC)            o_type_='PACKAGE' ;;
 PACKAGE_BODY)            o_type_='PACKAGE BODY' ;;
 JAVA_SOURCE)             o_type_='JAVA SOURCE' ;;
 DB_LINK)                 o_type_='DATABASE LINK' ;;
 TYPE_BODY)               o_type_='TYPE BODY' ;;
 MATERIALIZED_VIEW)       o_type_='MATERIALIZED VIEW' ;;
 MATERIALIZED_VIEW_LOG)   o_type_='MATERIALIZED VIEW LOG' ;;
 RMGR_CONSUMER_GROUP)     o_type_='CONSUMER GROUP' ;;
 RMGR_PLAN)               o_type_='RESOURCE PLAN' ;;
 ROLE)                    o_type_='ROLE' ;;
 *)                       o_type_=$type_ ;;
esac

case "$type_" in
USER)
$SP <<EOF >>$LOGF
SET LONG 10000000 LONGCHUNKSIZE 10000000 PAGESIZE 0 LINESIZE 180 FEEDBACK OFF VERIFY OFF TRIMSPOOL ON
BEGIN
   DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
   DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'PRETTY', true);
END;
/
SELECT dbms_metadata.get_ddl('USER','$object_') FROM dual;
prompt prompt SYSTEM_GRANTS:
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','$object_') from dual;
prompt prompt ROLE_GRANTS:
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','$object_') from dual;
prompt prompt OBJECT_GRANTS:
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','$object_') from dual;
EOF
;;
JOB)
$SP <<EOF >>$LOGF
SET LONG 10000000 LONGCHUNKSIZE 10000000 PAGESIZE 0 LINESIZE 230 FEEDBACK OFF VERIFY OFF TRIMSPOOL ON
SELECT dbms_metadata.get_ddl('PROCOBJ','$object_', '$owner_') from dual;
EOF
;;
TABLESPACE)
$SP <<EOF >>$LOGF
SET LONG 10000000 LONGCHUNKSIZE 10000000 PAGESIZE 0 LINESIZE 230 FEEDBACK OFF VERIFY OFF TRIMSPOOL ON
exec DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
select dbms_metadata.get_ddl('$type_','$object_') from dual;
EOF
;;
ROLE)
$SP <<EOF >>$LOGF
set long 1000000 longchunksize 200000 pagesize 0 linesize 1000 feedback off verify off trimspool on
column ddl format a1000
begin
   dbms_metadata.set_transform_param (dbms_metadata.session_transform, 'SQLTERMINATOR', true);
   dbms_metadata.set_transform_param (dbms_metadata.session_transform, 'PRETTY', true);
end;
/
variable v_role VARCHAR2(30);
exec :v_role := upper('$object_');
select dbms_metadata.get_ddl('ROLE', r.role) AS ddl
from   dba_roles r
where  r.role = :v_role
union all
select dbms_metadata.get_granted_ddl('ROLE_GRANT', rp.grantee) AS ddl
from   dba_role_privs rp
where  rp.grantee = :v_role
and    rownum = 1
union all
select dbms_metadata.get_granted_ddl('SYSTEM_GRANT', sp.grantee) AS ddl
from   dba_sys_privs sp
where  sp.grantee = :v_role
and    rownum = 1
union all
select dbms_metadata.get_granted_ddl('OBJECT_GRANT', tp.grantee) AS ddl
from   dba_tab_privs tp
where  tp.grantee = :v_role
and    rownum = 1
/
EOF
;;
*)
$SP <<EOF >$LOGF
set echo off feed off veri off tab off
alter session set NLS_DATE_FORMAT='dd/mm/yyyy hh24:mi:ss';
prompt "NLS_DATE_FORMAT='dd/mm/yyyy hh24:mi:ss'"
set linesize 5000 pages 0
set long 10000000 longc 10000000
SET SERVEROUTPUT ON SIZE UNLIMITED;
declare
 c clob;
 PROCEDURE DISPLAY_CLOB (P_CLOB IN CLOB) IS
--  l_amt NUMBER DEFAULT 32000;
  l_amt NUMBER DEFAULT 24000;
  l_offset NUMBER DEFAULT 1;
  l_length NUMBER DEFAULT NVL (DBMS_LOB.getlength (p_clob), 0);
  x varchar2(32760);
 BEGIN
  WHILE (l_offset < l_length) LOOP
   dbms_lob.read (p_clob, l_amt, l_offset, x);
   l_offset := l_offset + l_amt;
   DBMS_OUTPUT.PUT_LINE(X);
  END LOOP;
 END DISPLAY_CLOB;
begin
   DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
   for i in (select owner,object_name,object_type from dba_objects where owner='$owner_' and object_name = '$object_' /*and object_type='$o_type_'*/ order by object_name) loop
     select dbms_metadata.get_ddl('$type_',i.object_name,'$owner_') into c from dual;
       DISPLAY_CLOB(c);
--     DBMS_OUTPUT.PUT_LINE(c);
   end loop;
end;
/
--exec DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
--select dbms_metadata.get_ddl('$type_','$object_','$owner_') from dual;
EOF
;;
esac
logf
else
echo " ORACLE 9.0.1 "
echo "  "
echo " Type Name                       Meaning "
echo " ASSOCIATION                     associate statistics  "
echo " AUDIT                           audits of SQL statements  "
echo " AUDIT_OBJ                       audits of schema objects  "
echo " CLUSTER                         clusters  "
echo " COMMENT                         comments  "
echo " CONSTRAINT                      constraints  "
echo " CONTEXT                         application contexts  "
echo " DB_LINK                         database links  "
echo " DEFAULT_ROLE                    default roles  "
echo " DIMENSION                       dimensions  "
echo " DIRECTORY                       directories  "
echo " FUNCTION                        stored functions  "
echo " INDEX                           indexes  "
echo " INDEXTYPE                       indextypes  "
echo " JAVA_SOURCE                     java sources  "
echo " LIBRARY                         external procedure libraries  "
echo " MATERIALIZED_VIEW               materialized views  "
echo " MATERIALIZED_VIEW_LOG           materialized view logs  "
echo " OBJECT_GRANT                    object grants  "
echo " OPERATOR                        operators  "
echo " OUTLINE                         stored outlines  "
echo " PACKAGE                         stored packages  "
echo " PACKAGE_SPEC                    package specifications  "
echo " PACKAGE_BODY                    package bodies  "
echo " PROCEDURE                       stored procedures  "
echo " PROFILE                         profiles  "
echo " PROXY                           proxy authentications  "
echo " REF_CONSTRAINT                  referential constraint  "
echo " ROLE                            roles  "
echo " ROLE_GRANT                      role grants  "
echo " ROLLBACK_SEGMENT                rollback segments  "
echo " SEQUENCE                        sequences  "
echo " SYNONYM                         synonyms  "
echo " SYSTEM_GRANT                    system privilege grants  "
echo " TABLE                           tables  "
echo " TABLESPACE                      tablespaces  "
echo " TABLESPACE_QUOTA                tablespace quotas  "
echo " TRIGGER                         triggers  "
echo " TRUSTED_DB_LINK                 trusted links  "
echo " TYPE                            user-defined types  "
echo " TYPE_SPEC                       type specifications  "
echo " TYPE_BODY                       type bodies  "
echo " USER                            users  "
echo " VIEW                            views  "
echo " XMLSCHEMA                       XML schema  "
echo "  "
echo "  "
echo " ORACLE 10.1.0 "
echo "  "
echo " Type Name                       Meaning "
echo " AQ_QUEUE                        queues  "
echo " AQ_QUEUE_TABLE                  additional metadata for queue tables  "
echo " AQ_TRANSFORM                    transforms  "
echo " DATABASE_EXPORT                 all metadata objects in a database  "
echo " FGA_POLICY                      fine-grained audit policies  "
echo " INDEX_STATISTICS                indextypes  "
echo " JOB                             scheduler jobs (Current support scheduled for 11.2 .. See NOTE:567504.1)   "
echo " REFRESH_GROUP                   refresh groups  "
echo " RESOURCE_COST                   resource cost info  "
echo " RLS_CONTEXT                     driving contexts for enforcement of fine-grained access-control policies  "
echo " RLS_GROUP                       fine-grained access-control policy groups  "
echo " RLS_POLICY                      fine-grained access-control policies  "
echo " RMGR_CONSUMER_GROUP             resource consumer groups  "
echo " RMGR_INTITIAL_CONSUMER_GROUP    assign initial consumer groups to users  "
echo " RMGR_PLAN                       resource plans  "
echo " RMGR_PLAN_DIRECTIVE             resource plan directives  "
echo " SCHEMA_EXPORT                   sequences  "
echo " TABLE_DATA                      metadata describing row data for a table, nested table, or partition  "
echo " TABLE_EXPORT                    metadata for a table and its associated objects  "
echo " TABLE_STATISTICS                precomputed statistics on tables  "
echo " TRANSPORTABLE_EXPORT            metadata for objects in a transportable tablespace set "
echo ""
echo " Extract DDL for job:"
echo " PROCOBJ YOURJOBNAME YOURJOBOWNER  Capture DDL for Scheduler Jobs"
fi
}



psql()
{
if [ -z "$*" ]; then echo "No parameters"; return ; fi
TEXT_=$(tr '[:upper:]' '[:lower:]' <<< "$*")
P1_="$1"
P2_="$2"
P3_="$3"
shopt -s nocasematch
case "$P1_" in
  sqlstat)
    ash sqlstat $P2_ $P3_
    return
  ;;
  plan)
    echo "v\$sql_plan where sql_id = "$P2_
    $SP <<EOF >$LOGF
    set lines 230 pages 200
    column id noprint
    column plan for a130
    BREAK ON timestamp ON sql_id ON plan_hash_value ON child_number SKIP 1 NODUPLICATES
    SELECT  distinct sql_id,plan_hash_value, child_number, cost, cardinality, bytes, id, lpad(id,3,'0') ||' '|| lpad (' ', depth) || operation ||' '|| options ||' '|| object_name plan
    from v\$sql_plan where  sql_id = '$P2_'
    order by sql_id,plan_hash_value,child_number,id;
EOF
  ;;
  *)
    LEN_=$(expr length $P1_)
    SQL_ID__=$(tr -d '[:digit:][:lower:]' <<< "$P1_")
    if [ -z "$SQL_ID__" -a $LEN_ -eq 13 ] ; then
      SQL_="SELECT sql_id||' '|| plan_hash_value SQL_ID_PHV, child_number CN, SQL_FULLTEXT, module||' / '|| action MA, SQL_PROFILE, SQL_PATCH, SQL_PLAN_BASELINE, LAST_LOAD_TIME, LAST_ACTIVE_TIME FROM v\$sql where sql_id = '$P1_';"
      echo " v\$sql where sql_id = "$P1_
    else
      SQL_="SELECT sql_id||' '|| plan_hash_value SQL_ID_PHV, child_number CN, SQL_FULLTEXT, module||' / '|| action MA,SQL_PROFILE, SQL_PATCH, SQL_PLAN_BASELINE, LAST_LOAD_TIME, LAST_ACTIVE_TIME  FROM v\$sql where lower(sql_text) like '%$TEXT_%';"
      echo "v\$sql where lower(sql_text) like "$TEXT_
    fi
$SP <<EOF >$LOGF
set lines 230 pages 90
set long 1000000000 longc 1000000000
column sql_id for a13
column SQL_ID_PHV for a13 heading "SQL_ID / PHV"
column SQL_FULLTEXT for a100
column PHV for 9999999999
column CN for 99
column MA for a16 heading "MODULE/ACTION"
column SQL_PROFILE for a30
column SQL_PATCH for a9
column SQL_PLAN_BASELINE for a30
column LAST_LOAD_TIME for a10
column LAST_ACTIVE_TIME for a10
$SQL_
EOF
;;
esac
logf
}


awr_tempusage()
{
view_=$1
allocated_=$2
limit_=1024
if [ -z "$allocated_" ]; then
  allocated_=$limit_
fi
COND_="and sample_time $INTERVAL_"

$SP <<EOF >$LOGF
set lines 230  pages 80
PROMPT "AWR_tempusage from $view_ for temp_diff >= $allocated_ Mb and sample_time $INTERVAL_"
set timing on
col SAMPLE_TIME for a15
col SQL_ID  for a15
col TEMP_DIFF for 9999999999
select session_id,session_serial#, t.sample_time, t.sql_id, /*t.temp_mb,*/ t.temp_diff
  from ( select session_id,session_serial#,
               to_char(sample_time, 'DD/MM/YYYY HH24') sample_time,sql_id, /*sum(temp_mb) temp_mb,*/ sum(temp_diff) temp_diff
               , row_number() over (partition by to_char(sample_time, 'DD/MM/YYYY HH24') order by sum(temp_mb) desc nulls last) as rn
          from ( select sample_time,session_id,session_serial#,sql_id,temp_space_allocated/(1024*1024) temp_mb,
                       temp_space_allocated/1024/1024-lag(temp_space_allocated/1024/1024,1,0) over (partition by session_id,"SESSION_SERIAL#",sql_id order by sample_time) as temp_diff
                 from $view_
                where temp_space_allocated > 0
		  $COND_
       )
         group by session_id,session_serial#, to_char(sample_time, 'DD/MM/YYYY HH24'), sql_id
         having sum(temp_diff) >= nvl('$allocated_', $limit_)
       ) t
 order by sample_time, temp_diff desc;
EOF
}



awr_chart()
{
view_=$1
if [ "$view_" = "dba_hist_active_sess_history" ]; then
   S1_="*10"
fi
$SP <<EOF >$LOGF
set lines 350 pages 200 verify off echo off timing off feedback off tab off
column xxx new_value cpu noprint
select value xxx from v\$system_parameter where name='cpu_count';
Def v_secs=60 --  bucket size
Def v_graph=150
--Def v_gadd=+48
Def v_bars440=(&v_graph/sqrt(&cpu))/(sqrt(&cpu)*(22/sqrt(&cpu)))  -- 440 size of one AAS in characters
Def v_bars4=(&v_graph/(50/sqrt(&cpu))) -- 4
Def v_bars128=(&v_graph/(&cpu*11.5/sqrt(&cpu))) -- 4 - 128
Def v_bars=(&v_graph/(&cpu*11.5/sqrt(&cpu))) -- 4 - 128
--column v_bars new_value v_bars noprint
--select case when &cpu > 128 then &v_bars440 else &v_bars128  end  v_bars from dual;

--def B=chr(27)||'[37m'||chr(27)||'[1;'||to_char(29)||'m'||
--def cc=chr(27)||'[37m'||chr(27)||'[1;'||to_char(32)||'m'||
--def ii=chr(27)||'[37m'||chr(27)||'[1;'||to_char(34)||'m'||
--def ww=chr(27)||'[37m'||chr(27)||'[1;'||to_char(33)||'m'||
--def B=''
--def cc=''
--def ii=''
--def ww=''
--Def v_gadd=+48
--Def v_gadd=+0a
$_CHART
def C=*
def I=#
def W=+

col begin_time for a14
col graph format a198 truncate heading "CHART  &C&C&C CPU &C&C&C, &I&I&I IO &I&I&I, &W&W&W WAIT &W&W&W,  cpu_count: &cpu"
--col graph format a150 truncate heading "CHART  &C&C&C CPU &C&C&C, &I&I&I IO &I&I&I, &W&W&W WAIT &W&W&W,  cpu_count: &cpu"
col aas format 9999
col pct1 format 999
col pct2 format 999
col pct3 format 999
col first format  a15 truncate
col second format  a27 truncate
--col third format  a27 truncate
PROMPT "Top activity chart from $view_ in sample_time $INTERVAL_"
select to_char(start_time,'dd/mm/yy-hh24:mi') begin_time,
       --samples,
       --total,
       --waits,
       --cpu,
       round((total/&v_secs)) aas,
       --round(fpct * (total/&v_secs),2) aas1,
       fpct*100  pct1,
       decode(fpct,null,null,first) first,
       --round(spct * (total/&v_secs),2) aas2,
       spct*100 pct2,
       decode(spct,null,null,second) second,
--       tpct*100 pct3,
--       decode(tpct,null,null,third) third,
       substr(
         substr(
           &cc  rpad('&C',round((cpu*&v_bars)/&v_secs),'&C') ||
           &ii  rpad('&I',round((io*&v_bars)/&v_secs),'&I')  ||
           &ww  rpad('&W',round((waits*&v_bars)/&v_secs),'&W')  ||
           &B  rpad(' ',&cpu * &v_bars,' '),0,( &cpu * &v_bars ) &v_gadd) ||
        &cpu || substr(
              &cc  rpad('&C',round((cpu*&v_bars)/&v_secs),'&C') ||
              &ii  rpad('&I',round((io*&v_bars)/&v_secs),'&I')  ||
              &ww  rpad('&W',round((waits*&v_bars)/&v_secs),'&W')  ||
              &B  rpad(' ',&cpu * &v_bars,' '),(&cpu * &v_bars) &v_gadd,(&v_graph-&v_bars*&cpu) &v_gadd )
       ,0,&v_graph &v_gadd) graph 
from (
select start_time
     , max(samples) samples
     , sum(top.total) $S1_ total
     , round(max(decode(top.seq,1,pct,null)),2) fpct
     , substr(max(decode(top.seq,1,decode(top.event,'ON CPU','CPU',event),null)),0,27) first
     , round(max(decode(top.seq,2,pct,null)),2) spct
     , substr(max(decode(top.seq,2,decode(top.event,'ON CPU','CPU',event),null)),0,27) second
     , round(max(decode(top.seq,3,pct,null)),2) tpct
     , substr(max(decode(top.seq,3,decode(top.event,'ON CPU','CPU',event),null)),0,27) third
     , sum(waits) $S1_ waits
     , sum(io) $S1_ io
     , sum(cpu) $S1_ cpu
from (
  select to_date(tday||' '||tmod*&v_secs,'YYMMDD SSSSS') start_time
     , event
     , total
     , row_number() over ( partition by id order by total desc ) seq
     , ratio_to_report( sum(total)) over ( partition by id ) pct
     , max(samples) samples
     , sum(decode(event,'ON CPU',total,0))    cpu
     , sum(decode(event,'ON CPU',0,
                        'db file sequential read',0,
                        'db file scattered read',0,
                        'db file parallel read',0,
                        'direct path read',0,
                        'direct path read temp',0,
                        'direct path write',0,
                        'direct path write temp',0, total)) waits
     , sum(decode(event,'db file sequential read',total,
                                  'db file scattered read',total,
                                  'db file parallel read',total,
                                  'direct path read',total,
                                  'direct path read temp',total,
                                  'direct path write',total,
                                  'direct path write temp',total, 0)) io
  from (
    select to_char(sample_time,'YYMMDD')                      tday
       , trunc(to_char(sample_time,'SSSSS')/&v_secs)          tmod
       , to_char(sample_time,'YYMMDD')||trunc(to_char(sample_time,'SSSSS')/&v_secs) id
       , decode(ash.session_state,'ON CPU','ON CPU',ash.event)     event
       , sum(decode(session_state,'ON CPU',1,decode(session_type,'BACKGROUND',0,1))) total
       , (max(sample_id)-min(sample_id)+1)                    samples
     from $view_  ash
       where sample_time $INTERVAL_
     group by  trunc(to_char(sample_time,'SSSSS')/&v_secs)
            ,  to_char(sample_time,'YYMMDD')
            ,  decode(ash.session_state,'ON CPU','ON CPU',ash.event)
  )  chunks
  group by id, tday, tmod, event, total
) top
group by start_time
) aveact
order by start_time
/
EOF
}


awr_mchart()
{
_CHART="
def B=''
def cc=''
def ii=''
def ww=''
Def v_gadd=+0"
awr_chart $1
}


awr_cchart()
{
_CHART="
def B=chr(27)||'[37m'||chr(27)||'[1;'||to_char(29)||'m'||
def cc=chr(27)||'[37m'||chr(27)||'[1;'||to_char(32)||'m'||
def ii=chr(27)||'[37m'||chr(27)||'[1;'||to_char(34)||'m'||
def ww=chr(27)||'[37m'||chr(27)||'[1;'||to_char(33)||'m'||
Def v_gadd=+48"
awr_chart $1
}



awr_tchart()
{
view_=$1
if [ "$view_" = "dba_hist_active_sess_history" ]; then
    S1_="*10"
fi
$SP <<EOF >$LOGF
set lines 250 pages 100 tab off
col begin_time for a15 heading '1|BEGIN_TIME'
col aas for 9990.99 heading '2|AAS'
col cpu for 9990.99 heading '3|CPU'
col bcpu for 9990.99 heading '4|BCPU'
col scheduler for 9990.99 heading '5|SHEDUL'
col uio for 9990.99 heading '6|UIO'
col sio for 9990.99 heading '7|SIO'
col concurrency for 9990.99 heading '8|CONCUR'
col application for 9990.99 heading '9|APPL'
col COMMIT for 9990.99 heading '10|COMMIT'
col configuration for 9990.99 heading '11|CONFIG'
col administrative for 9990.99 heading '12|ADMIN'
col network for 9990.99 heading '13|NET'
col queueing for 9990.99 heading '14|QUEUE'
col clust for 9990.99 heading '15|CLUST'
col other for 9990.99 heading '16|OTHER'
PROMPT "Data for chart: Average active/waiting sessions from $view_ in sample_time $INTERVAL_"
SELECT
  to_char(sample_time,'dd/mm/yy-hh24:mi') as begin_time,
  aas,
  cpu,
  bcpu,
  scheduler,
  uio,
  sio,
  concurrency,
  application,
  COMMIT,
  configuration,
  administrative,
  network,
  queueing,
  clust,
  other
FROM
  (SELECT
     TRUNC(sample_time,'MI') AS sample_time,
     round(count(*)/60,2) $S1_ AS aas,
     SUM(DECODE(session_state,'ON CPU',DECODE(session_type,'BACKGROUND',0,1),0))/60 $S1_ AS cpu,
     SUM(DECODE(session_state,'ON CPU',DECODE(session_type,'BACKGROUND',1,0),0))/60 $S1_ AS bcpu,
     SUM(DECODE(wait_class,'Scheduler',1,0))/60 $S1_ AS scheduler,
     SUM(DECODE(wait_class,'User I/O',1,0))/60 $S1_ AS uio,
     SUM(DECODE(wait_class,'System I/O',1,0))/60 $S1_ AS sio,
     SUM(DECODE(wait_class,'Concurrency',1,0))/60 $S1_ AS concurrency,
     SUM(DECODE(wait_class,'Application',1,0))/60 $S1_ AS application,
     SUM(DECODE(wait_class,'Commit',1,0))/60 $S1_ AS COMMIT,
     SUM(DECODE(wait_class,'Configuration',1,0))/60 $S1_ AS configuration,
     SUM(DECODE(wait_class,'Administrative',1,0))/60 $S1_ AS administrative,
     SUM(DECODE(wait_class,'Network',1,0))/60 $S1_ AS network,
     SUM(DECODE(wait_class,'Queueing',1,0))/60 $S1_ AS queueing,
     SUM(DECODE(wait_class,'Cluster',1,0))/60 $S1_ AS clust,
     SUM(DECODE(wait_class,'Other',1,0))/60 $S1_ AS other
   FROM $view_
   WHERE sample_time $INTERVAL_ and session_type in ('FOREGROUND','USER')
   GROUP BY TRUNC(sample_time,'MI')) ash
ORDER BY begin_time;
EOF
}



dhash()
{
case "$(db_version)" in
8|9)  echo "Current Oracle Version doesn't have AWR..." ; exit ;;
*)  : ;;
esac

if [ -z "$*" ]; then

$SP <<EOF >$LOGF
set lines 250 
set feedback off
PROMPT
PROMPT Snap_intervel and Retention period from view: DBA_HIST_WR_CONTROL
column SNAP_INTERVAL for a30
column RETENTION for a30
SELECT DBID, SNAP_INTERVAL, RETENTION FROM DBA_HIST_WR_CONTROL where dbid=(select dbid from v\$database);
PROMPT
PROMPT "Avilable period at WRM\$_SNAPSHOT_DETAILS:"
column min_begin_time for a20
column max_end_time for a20
column drop_snapshot_range for a110
select dbid,min(snap_id), cast(min(begin_time) as date) min_begin_time,max(snap_id), cast(max(end_time) as date) max_end_time,
'exec DBMS_WORKLOAD_REPOSITORY.DROP_SNAPSHOT_RANGE(low_snap_id=>'||min(snap_id)||',high_snap_id=>'||max(snap_id)||',dbid =>'||dbid||');' drop_snapshot_range
 from WRM\$_SNAPSHOT_DETAILS group by dbid order by min(begin_time);
EOF

else

sysdate=$(date +%d/%m/%y\ %H:%M:%S)
if [ $(is_number $(awk -F"/" '{print $1}' <<< "$*")) -eq 0 ]; then
 DD_=$(date +%d/%m/%Y)
 HHB_=$(date +%H)
 HHE_=1
 INTERVAL_="between to_date('$sysdate','dd/mm/yy hh24:mi:ss') - interval '$HHE_' hour and sysdate"
else
 DD_=$(awk -F- '{print $1}' <<< "$*")
 HHB_=$(awk -F- '{print $2}' <<< "$*")
 HHE_=$((awk -F- '{print $3}' | cut -d' ' -f1) <<< "$*")
 HHR_=$(awk '$1!~/:/{print $1}' <<< "$HHE_")
 if [ -n "$HHR_" ]; then
   INTERVAL_="between to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') and to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') + interval '$HHR_' hour +  interval '2' minute"
   shift
 else
   INTERVAL_="between to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') and to_date('$DD_ $HHE_','dd/mm/yy hh24:mi') + interval '2' minute"
   shift
 fi
fi

type_=$(awk '{print $1}' <<< "$*")

SET_COL='set lines 250 pages 80
set long 1000000000 longc 1000000000
col "SQL_TEXT" for a80
column TIME for a17
column SID for 99999
column SERIAL for 999999
column USERNAME for a25
column sql_id for a13
column sql_plan_hash_value for 9999999999 heading "PHV"
column EVENT for a30
column wait_class for a14
column OBJ# for 99999999
column FILE# for 999
column BLOCK# for 9999999
column BLSID for 99999
column BLSERIAL for 999999
column BLSTATUS for a11
column PROGRAM for a21
column MODULE for a20
column ACTION for a16
column MACHINE for a20
column PMAM for a70 heading "PROGRAM \ MODULE \ ACTION \ MACHINE" truncated
column TIME_WAITED for 999990.99
column CPU for 99990.99
column WAIT for 99990.99
column IO for 99990.99
column activity for 99990.99 heading "%ACTIVITY"
col sql_opname for a15
col entry_name for a45
column owner for a30
column OBJECT_NAME for a35
column top_level_sql_id for a14
column top_level_call_name for a20'

shopt -s nocasematch
case $type_ in
event)
   $SP <<EOF >$LOGF
   $SET_COL
   PROMPT
   PROMPT "Top 20 events from DBA_HIST_ACTIVE_SESS_HISTORY where sample_time $INTERVAL_"
   select * from ( select nvl(EVENT, 'ON CPU') EVENT, round(100*count(*)/ sum(count(1)) over(), 2) "%ACTIVITY" from DBA_HIST_ACTIVE_SESS_HISTORY
   where sample_time $INTERVAL_ and dbid=(select dbid from v\$database) group by EVENT order by 2 desc ) where rownum<21;
EOF
;;
sess)
P1_=$(awk '{print $2}' <<< "$*")
P2_=$(awk '{print $3}' <<< "$*")
P3_=$(awk '{print $4}' <<< "$*")
if [ -n "$P1_"  -a -n "$P2_" -a "$P3_" = "all" ]; then
  $SP <<EOF >$LOGF
  PROMPT "Session from DBA_HIST_ACTIVE_SESS_HISTORY by filter: sample_time $INTERVAL_  for SID: $P1_  SERIAL: $P2_"
  $SET_COL
  select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
  blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action,machine*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM
  from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id 
  and dbid=(select dbid from v\$database) and sample_time $INTERVAL_ and  session_id = '$P1_' and "SESSION_SERIAL#" = '$P2_' order by sample_time;
EOF
elif [ -n "$P1_" -a -n "$P2_" ]; then
  if [ "$P3_" != "nosqlid" ]; then   S1_="sql_id,sql_plan_hash_value,"; fi
  $SP <<EOF >$LOGF
  PROMPT "Top 30 Waits from DBA_HIST_ACTIVE_SESS_HISTORY by filter: sample_time $INTERVAL_ for sid = '$P1_' and serial = '$P2_'"
  $SET_COL
  select * from (
  select session_id sid,"SESSION_SERIAL#" serial,username, $S1_ nvl(event,'ON CPU') event, program||' \ '||module||' \ '||action||' \ '||machine PMAM,
   sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
   sum(decode(session_state,'ON CPU',wait_time))/1000000     "CPU",
   (sum(decode(session_state,'WAITING',time_waited))  -  sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0))) )/1000000    "WAIT" ,
   sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0)))/1000000    "IO" ,
   round(100*count(*)/ sum(count(1)) over(), 2) activity
  from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id
  and dbid=(select dbid from v\$database) and sample_time $INTERVAL_
  --and  sql_id is not null
  and session_id = '$P1_' and "SESSION_SERIAL#" = '$P2_'
  group by session_id,"SESSION_SERIAL#",username, $S1_  event, program,module,action,machine
  order by activity desc
  ) where rownum<31;
EOF
elif [ -n "$P1_" ]; then
  $SP <<EOF >$LOGF
  PROMPT "Session from DBA_HIST_ACTIVE_SESS_HISTORY by filter: sample_time $INTERVAL_ for SQL_ID: $P1_ "
  $SET_COL
  select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
  blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action,machine*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM
  from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id
  and dbid=(select dbid from v\$database) and sample_time $INTERVAL_ and sql_id = '$P1_' order by sample_time;
EOF
else
  $SP <<EOF >$LOGF
  PROMPT "Top 30 ACTIVE sessions in seconds from DBA_HIST_ACTIVE_SESS_HISTORY by filter: sample_time $INTERVAL_"
  $SET_COL
  select * from (
  select session_id sid,"SESSION_SERIAL#" serial, username,/*sql_id,sql_plan_hash_value,nvl(event,'ON CPU') event,*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM,
   sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
   sum(decode(session_state,'ON CPU',wait_time))/1000000     "CPU",
   (sum(decode(session_state,'WAITING',time_waited))  -  sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0))) )/1000000    "WAIT" ,
   sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0)))/1000000    "IO" ,
   round(100*count(*)/ sum(count(1)) over(), 2) activity
  from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id 
  and dbid=(select dbid from v\$database) and sample_time $INTERVAL_
  --and  sql_id is not null
  group by session_id,"SESSION_SERIAL#", username, /*sql_id,sql_plan_hash_value,event,*/ program,module,action,machine
  order by activity desc
  ) where rownum<31;
EOF
fi
;;
where)
  FIELD_=$(awk '{print $2}' <<< "$*")
  if [ -z "$FIELD_" ]; then FIELD_="program"; fi
  PRG_=$(awk '{print $3}' <<< "$*")
  COND_="and $FIELD_ like '%$PRG_%'"
  $SP <<EOF >$LOGF
  PROMPT "Stat top 30 session_state from DBA_HIST_ACTIVE_SESS_HISTORY where sample_time $INTERVAL_  for condition: $COND_"
  $SET_COL
  select * from (
  select /*session_id sid,"SESSION_SERIAL#" serial,*/ username,
   sql_id,sql_plan_hash_value,
    nvl(event,'ON CPU') event, /* top_level_sql_id, top_level_call_name, */  -- program||' \ '||module||' \ '||action||' \ '||machine PMAM,
    sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
    sum(decode(session_state,'ON CPU',wait_time))/1000000     "CPU",
    (sum(decode(session_state,'WAITING',time_waited))  -  sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0))) )/1000000    "WAIT" ,
    sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0)))/1000000    "IO" ,
    round(100*count(*)/ sum(count(1)) over(), 2) activity
  from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id
  and dbid=(select dbid from v\$database) and sample_time $INTERVAL_
  --and  sql_id is not null 
  --and PLSQL_ENTRY_OBJECT_ID = 11235547
  --and "CURRENT_OBJ#" = 56645
  $COND_
  --and program like '%$PRG_%'
  group by /*session_id,"SESSION_SERIAL#",*/ username,
  sql_id,sql_plan_hash_value,
  event --, /* top_level_sql_id, top_level_call_name, */  session_state,program,module,action,machine 
  order by activity desc
  ) where rownum<31;
EOF
;;
sql)
  P1_=$(awk '{print $2}' <<< "$*")
  case "$P1_" in
  all)
   shift
   shift
   EVENT_="$*"
   echo "EVENT_: "$EVENT_
   $SP <<EOF >$LOGF
   PROMPT "Events from DBA_HIST_ACTIVE_SESS_HISTORY by filter: sample_time $INTERVAL_  Event: $EVENT_"
   PROMPT
   $SET_COL
   column PMAM for a55 heading "PROGRAM \ MODULE \ ACTION \ MACHINE" truncated
   select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,event,wait_class,"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
   blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action,machine*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM
   from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id and dbid=(select dbid from v\$database) and sample_time $INTERVAL_
   and event like '%$EVENT_%' order by sample_time;
EOF
  ;;
  top)
   shift
   shift
   EVENT_="$*"
  if [ -n "$EVENT_" ]; then
   S0_="x.event,"
   S1_="nvl(event,'ON CPU') event,"
   S2_=" and event like '%$EVENT_%'"
   S3_=",event"
  else
   S2_="and sql_id is not null"
  fi
  $SP <<EOF >$LOGF
  $SET_COL
  PROMPT
  PROMPT "Top 30 SQL TIME_WATED in second from DBA_HIST_ACTIVE_SESS_HISTORY where sample_time $INTERVAL_ and $S2_"
  select * from (
  select  x.sql_id, x.sql_plan_hash_value, x.sql_opname, e.object_name || decode(e.object_name,'','','.') || e.procedure_name entry_name, $S0_  x.time_waited,x.cpu,x.wait,x.io, x.activity
  from      dba_procedures    e, dba_procedures    p,
           (select    plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
                      sql_id,
                      sql_plan_hash_value,
                      sql_opname, $S1_
                      sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
                      sum(decode(session_state,'ON CPU',wait_time))/1000000     "CPU",
                      (sum(decode(session_state,'WAITING',time_waited))  -  sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0))) )/1000000    "WAIT" ,
                      sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0)))/1000000    "IO" ,
                      round(100*count(*)/ sum(count(1)) over(), 2) activity
            from      dba_hist_active_sess_history
  where sample_time $INTERVAL_  $S2_
            group by  plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
                      sql_id,
                      sql_plan_hash_value,
                      sql_opname $S3_ ) x
  where     e.object_id (+) = x.plsql_entry_object_id
  and       e.subprogram_id (+) = x.plsql_entry_subprogram_id
  and       p.object_id (+) = x.plsql_object_id
  and       p.subprogram_id (+) = x.plsql_subprogram_id
  order by  x.activity desc)
  where rownum<31 ;
EOF
 ;;
 *)
 SQL_ID_=$(awk '{print $2}' <<< "$*")
 SQL_TEXT_=$(shift; tr '[:lower:]' '[:upper:]' <<< "$*")
 if [ -z "$SQL_ID_" ]; then
  $SP <<EOF >$LOGF
  PROMPT "Top 10 SQL from DBA_HIST_ACTIVE_SESS_HISTORY where sample_time $INTERVAL_"
  $SET_COL
  select /*+ LEADING(H_TXT) */ s.*, h_txt.sql_text from (
  select * from (
  select ash.SQL_ID , ash.SQL_PLAN_HASH_VALUE Plan_hash, aud.name type,
  sum(decode(ash.session_state, 'ON CPU', ash.wait_time, ash.time_waited))/1000000 time_waited,
  sum(decode(ash.session_state,'ON CPU',ash.wait_time))/1000000     "CPU",
  (sum(decode(ash.session_state,'WAITING',time_waited))  -  sum(decode(ash.session_state,'WAITING', decode(ash.wait_class, 'User I/O',ash.time_waited,0))) )/1000000    "WAIT" ,
  sum(decode(ash.session_state,'WAITING', decode(ash.wait_class, 'User I/O',ash.time_waited,0)))/1000000    "IO" ,
  round(100*count(*)/ sum(count(1)) over(), 2) activity
  from dba_hist_active_sess_history ash,
     audit_actions aud
  where ash.SQL_ID is not NULL
   and ash.sql_opcode=aud.action
    and sample_time $INTERVAL_
     and dbid=(select dbid from v\$database)
  group by ash.sql_id, SQL_PLAN_HASH_VALUE   , aud.name
  order by activity  desc
  ) where rownum < 11) s, DBA_HIST_SQLTEXT h_txt where s.sql_id=h_txt.sql_id;
EOF
else
  LEN_=$(expr length $SQL_ID_)
  SQL_ID__=$(tr -d '[:digit:][:lower:]' <<< "$SQL_ID_")
if [ -z "$SQL_ID__" -a $LEN_ -eq 13 ] ; then
# SQL_="select sql_id,sql_text from DBA_HIST_SQLTEXT where dbid=(select dbid from v\$database) and sql_id='$SQL_ID_';"
 SQL_="select cast(h.sample_time as date) sample_time, s.sql_id, sql_plan_hash_value, s.sql_text from DBA_HIST_SQLTEXT s, dba_hist_active_sess_history h where s.sql_id=h.sql_id and s.dbid=(select dbid from v\$database) and s.sql_id = '$SQL_ID_' and sample_time $INTERVAL_ and rownum<21 order by sample_time;"
 PROMPT_="20 SQL_ID = $SQL_ID_"
else
# SQL_="select sql_id,sql_text from DBA_HIST_SQLTEXT where dbid=(select dbid from v\$database) and upper(sql_text) like '%$SQL_TEXT_%';"
 SQL_="select cast(h.sample_time as date) sample_time, s.sql_id, sql_plan_hash_value, s.sql_text from DBA_HIST_SQLTEXT s, dba_hist_active_sess_history h where s.sql_id=h.sql_id and s.dbid=(select dbid from v\$database) and upper(s.sql_text) like '%$SQL_TEXT_%' and sample_time $INTERVAL_ and rownum<21 order by sample_time;"
 PROMPT_="20 SQL_TEXT like $SQL_TEXT_"
fi
  $SP <<EOF >$LOGF
  PROMPT "SQL from DBA_HIST_SQLTEXT by $PROMPT_ where sample_time $INTERVAL_"
  $SET_COL
  column sample_time for a10 heading "sample_time"
  $SQL_
EOF
fi
;;
esac
;;
plan)
  SQL_ID_=$(awk '{print $2}' <<< "$*")
  PHV_=$(echo $* | awk '{print $3}' <<< "$*")
  if [ "$PHV_" = "%" ]; then PHV_=''; fi
  shift
  shift
  shift
  FMT_="$*"
  echo "FMT_: "$FMT_
  $SP <<EOF >$LOGF
  PROMPT "Avilable SNAP_ID from  WRM\$_SNAPSHOT_DETAILS and dba_hist_active_sess_history where begin_time $INTERVAL_ for sql_id: $SQL_ID_ :"
  set lines 250 pages 90 feedback off
  col SQL_EXEC_START for a15
  select to_char(SQL_EXEC_START,'dd/mm/yyyy') SQL_EXEC_START,sql_id,sql_plan_hash_value,min(snap_id),max(snap_id) from dba_hist_active_sess_history 
  where dbid=(select dbid from v\$database) and snap_id > (select min(snap_id) from WRM\$_SNAPSHOT_DETAILS where begin_time $INTERVAL_ )
  and sql_id='$SQL_ID_' and sql_plan_hash_value like '%$PHV_%'
  and sql_exec_start $INTERVAL_
  group by to_char(SQL_EXEC_START,'dd/mm/yyyy'),sql_id,sql_plan_hash_value order by  min(snap_id);

  PROMPT
  PROMPT "Plans from DBA_HIST_SQL_PLAN (dbms_xplan.display_awr) for sql_id: $SQL_ID_ "
  BREAK ON timestamp ON sql_id ON plan_hash_value SKIP 1 NODUPLICATES
  column timestamp for a20 wrap
  column id for 99
  column OBJECT_OWNER for a15
  column operation for a20
  column options for a30
  column OBJECT_NAME for a30
  column OBJECT_TYPE for a20
  column cost for 9999999
  column plan_hash_value for 9999999999
  select unique p.timestamp,p.sql_id,p.plan_hash_value, s.snap_id from DBA_HIST_SQL_PLAN p, DBA_HIST_SNAPSHOT s
  where p.sql_id = '$SQL_ID_' and p.plan_hash_value like '%$PHV_%' and begin_interval_time $INTERVAL_ and p.timestamp between s.begin_interval_time and s.end_interval_time order by p.timestamp;

  set pages 0
  --select * from table(dbms_xplan.display_awr('$SQL_ID_','',format => '-predicate +outline'));
  select * from table(dbms_xplan.display_awr(sql_id=>'$SQL_ID_',plan_hash_value=>'$PHV_',format=>nvl('$FMT_', 'typical +outline last')));
EOF
;;
sqlstat)
 SQL_ID_=$(awk '{print $2}' <<< "$*")
 P2_=$(awk '{print $3}' <<< "$*")
 if [ -n "$SQL_ID_" ]; then LEN_=$(expr length $SQL_ID_); fi
 SQL_SQLSTAT="
 set lines 250 pages 80 feedback off
 column snap_id for 999999
 column end_interval_time for a17 heading 'END_TIME'
 column sql_id for a13
 column plan_hash_value for 9999999999 heading 'PLAN_HASH_V'
 column optimizer_cost for 99999999 heading 'COST'
 column module for a32 truncate
 column parsing_schema_name for a20 heading 'SCHEMA'
 column fetches_delta for 999,999 heading 'FCH\EX'
 column sorts_delta for 999,999 heading 'SORT\EX'
 column executions_delta for 999,999,999 heading 'EXEC'
 column pio_per_exec for 999,999,999 heading 'PIO\EX'
 column lio_per_exec for 99,999,999,999 heading 'LIO\EX'
 column rows_processed_delta for 99,999,999 heading 'ROWS_PR\EX'
 column cpu_time_delta for 99,999.9999 heading 'CPU_TIME\EX'
 column elapsed_time_delta for 99,999.9999 heading 'ELA_TIME\EX'
 column iowait_delta for 999,999 heading 'IOWAIT\EX'
"
case "$LEN_" in 
 13)
 $SP <<EOF >$LOGF
 PROMPT "SQLStats from dba_hist_sqlstat  for sql_id: $SQL_ID_ and begin_interval_time $INTERVAL_"
 $SQL_SQLSTAT
 select hs.snap_id,to_char(hs.end_interval_time,'dd/mm/yy hh24:mi:ss') end_interval_time, sql_id,plan_hash_value,optimizer_cost,module, parsing_schema_name,
 trunc(fetches_delta / decode(executions_delta, 0, 1, executions_delta)) fetches_delta,
 trunc(sorts_delta / decode(executions_delta, 0, 1, executions_delta)) sorts_delta,
 executions_delta,
 trunc(DISK_READS_DELTA / decode(executions_delta, 0, 1, executions_delta)) PIO_PER_EXEC,
 (buffer_gets_delta / decode(nvl(executions_delta, 0), 0, 1, executions_delta)) LIO_PER_EXEC,
 trunc(rows_processed_delta / decode(executions_delta, 0, 1, executions_delta)) rows_processed_delta,
 decode(EXECUTIONS_delta, 0, cpu_time_delta/1000000, round(cpu_time_delta/EXECUTIONS_delta/1000000, 4)) cpu_time_delta,
 (elapsed_time_delta / decode(nvl(executions_delta, 0), 0, 1, executions_delta)) / 1000000 elapsed_time_delta,
 decode(EXECUTIONS_delta, 0, iowait_delta/1000000, round(iowait_delta/EXECUTIONS_delta/1000000, 4)) iowait_delta
 from dba_hist_sqlstat st, dba_hist_snapshot hs
 where st.snap_id=hs.snap_id and sql_id = '$SQL_ID_' and st.instance_number = hs.instance_number and
 hs.snap_id in (select snap_id from DBA_HIST_SNAPSHOT where begin_interval_time $INTERVAL_ )
 and hs.dbid = (select dbid from v\$database)
 and executions_delta > 0
 order by snap_id, end_interval_time;
EOF
;;
 *)
 case "$SQL_ID_" in
   pio*) S1_="PIO_PER_EXEC * executions_delta desc" ;;
   lio*) S1_="LIO_PER_EXEC * executions_delta desc" ;;
   cpu*) S1_="cpu_time_delta * executions_delta desc" ;;
   exe*) S1_="executions_delta desc" ;;
   ela*) S1_="elapsed_time_delta * executions_delta desc" ;;
   fch*) S1_="fetches_delta * executions_delta desc" ;;
   sor*|srt*) S1_="sorts_delta * executions_delta desc" ;;
   iow*) S1_="iowait_delta * executions_delta desc" ;;
   row*) S1_="rows_processed_delta * executions_delta desc" ;;
      *) S1_="PIO_PER_EXEC * executions_delta desc" ;;
 esac
 if [ -z "$P2_" ]; then P2_=1; fi
 $SP <<EOF >$LOGF
 PROMPT "TOP 40 SQLStats from dba_hist_sqlstat where begin_interval_time $INTERVAL_ order by $S1_ "
 $SQL_SQLSTAT
 select * from (
 select hs.snap_id,to_char(hs.end_interval_time,'dd/mm/yy hh24:mi:ss') end_interval_time, sql_id,plan_hash_value,
 trunc(fetches_delta / decode(executions_delta, 0, 1, executions_delta)) fetches_delta,
 trunc(sorts_delta / decode(executions_delta, 0, 1, executions_delta)) sorts_delta,
 executions_delta,
 trunc(DISK_READS_DELTA / decode(executions_delta, 0, 1, executions_delta)) PIO_PER_EXEC,
 (buffer_gets_delta / decode(nvl(executions_delta, 0), 0, 1, executions_delta)) LIO_PER_EXEC,
 trunc(rows_processed_delta / decode(executions_delta, 0, 1, executions_delta)) rows_processed_delta,
 decode(EXECUTIONS_delta, 0, cpu_time_delta/1000000, round(cpu_time_delta/EXECUTIONS_delta/1000000, 4)) cpu_time_delta,
 (elapsed_time_delta / decode(nvl(executions_delta, 0), 0, 1, executions_delta)) / 1000000 elapsed_time_delta,
 decode(EXECUTIONS_delta, 0, iowait_delta/1000000, round(iowait_delta/EXECUTIONS_delta/1000000, 4)) iowait_delta
 from dba_hist_sqlstat st, dba_hist_snapshot hs
 where st.snap_id=hs.snap_id and st.instance_number = hs.instance_number and
 hs.snap_id in (select snap_id from DBA_HIST_SNAPSHOT where begin_interval_time $INTERVAL_ )
 and hs.dbid = (select dbid from v\$database)
 and executions_delta >= $P2_
 order by $S1_ 
 ) where rownum <= 40;
EOF
;;
esac
;;
growseg)
 TBS=$(awk '{print $2}' <<< "$*")
 SEG=$(awk '{print $3}' <<< "$*")
 if [ -z "$SEG" ]; then
   $SP <<EOF >$LOGF
   PROMPT "DBA_HIST_SEG_STAT: Most segments growth in begin_interval_time $INTERVAL_"
   set lines 250 pages 80
   column owner for a20
   column TABLESPACE for a20
   column OBJECT_NAME for a30
   column SUBOBJECT_NAME for a46
   column OBJECT_TYPE for a18
   column TABLESPACE for a22
   BREAK ON REPORT
   COMPUTE SUM LABEL 'SUM' OF "Growth in MB" on report
   COMPUTE SUM LABEL 'SUM' OF "Total Size(GB)" on report
   select * from (SELECT o.OWNER , o.OBJECT_NAME , o.SUBOBJECT_NAME , o.OBJECT_TYPE ,
    t.NAME "Tablespace", round(s.growth/(1024*1024),2) "Growth in MB",
    (SELECT round(sum(bytes)/(1024*1024*1024),2)
    FROM dba_segments
    WHERE segment_name=o.object_name) "Total Size(GB)"
   FROM DBA_OBJECTS o,
    ( SELECT TS#,OBJ#,
        SUM(SPACE_ALLOCATED_DELTA) growth
    FROM DBA_HIST_SEG_STAT where snap_id in (select snap_id from DBA_HIST_SNAPSHOT where begin_interval_time $INTERVAL_ )
    GROUP BY TS#,OBJ#
    HAVING SUM(SPACE_ALLOCATED_DELTA) > 0
    ORDER BY 2 DESC ) s,
    v\$tablespace t 
   WHERE s.OBJ# = o.OBJECT_ID
   AND s.TS# = t.TS# and t.name like nvl(trim('$TBS'),'%')
   ORDER BY 6 DESC) where rownum<=6000;
EOF
 else
   $SP <<EOF >$LOGF
   PROMPT "DBA_HIST_SEG_STAT: $SEG segment growth in begin_interval_time $INTERVAL_"
   set lines 250 pages 80
   column owner for a20
   column SEGMENT_NAME for a30
   column TABLESPACE for a20
   column SUBOBJECT_NAME for a46
   column end_interval_time for a13 heading "end_interval_time"
   column space_used_delta for 999999999 heading "Space grows (MB)"
   column usage for 9999990.99 heading "% of Grows"
   BREAK ON REPORT
   COMPUTE SUM LABEL 'SUM' OF space_used_delta on report
   select * from (select to_char(end_interval_time, 'DD/MM/YYYY HH24') end_interval_time, c.owner, c.segment_name, b.SUBOBJECT_NAME, c.tablespace_name,
   round(sum(space_used_delta) / 1024 / 1024, 2) space_used_delta,
   trunc(sum(c.bytes) / 1024 / 1024) "Total Object Size (MB)",
   round((sum(space_used_delta) / sum(c.bytes)) * 100, 2) usage
   from dba_hist_snapshot sn, dba_hist_seg_stat a, dba_objects b, dba_segments c
   where begin_interval_time $INTERVAL_
   and sn.snap_id = a.snap_id and b.object_id = a.obj# and b.owner = c.owner and b.object_name = c.segment_name
   and c.segment_name = '$SEG' and c.tablespace_name like nvl(trim('$TBS'),'%')
   group by to_char(end_interval_time, 'DD/MM/YYYY HH24'), c.owner, c.segment_name, b.SUBOBJECT_NAME, c.tablespace_name
   having sum(space_used_delta) > 0 )
   order by owner, segment_name, to_date(end_interval_time, 'DD/MM/YYYY HH24');
EOF
 fi
;;
segstat)
  OBJ_=$(awk '{print $2}' <<< "$*")
  OWN_=$(awk '{print $3}' <<< "$*")
  [[ -n "$4" ]] && ORDERBY_="$4 desc, "
  $SP <<EOF >$LOGF
  PROMPT "Segment statistics for OBJECTS with max BLOCK_CHANGED from AWR in begin_interval_time $INTERVAL_ for SEGMENT: $OBJ_ OWNER: $OWN_ 
  $SET_COL
  set lines 230 pages 90 numw 9
  col owner for a20
  col SNAP_TIME for a15 heading "1|BEGIN_TIME"
  col LogRe_Bl for 999999999 heading "5|LogRe_Bl"
  col BufBusWa for 999999999 heading "6|BufBusWa"
  col DbBlCh_Bl for 999999999 heading "7|DbBlCh_Bl"
  col PhRe_Bl for 99999999 heading "8|PhRe_Bl"
  col PhWr_Bl for 99999999 heading "9|PhWr_Bl"
  col PhReDirBl for 99999999 heading "10|PhReDirBl"
  col PhWrDirBl for 99999999 heading "11|PhWrDirBl"
  col ITL_W for 99999999 heading "12|ITL_W"
  col RowLckWa for 99999999 heading "13|RowLckWa"
  col SpAlloMb for 999999999 heading "14|SpAlloMb"
  col SpAlloTMb for 999999999 heading "15|SpAlloTMb"
  BREAK ON REPORT
  COMPUTE SUM LABEL 'SUM' OF block_changed on report
  SELECT   TO_CHAR(begin_interval_time, 'dd/mm/yy-hh24:mi') snap_time,
           dhso.owner, dhso.object_name, dhso.object_type,
           SUM(LOGICAL_READS_DELTA) "LogRe_Bl",
           SUM(BUFFER_BUSY_WAITS_DELTA) "BufBusWa",
           SUM(DB_BLOCK_CHANGES_DELTA) "DbBlCh_Bl",
           SUM(PHYSICAL_READS_DELTA) "PhRe_Bl",
           SUM(PHYSICAL_WRITES_DELTA) "PhWr_Bl",
           SUM(PHYSICAL_READS_DIRECT_DELTA) "PhReDirBl",
           SUM(PHYSICAL_WRITES_DIRECT_DELTA) "PhWrDirBl",
           SUM(ITL_WAITS_DELTA) ITL_W,
           SUM(ROW_LOCK_WAITS_DELTA) "RowLckWa",
           SUM(SPACE_ALLOCATED_DELTA)/1024/1024 "SpAlloMb",
           SUM(Space_Allocated_Total)/1024/1024 "SpAlloTMb"
   FROM   dba_hist_seg_stat dhss,
           dba_hist_seg_stat_obj dhso,
           dba_hist_snapshot dhs
   WHERE       dhs.snap_id = dhss.snap_id
           AND dhs.instance_number = dhss.instance_number
           AND dhss.obj# = dhso.obj#
           AND dhss.dataobj# = dhso.dataobj#
	   AND begin_interval_time $INTERVAL_
	   and object_name like nvl(trim('$OBJ_'),'%')
	   and owner like nvl(trim('$OWN_'),'%')
  GROUP BY  begin_interval_time, dhso.owner, dhso.object_name, dhso.object_type
  --  HAVING   SUM (LOGICAL_READS_DELTA) > nvl(trim('$SIZE_'), 0)
  ORDER BY  $ORDERBY_  snap_time;
EOF
;;
mchart) awr_mchart dba_hist_active_sess_history
;;
cchart) awr_cchart dba_hist_active_sess_history
;;
tchart) awr_tchart dba_hist_active_sess_history
;;
temp)
  P1_=$(awk '{print $2}' <<< "$*")
  awr_tempusage dba_hist_active_sess_history $P1_
;;
iostat)
P2_=$(awk '{print $2}' <<< "$*")
case "$P2_" in
  df)        filetype_name='Data File' ;;
  ctl)       filetype_name='Control File' ;;
  arch)      filetype_name='Archive Log' ;;
  log|redo)  filetype_name='Log File' ;;
  other)     filetype_name='Other' ;;
  temp)      filetype_name='Temp File' ;;
     *)      filetype_name='Data File' ; P2_="df" ;;
esac
$SP <<EOF >$LOGF
prompt  dba_hist_iostat_filetype param 'Archive Log' 'Control File' 'Data File' 'Log File'  'Other' 'Temp File' for  $filetype_name
set lines 230 pages 190 numw 9 tab off
col begin_time for a17 heading "1|BEGIN_TIME"
col filetype_name for a17 noprint
col TRE_MBS for 999990D99 heading "2|TRE_MBS"
col TRE_IOPS for 999990D99 heading "3|TRE_IOPS"
col TWR_MBS for 999990D99 heading "4|TWR_MBS"
col TWR_IOPS for 999990D99 heading "5|TWR_IOPS"
col SRE_MBS for 999990D99 heading "6|SRE_MBS"
col SRE_IOPS for 999990D99 heading "7|SRE_IOPS"
col SWR_MBS for 999990D99 heading "8|SWR_MBS"
col SWR_IOPS for 999990D99 heading "9|SWR_IOPS"
col SMRE_LAT for 999990D99 heading "10|SMRE_LAT"
col SMWR_LAT for 999990D99 heading "11|SMWR_LAT"
col LARE_LAT for 999990D99 heading "12|LARE_LAT"
col LAWR_LAT for 999990D99 heading "13|LAWR_LAT"
select * from  
(
select
--   id, 
  TO_CHAR(begin_interval_time,'DD/MM/YY-HH24:MI') begin_time
--  , inst
--  , round(((CAST(end_interval_time AS DATE) - CAST(begin_interval_time AS DATE)) * 86400)/60,2) dur
  , filetype_name
  , round(read_mbs/round(((CAST(end_interval_time AS DATE)    - CAST(begin_interval_time AS DATE)) * 86400),2),2) tre_mbs
  , round(read_iops/round(((CAST(end_interval_time AS DATE)   - CAST(begin_interval_time AS DATE)) * 86400),2),2) tre_iops
  , round(write_mbs/round(((CAST(end_interval_time AS DATE)   - CAST(begin_interval_time AS DATE)) * 86400),2),2) twr_mbs
  , round(write_iops/round(((CAST(end_interval_time AS DATE)  - CAST(begin_interval_time AS DATE)) * 86400),2),2) twr_iops
  , round(sread_mbs/round(((CAST(end_interval_time AS DATE)   - CAST(begin_interval_time AS DATE)) * 86400),2),2) sre_mbs
  , round(sread_iops/round(((CAST(end_interval_time AS DATE)  - CAST(begin_interval_time AS DATE)) * 86400),2),2) sre_iops
  , round(swrite_mbs/round(((CAST(end_interval_time AS DATE)  - CAST(begin_interval_time AS DATE)) * 86400),2),2) swr_mbs
  , round(swrite_iops/round(((CAST(end_interval_time AS DATE) - CAST(begin_interval_time AS DATE)) * 86400),2),2) swr_iops
  , nvl(round(srst/decode(sread_iops,0,to_number(null),sread_iops),2),0)                          smre_lat  --small_read_servicetime/small_read_reqs
  , nvl(round(swst/decode(swrite_iops,0,to_number(null),swrite_iops),2),0)                        smwr_lat
  , nvl(round(lrst/decode(read_iops-sread_iops,0,to_number(null),read_iops-sread_iops),2),0)      lare_lat  --large_read_servicetime/large_read_reqs
  , nvl(round(lwst/decode(write_iops-swrite_iops,0,to_number(null),write_iops-swrite_iops),2),0)  lawr_lat
from 
(
  select  s0.snap_id id
          , s1.begin_interval_time
          , s1.end_interval_time
          , s0.instance_number inst
          , e.filetype_name
          , sum(((e.small_read_megabytes   - b.small_read_megabytes)  + (e.large_read_megabytes  - b.large_read_megabytes)))   read_mbs          
          , sum(((e.small_read_reqs        - b.small_read_reqs)       + (e.large_read_reqs       - b.large_read_reqs)))        read_iops 
          , sum(((e.small_write_megabytes  - b.small_write_megabytes) + (e.large_write_megabytes - b.large_write_megabytes)))  write_mbs 
          , sum(((e.small_write_reqs       - b.small_write_reqs)      + (e.large_write_reqs      - b.large_write_reqs)))       write_iops            
          , sum(e.small_read_megabytes     - b.small_read_megabytes)    sread_mbs  
          , sum(e.small_read_reqs          - b.small_read_reqs)         sread_iops
          , sum(e.small_write_megabytes    - b.small_write_megabytes)   swrite_mbs
          , sum(e.small_write_reqs         - b.small_write_reqs)        swrite_iops
          , sum((e.small_read_servicetime  - b.small_read_servicetime))   srst
          , sum((e.small_write_servicetime - b.small_write_servicetime))  swst
          , sum((e.large_read_servicetime  - b.large_read_servicetime))   lrst
          , sum((e.large_write_servicetime - b.large_write_servicetime))  lwst
       from dba_hist_snapshot s0
            , dba_hist_snapshot s1
            , dba_hist_iostat_filetype b
            , dba_hist_iostat_filetype e
      where 
         s0.dbid                  = (select dbid from v\$database)
         and S1.BEGIN_INTERVAL_TIME $INTERVAL_
         and s1.dbid              = s0.dbid
         and b.dbid               = s0.dbid
         and e.dbid               = s0.dbid
         and s1.instance_number   = s0.instance_number
         and b.instance_number    = s0.instance_number
         and e.instance_number    = s0.instance_number
         and s1.snap_id           = s0.snap_id + 1
         and b.snap_id            = s0.snap_id
         and e.snap_id            = s0.snap_id + 1
         and e.filetype_id     = b.filetype_id
         and e.filetype_name   = b.filetype_name
       group by s0.snap_id, s1.begin_interval_time, s1.end_interval_time, s0.instance_number, e.filetype_name
       order by s0.snap_id asc 
)
where read_mbs + read_iops + write_mbs + write_iops > 0
and filetype_name='$filetype_name'
) order by filetype_name, begin_time;
EOF
;;
awrinfo)
$SP <<EOF >$LOGF
prompt  dba_hist_sys_time_model 
set lines 230 pages 190 numw 9 tab off null 0
col begin_time for a17 heading "1|BEGIN_TIME"
col instance_number for 999 noprint
col AAS for 99999 heading "2|AAS" 
col DBTIMEM for 99999 heading "3|DBTIMEM" 
col DBCPUM for 99999 heading "4|DBCPUM" 
col LOAD for 99999 heading "5|LOAD"
col LOADW for 99999 heading "6|LOADW"
col LIOPSEC for 9999999 heading "7|LIOPSEC"
col REDO_GB for 9999 heading "8|REDO_GB"
col DBBLC for 9999999999 heading "9|DBBLC^3"
col PGAMB for 99999 heading "10|PGAMB"
col READLAT for 9999.00 heading "11|READLAT"
col LFPWLAT for 9999.00 heading "12|LFPWLAT"
col LFSYLAT for 9999.00 heading "13|LFSYLAT"
col PHYREMBT for 9999999 heading "14|PHYREMBT"
col PHYWRMBT for 9999999 heading "15|PHYWRMBT"
col PHREMBPS for 999999 heading "16|PREMBPS"
col PHWRMBPS for 999999 heading "17|PWRMBPS"
col PHREIOPS for 999999 heading "18|PREIOPS"
col PHWRIOPS for 999999 heading "19|PWRIOPS"
col ENQTXMS for 99999999 heading "20|ENQTXMS"
col ENQTMMS for 9999999 heading "21|ENQTMMS"
col TRANMIN for 999999 heading "22|TRANMIN"
col ROLLMIN for 999999 heading "23|ROLLMIN"
with 
AAS as (
SELECT CAST(begin_interval_time AS date) begin_time, instance_number, ROUND (AVG (v_ps)) aas
    FROM (SELECT begin_interval_time, instance_number, v / ela v_ps
              FROM (SELECT sn.begin_interval_time, sn.instance_number,
                             (CASE WHEN sn.begin_interval_time = sn.startup_time THEN VALUE
                                  ELSE VALUE - LAG (VALUE,1) OVER (PARTITION BY sy.stat_id,sy.dbid,sn.instance_number,sn.startup_time ORDER BY sy.snap_id)
                              END) / 1000000 v,
                               (CAST (sn.end_interval_time AS date) - CAST (sn.begin_interval_time AS date)) * 24 * 3600 ela
                     FROM   dba_hist_snapshot sn, dba_hist_sys_time_model sy
                     WHERE       sn.dbid = sy.dbid
                             AND sn.instance_number = sy.instance_number
                             AND sn.snap_id = sy.snap_id
                             AND sy.stat_name = 'DB time'
                             AND sn.end_interval_time $INTERVAL_
                             AND sn.instance_number = 1))
GROUP BY   begin_interval_time, instance_number
),
DBTM as (
SELECT CAST (sn.begin_interval_time AS date) begin_time, a.instance_number, ROUND ( (a.VALUE - LAG(a.VALUE) OVER ( PARTITION BY a.instance_number, a.stat_name ORDER BY a.snap_id)) / 1000000 / 60, 2) as DBtimeM
              FROM  dba_hist_sys_time_model a, dba_hist_snapshot sn
             WHERE      a.snap_id = sn.snap_id
                    AND a.instance_number = sn.instance_number
                    AND a.stat_name = 'DB time'
                    AND sn.end_interval_time $INTERVAL_
),
DBCPU as (
SELECT CAST (sn.begin_interval_time AS date) begin_time, a.instance_number, ROUND ( (a.VALUE - LAG(a.VALUE) OVER ( PARTITION BY a.instance_number, a.stat_name ORDER BY a.snap_id)) / 1000000 / 60, 2) as DBCPUM
              FROM  dba_hist_sys_time_model a, dba_hist_snapshot sn
             WHERE      a.snap_id = sn.snap_id
                    AND a.instance_number = sn.instance_number
                    AND a.stat_name = 'DB CPU'
                    AND sn.end_interval_time $INTERVAL_
),
LOAD as (
select cast (sn.begin_interval_time as date) begin_time, os.instance_number, round(os.value,2) load
 from dba_hist_snapshot sn, dba_hist_osstat os
 where sn.dbid = os.dbid
 and sn.instance_number = os.instance_number
 and sn.snap_id = os.snap_id
 and os.stat_name = 'LOAD'
 and sn.end_interval_time $INTERVAL_
),
LOADW as (
select t1.begin_time, t1.instance_number ,round(t1.busy_time / (t1.NUM_CPUS * 60 * 60), 2) load
  from (select cast(sn.begin_interval_time as date) begin_time        
              ,sn.instance_number          
              ,avg(case
                     when os.stat_name = 'NUM_CPUS' then
                      to_number(os.value)
                     else
                      null
                   end) NUM_CPUS
              ,case when sum(case when os1.stat_name = 'BUSY_TIME' then to_number(os1.value) else null end ) 
                  > sum(case when os.stat_name = 'BUSY_TIME' then to_number(os.value) else null end )
                 then sum(case when os.stat_name = 'BUSY_TIME' then to_number(os.value) else null end )
                 else sum(case when os.stat_name = 'BUSY_TIME' then to_number(os.value) else null end ) 
                    - sum(case when os1.stat_name = 'BUSY_TIME' then to_number(os1.value) else null end)
               end BUSY_TIME
          from dba_hist_snapshot sn
              ,dba_hist_osstat   os
              ,dba_hist_osstat   os1          
         where sn.dbid = os.dbid          
           and sn.instance_number = os.instance_number          
           and sn.instance_number = os1.instance_number          
           and sn.snap_id = os.snap_id          
           and sn.snap_id - 1 = os1.snap_id          
           and os.stat_name in ('USER_TIME', 'SYS_TIME', 'BUSY_TIME', 'IDLE_TIME', 'NUM_CPUS')          
           and os1.stat_name in ('USER_TIME', 'SYS_TIME', 'BUSY_TIME', 'IDLE_TIME', 'NUM_CPUS')          
           and sn.end_interval_time $INTERVAL_
         group by cast(sn.begin_interval_time as date), sn.instance_number ) t1
),
LIO as (
select cast(begin_interval_time as date) begin_time,instance_number, trunc(avg(pSec)) perSec
  from (select begin_interval_time,instance_number,greatest(v / ela, 0) pSec
          from (select /*+ leading(sn,stn,sy) */ sn.snap_id,sn.instance_number,sn.dbid,sn.begin_interval_time
                ,case when sn.begin_interval_time = sn.startup_time then sy.value
                      else sy.value - lag(sy.value, 1) over(partition by sy.stat_id, sy.instance_number, sy.dbid,sn.startup_time order by sy.snap_id)
                 end v
                ,(cast(end_interval_time as date) - cast(begin_interval_time as date)) * 24 * 3600 ela
                  from dba_hist_snapshot  sn
                      ,dba_hist_sysstat   sy
                      ,dba_hist_stat_name stn
                 where sn.dbid = sy.dbid
                   and sn.instance_number = sy.instance_number
                   and sn.snap_id = sy.snap_id
                   and sn.dbid = stn.dbid
                   and sy.stat_id = stn.stat_id
                   and sn.end_interval_time $INTERVAL_
                   and stn.stat_name = 'session logical reads'))
 group by begin_interval_time,instance_number
),
REDO as (
SELECT cast(sn.begin_interval_time as date) begin_time, st1.instance_number, round((st1.value-lag(st1.value,1) over (partition by st1.instance_number order by sn.begin_interval_time))/1024/1024/1024) redo_gb
FROM  dba_hist_snapshot sn,DBA_HIST_SYSSTAT st1
where sn.snap_id=st1.snap_id
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.stat_name ='redo size'
and sn.end_interval_time $INTERVAL_
),
DBBLC as (
SELECT cast(sn.begin_interval_time as date) begin_time, st1.instance_number,
round((st1.value-lag(st1.value,1) over (partition by st1.instance_number order by sn.begin_interval_time))) DBBLC
FROM 
dba_hist_snapshot sn,DBA_HIST_SYSSTAT st1
where sn.snap_id=st1.snap_id
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.stat_name ='db block changes'
and sn.end_interval_time $INTERVAL_
),
PGA as (
select cast(sn.begin_interval_time as date) begin_time, g.instance_number, round(g.value/1048576,2) PGAmb
from dba_hist_snapshot sn, dba_hist_pgastat g
where sn.snap_id = g.snap_id
and sn.instance_number = g.instance_number
and sn.dbid = g.dbid
and g.name = 'total PGA allocated'
and sn.end_interval_time $INTERVAL_
),
READLAT as (
--read latency ms
select  cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER,
round( (st1.time_waited_micro -lead(st1.time_waited_micro,1) over (partition by st1.INSTANCE_NUMBER, st1.event_name order by st1.snap_id) )  /
(st1.total_waits -lead(st1.total_waits,1) over (partition by st1.INSTANCE_NUMBER, st1.event_name order by st1.snap_id) ) /1000,2 ) as READLAT
from  DBA_HIST_SYSTEM_EVENT st1,dba_hist_snapshot sn
where sn.snap_id=st1.snap_id  
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.event_name  = 'db file sequential read'
and sn.end_interval_time $INTERVAL_
),
LFPWLAT as (
-- log file parallel write latency ms
select  cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER,
round( (st1.time_waited_micro -lead(st1.time_waited_micro,1) over (partition by st1.INSTANCE_NUMBER, st1.event_name order by st1.snap_id) )  /
(st1.total_waits -lead(st1.total_waits,1) over (partition by st1.INSTANCE_NUMBER, st1.event_name order by st1.snap_id) ) /1000,2) as LFPWLAT
from  DBA_HIST_SYSTEM_EVENT st1,dba_hist_snapshot sn
where sn.snap_id=st1.snap_id  
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.event_name = 'log file parallel write'
and sn.end_interval_time $INTERVAL_
),
LFSYLAT as (
--log file sync latency ms
select  cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER,
round( (st1.time_waited_micro -lead(st1.time_waited_micro,1) over (partition by st1.INSTANCE_NUMBER, st1.event_name order by st1.snap_id) )  /
(st1.total_waits -lead(st1.total_waits,1) over (partition by st1.INSTANCE_NUMBER, st1.event_name order by st1.snap_id) ) /1000,2 ) as LFSYLAT
from  DBA_HIST_SYSTEM_EVENT st1,dba_hist_snapshot sn
where sn.snap_id=st1.snap_id  
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.event_name = 'log file sync'
and sn.end_interval_time $INTERVAL_
),
PHYRE as (
SELECT cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER, 
trunc((st1.value-lag(st1.value,1) over (partition by st1.INSTANCE_NUMBER, st1.stat_name order by sn.end_interval_time))/1024/1024,2) as PHYREMBT
FROM  dba_hist_snapshot sn,DBA_HIST_SYSSTAT st1
where  sn.snap_id=st1.snap_id
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.stat_name = 'physical read total bytes'
and sn.end_interval_time $INTERVAL_
),
PHYWR as (
SELECT cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER, 
trunc((st1.value-lag(st1.value,1) over (partition by st1.INSTANCE_NUMBER, st1.stat_name order by sn.end_interval_time))/1024/1024,2) as PHYWRMBT
FROM  dba_hist_snapshot sn,DBA_HIST_SYSSTAT st1
where  sn.snap_id=st1.snap_id
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.stat_name = 'physical write total bytes'
and sn.end_interval_time $INTERVAL_
),
PHREMbps as (
SELECT cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER,
round((st1.value-lag(st1.value,1) over (partition by st1.INSTANCE_NUMBER,st1.stat_name order by sn.end_interval_time))/1024/1024/EXTRACT(day FROM (end_interval_time - begin_interval_time)*24*60*60),2) PHREMbps
 FROM dba_hist_snapshot sn,DBA_HIST_SYSSTAT st1
where sn.snap_id=st1.snap_id
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.stat_name = 'physical read total bytes'
and sn.end_interval_time $INTERVAL_
),
PHWRMbps as (
SELECT cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER,
round((st1.value-lag(st1.value,1) over (partition by st1.INSTANCE_NUMBER,st1.stat_name order by sn.end_interval_time))/1024/1024/EXTRACT(day FROM (end_interval_time - begin_interval_time)*24*60*60),2) PHWRMbps
 FROM dba_hist_snapshot sn,DBA_HIST_SYSSTAT st1
where sn.snap_id=st1.snap_id
and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
and st1.stat_name = 'physical write total bytes'
and sn.end_interval_time $INTERVAL_
),
PHREIOPS as (
select cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER, round(average) PHREIOPS
 from dba_hist_sysmetric_summary st1,dba_hist_snapshot sn
where sn.snap_id=st1.snap_id
  and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
  and st1.metric_name = 'Physical Read Total IO Requests Per Sec'
  and sn.end_interval_time $INTERVAL_
),
PHWRIOPS as (
select cast(sn.begin_interval_time as date) begin_time, st1.INSTANCE_NUMBER, round(average) PHWRIOPS
 from dba_hist_sysmetric_summary st1,dba_hist_snapshot sn
where sn.snap_id=st1.snap_id
  and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
  and st1.metric_name = 'Physical Write Total IO Requests Per Sec'
  and sn.end_interval_time $INTERVAL_
),
ENQTXms as (
select cast(sn.begin_interval_time as date) begin_time,sn.INSTANCE_NUMBER,nvl(round((lead(st1.time_waited_micro, 1) over(partition by st1.INSTANCE_NUMBER, st1.event_name order by st1.snap_id) - st1.time_waited_micro) / 1000, 2), 0) as ENQTXms
  from dba_hist_snapshot sn
 right join v\$event_name en
    on en.name = 'enq: TX - row lock contention'
  left join DBA_HIST_SYSTEM_EVENT st1
    on sn.snap_id = st1.snap_id
   and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
   and en.name = st1.event_name
 where sn.end_interval_time $INTERVAL_
), 
ENQTMms as (
select cast(sn.begin_interval_time as date) begin_time,sn.INSTANCE_NUMBER,nvl(round((lead(st1.time_waited_micro, 1) over(partition by st1.INSTANCE_NUMBER, st1.event_name order by st1.snap_id) - st1.time_waited_micro) / 1000, 2), 0) as ENQTMms
  from dba_hist_snapshot sn
 right join v\$event_name en
    on en.name = 'enq: TM - contention'
  left join DBA_HIST_SYSTEM_EVENT st1
    on sn.snap_id = st1.snap_id
   and sn.INSTANCE_NUMBER = st1.INSTANCE_NUMBER
   and en.name = st1.event_name
 where sn.end_interval_time $INTERVAL_
),
TRAN as (
SELECT cast(sn.begin_interval_time as date) begin_time, A.INSTANCE_NUMBER,
round((a.VALUE - LAG(a.VALUE) OVER(partition by a.INSTANCE_NUMBER, a.STAT_NAME ORDER BY a.SNAP_ID)) / EXTRACT(day FROM (sn.end_interval_time - sn.begin_interval_time)*24*60), 1) TRANMIN
from dba_hist_sysstat  a, DBA_HIST_SNAPSHOT sn
WHERE A.SNAP_ID = sn.SNAP_ID AND A.INSTANCE_NUMBER = sn.INSTANCE_NUMBER
and a.STAT_NAME = 'user commits'
and sn.end_interval_time $INTERVAL_
),
ROLL as (
SELECT cast(sn.begin_interval_time as date) begin_time, A.INSTANCE_NUMBER,
round((a.VALUE - LAG(a.VALUE) OVER(partition by a.INSTANCE_NUMBER, a.STAT_NAME ORDER BY a.SNAP_ID)) / EXTRACT(day FROM (sn.end_interval_time - sn.begin_interval_time)*24*60), 1) ROLLMIN
from dba_hist_sysstat  a, DBA_HIST_SNAPSHOT sn
WHERE A.SNAP_ID = sn.SNAP_ID AND A.INSTANCE_NUMBER = sn.INSTANCE_NUMBER
and a.STAT_NAME = 'transaction rollbacks'
and sn.end_interval_time $INTERVAL_
)
select TO_CHAR(aas.begin_time,'DD/MM/YY-HH24:MI:SS') begin_time, aas.instance_number, nvl(aas.aas,0) aas, nvl(DBTM.DBtimeM,0) DBtimeM, nvl(DBCPU.DBCPUM,0) DBCPUM, nvl(LOAD.load,0) load, nvl(LOADW.load,0) loadw, nvl(LIO.perSec,0) LIOpSEC, nvl(redo.redo_gb,0) redo_gb, nvl(DBBLC.DBBLC/1000,0) DBBLC, nvl(PGA.PGAmb, 0) PGAmb,
nvl(READLAT.READLAT,0) READLAT, nvl(LFPWLAT.LFPWLAT,0) LFPWLAT, nvl(LFSYLAT.LFSYLAT,0) LFSYLAT, nvl(PHYRE.PHYREMBT,0) PHYREMBT, nvl(PHYWR.PHYWRMBT,0) PHYWRMBT, nvl(PHREMbps.PHREMbps,0) PHREMbps, nvl(PHWRMbps.PHWRMbps,0) PHWRMbps, nvl(PHREIOPS.PHREIOPS,0) PHREIOPS, nvl(PHWRIOPS.PHWRIOPS,0) PHWRIOPS, 
nvl(ENQTXms.ENQTXms,0) ENQTXms, nvl(ENQTMms.ENQTMms,0) ENQTMms, nvl(TRAN.TRANMIN,0) TRANMIN, nvl(ROLL.ROLLMIN,0) ROLLMIN
from AAS, DBTM, DBCPU, LOAD, LOADW, LIO, REDO, DBBLC, PGA, READLAT, LFPWLAT, LFSYLAT, PHYRE, PHYWR, PHREIOPS, PHWRIOPS, PHREMbps, PHWRMbps, ENQTXms, ENQTMms, TRAN, ROLL
where AAS.begin_time=DBTM.begin_time (+) and AAS.instance_number=DBTM.instance_number (+)
  and AAS.begin_time=DBCPU.begin_time (+) and AAS.instance_number=DBCPU.instance_number (+)
  and AAS.begin_time=LOAD.begin_time (+) and AAS.instance_number=LOAD.instance_number (+)
  and AAS.begin_time=LOADW.begin_time (+) and AAS.instance_number=LOADW.instance_number (+)
  and AAS.begin_time=LIO.begin_time (+) and AAS.instance_number=LIO.instance_number (+)
  and AAS.begin_time=REDO.begin_time (+) and AAS.instance_number=REDO.instance_number (+)
  and AAS.begin_time=DBBLC.begin_time (+) and AAS.instance_number=DBBLC.instance_number (+)
  and AAS.begin_time=PGA.begin_time (+) and AAS.instance_number=PGA.instance_number (+)
  and AAS.begin_time=READLAT.begin_time (+) and AAS.instance_number=READLAT.instance_number (+)
  and AAS.begin_time=LFPWLAT.begin_time (+) and AAS.instance_number=LFPWLAT.instance_number (+)
  and AAS.begin_time=LFSYLAT.begin_time (+) and AAS.instance_number=LFSYLAT.instance_number (+)
  and AAS.begin_time=PHYRE.begin_time (+) and AAS.instance_number=PHYRE.instance_number (+)
  and AAS.begin_time=PHYWR.begin_time (+) and AAS.instance_number=PHYWR.instance_number (+)
  and AAS.begin_time=PHREMbps.begin_time (+) and AAS.instance_number=PHREMbps.instance_number (+)
  and AAS.begin_time=PHWRMbps.begin_time (+) and AAS.instance_number=PHWRMbps.instance_number (+)
  and AAS.begin_time=PHREIOPS.begin_time (+) and AAS.instance_number=PHREIOPS.instance_number (+)
  and AAS.begin_time=PHWRIOPS.begin_time (+) and AAS.instance_number=PHWRIOPS.instance_number (+)
  and AAS.begin_time=ENQTXms.begin_time (+) and AAS.instance_number=ENQTXms.instance_number (+)
  and AAS.begin_time=ENQTMms.begin_time (+) and AAS.instance_number=ENQTMms.instance_number (+)
  and AAS.begin_time=TRAN.begin_time (+) and AAS.instance_number=TRAN.instance_number (+)
  and AAS.begin_time=ROLL.begin_time (+) and AAS.instance_number=ROLL.instance_number (+)
order by begin_time;
EOF
;;
*) echo "Nothing..." ;;
esac
fi
logf
}



ash()
{
case "$(db_version)" in
  8|9)  echo "Current Oracle Version doesn't have AWR..." ; exit ;;
   10)  MACHINE_="" ;;
    *)  MACHINE_="machine" ;;
esac

if [ -z "$*" ]; then
  $SP <<EOF >$LOGF
  set echo off
  set feedback off
  set lines 230
  col MIN_SAMPLE_TIME for a25
  col MAX_SAMPLE_TIME for a25
  PROMPT
  PROMPT "Avilable period at V\$ACTIVE_SESSION_HISTORY:"
  select to_char(min(sample_time),'dd/mm/yyyy hh24:mi:ss') min_sample_time, to_char(max(sample_time),'dd/mm/yyyy hh24:mi:ss') max_sample_time from V\$ACTIVE_SESSION_HISTORY;
EOF

else
 sysdate=$(date +%d/%m/%y\ %H:%M:%S)
 if [ $(is_number $(awk -F"/" '{print $1}' <<< "$*"))  -eq 0 ]; then
   DD_=$(date +%d/%m/%Y)
   HHB_=$(date +%H)
   HHE_=1
   INTERVAL_="between to_date('$sysdate','dd/mm/yy hh24:mi:ss') - interval '$HHE_' hour and sysdate"
 else
   DD_=$(awk -F- '{print $1}' <<< "$*")
   HHB_=$(awk -F- '{print $2}' <<< "$*")
   HHE_=$((awk -F- '{print $3}' | cut -d' ' -f1) <<< "$*")
   HHR_=$(awk '$1!~/:/{print $1}' <<< "$HHE_")
   echo "DD_: $DD_   HHB_: $HHB_  HHE_: $HHE_  HHR_: $HHR_ "
   if [ -n "$HHR_" ]; then
     INTERVAL_="between to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') and to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') + interval '$HHR_' hour"
     shift
   else
     INTERVAL_="between to_date('$DD_ $HHB_','dd/mm/yy hh24:mi') and to_date('$DD_ $HHE_','dd/mm/yy hh24:mi')"
     shift
   fi
 fi

 type_=$((awk '{print $1}' | tr '[:upper:]' '[:lower:]') <<< "$*")
 P1_=$(awk '{print $2}' <<< "$*")
 P2_=$(awk '{print $3}' <<< "$*")
 P3_=$(awk '{print $4}' <<< "$*")

SET_COL='set lines 250 pages 70
set long 1000000000 longc 1000000000
col "SQL_TEXT" for a80
#column TIME for a9
column TIME for a17
column SID for 99999
column SERIAL for 999999
column USERNAME for a25
column sql_id for a13
column sql_plan_hash_value for 9999999999 heading "PHV"
column EVENT for a30
column wait_class for a14
column OBJ# for 99999999
column FILE# for 999
column BLOCK# for 9999999
column BLSID for 99999
column BLSERIAL for 999999
column BLSTATUS for a11
column PROGRAM for a41
column MODULE for a20
column ACTION for a16
column MACHINE for a20
column PMAM for a70 heading "PROGRAM \ MODULE \ ACTION \ MACHINE" truncated
column TIME_WAITED for 999990.99
column CPU for 99990.99
column WAIT for 99990.99
column IO for 99990.99
column activity for 99990.99 heading "%ACTIVITY"
col sql_opname for a15
col entry_name for a45

column top_level_sql_id for a14
column top_level_call_name for a20'

shopt -s nocasematch
case "$type_" in
event)
   $SP <<EOF >$LOGF
   $SET_COL
   PROMPT "Top 20 events from V\$ACTIVE_SESSION_HISTORY where sample_time $INTERVAL_"
   select * from ( select nvl(EVENT, 'ON CPU') EVENT, round(100*count(*)/ sum(count(1)) over(), 2) "%ACTIVITY" from V\$ACTIVE_SESSION_HISTORY
   where sample_time $INTERVAL_ group by EVENT order by 2 desc ) where rownum<21;
EOF
;;
sess)
if [ -n "$P1_"  -a -n "$P2_" -a "$P3_" = "all" ]; then
  $SP <<EOF >$LOGF
 PROMPT
  PROMPT "Session from V\$ACTIVE_SESSION_HISTORY by filter: SID: $P1_  SERIAL: $P2_ and sample_time $INTERVAL_"
  $SET_COL
  select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
  blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action, $MACHINE_ */ program||' \ '||module||' \ '||action||' \ '|| $MACHINE_ PMAM
  from v\$active_session_history h, dba_users u where h.user_id=u.user_id 
  and sample_time $INTERVAL_
  and session_id = '$P1_' and "SESSION_SERIAL#" = '$P2_' order by sample_time;
EOF
elif [ -n "$P1_" -a -n "$P2_" ]; then
  if [ "$P3_" != "nosqlid" ]; then   S1_="sql_id,sql_plan_hash_value,"; fi
  $SP <<EOF >$LOGF
  PROMPT
  PROMPT "Top 30 Waits in seconds  from V\$ACTIVE_SESSION_HISTORY for sid = '$P1_' and serial = '$P2_' and sample_time $INTERVAL_"
  $SET_COL
  select * from (
  select session_id sid,"SESSION_SERIAL#" serial,username, $S1_ nvl(event,'ON CPU') event, program||' \ '||module||' \ '||action||' \ '||machine PMAM,
    sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
    sum(decode(session_state,'ON CPU',wait_time))/1000000     "CPU",
    (sum(decode(session_state,'WAITING',time_waited))  -  sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0))) )/1000000    "WAIT" ,
    sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0)))/1000000    "IO" ,
    round(100*count(*)/ sum(count(1)) over(), 2) activity
  from v\$active_session_history h, dba_users u where h.user_id=u.user_id
  --and sql_id is not null
  and sample_time $INTERVAL_
  and session_id = '$P1_' and "SESSION_SERIAL#" = '$P2_'
  group by session_id,"SESSION_SERIAL#",username, $S1_ event,program,module,action,machine
  order by activity desc
  ) where rownum < 31;
EOF
elif [ -n "$P1_" ]; then 
  $SP <<EOF >$LOGF
  PROMPT
  PROMPT "Session from V\$ACTIVE_SESSION_HISTORY by filter: SQL_ID: $P1_ and sample_time $INTERVAL_"
  $SET_COL
  select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
  blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action, $MACHINE_ */ program||' \ '||module||' \ '||action||' \ '|| $MACHINE_ PMAM
  from v\$active_session_history h, dba_users u where h.user_id=u.user_id 
  and sample_time $INTERVAL_ and sql_id = '$P1_' order by sample_time;
EOF
else
  $SP <<EOF >$LOGF
  PROMPT
  PROMPT "Top 30 ACTIVE Sessions in seconds from V\$ACTIVE_SESSION_HISTORY where sample_time $INTERVAL_"
  $SET_COL
  select * from (
  select session_id sid,"SESSION_SERIAL#" serial,username,/*sql_id,sql_plan_hash_value,nvl(event,'ON CPU') event,*/ /* session_state,*/ /*program,module,action,machine,*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM,
    sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
    sum(decode(session_state,'ON CPU',wait_time))/1000000     "CPU",
    (sum(decode(session_state,'WAITING',time_waited))  -  sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0))) )/1000000    "WAIT" ,
    sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0)))/1000000    "IO" ,
    round(100*count(*)/ sum(count(1)) over(), 2) activity
  from v\$active_session_history h, dba_users u where h.user_id=u.user_id 
  and sql_id is not null
  and sample_time $INTERVAL_
  group by session_id,"SESSION_SERIAL#",username,/*sql_id,sql_plan_hash_value,event,session_state,*/program,module,action,machine
  order by activity desc
  ) where rownum<31;
EOF
fi
;;
where)
FIELD_=$(awk '{print $2}' <<< "$*")
if [ -z "$FIELD_" ]; then FIELD_="program"; fi
PRG_=$(awk '{print $3}' <<< "$*")
COND_="and $FIELD_ like '%$PRG_%'"
$SP <<EOF >$LOGF
PROMPT
PROMPT "Stat top 30 session_state from V\$ACTIVE_SESSION_HISTORY for condition: $COND_ and sample_time $INTERVAL_"
$SET_COL
select * from (
select session_id sid,"SESSION_SERIAL#" serial, username,
   sql_id,sql_plan_hash_value,
   nvl(event,'ON CPU') event, /* top_level_sql_id, top_level_call_name, */   /* program, session_state, */ /*program,module,action,machine,*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM,
   sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
   sum(decode(session_state,'ON CPU',wait_time))/1000000     "CPU",
   (sum(decode(session_state,'WAITING',time_waited))  -  sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0))) )/1000000    "WAIT" ,
   sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0)))/1000000    "IO" ,
   round(100*count(*)/ sum(count(1)) over(), 2) activity
from v\$active_session_history h, dba_users u where h.user_id=u.user_id
  --and sql_id is not null 
  --and sql_plan_hash_value<>0
  and sample_time $INTERVAL_
  $COND_
  --and PLSQL_ENTRY_OBJECT_ID = 11235547
  --and "CURRENT_OBJ#" = 56645
  --and program like '%$PRG_%'
  --and module like '%$PRG_%'
  --and action like '%$PRG_%'
group by session_id,"SESSION_SERIAL#",
  username,
  sql_id,sql_plan_hash_value,
  event, /* top_level_sql_id, top_level_call_name, */ program,module,action,machine
order by activity desc
) where rownum < 51;
EOF
;;
sql)
  P1_=$(echo $* | awk '{print $2}')
  case "$P1_" in
  all)
   shift
   shift
   EVENT_="$*"
   $SP <<EOF >$LOGF
   PROMPT
   PROMPT "Events from V\$ACTIVE_SESSION_HISTORY where sample_time $INTERVAL_ and event like $EVENT_"
   $SET_COL
   column PMAM for a55 heading "PROGRAM \ MODULE \ ACTION \ MACHINE" truncated
   select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,wait_class,"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
   blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action, $MACHINE_ */ program||' \ '||module||' \ '||action||' \ '|| $MACHINE_ PMAM
   from v\$active_session_history h, dba_users u where h.user_id=u.user_id and sample_time $INTERVAL_ and event like '%$EVENT_%' order by sample_time;
EOF
  ;;
  top)
   shift
   shift
   EVENT_="$*"
   echo "EVENT_: "$EVENT_
   if [ -n "$EVENT_" ]; then
     S0_="x.event, "
     S1_="nvl(event,'ON CPU') event,"
     S2_=" and event like '%$EVENT_%'"
     S3_=", event "
   else 
     S2_="and sql_id is not null"
   fi
   $SP <<EOF >$LOGF
   PROMPT
   PROMPT "Top 30 SQL TIME_WAITED in second from V\$ACTIVE_SESSION_HISTORY where sample_time $INTERVAL_ for event like '%$EVENT_%'"
   $SET_COL
   select * from (
   select  x.sql_id, x.sql_plan_hash_value,sql_opname, e.object_name || decode(e.object_name,'','','.') || e.procedure_name entry_name, $S0_ x.time_waited,x.cpu,x.wait,x.io, /* x.cnt,*/ x.activity
   from      dba_procedures    e, dba_procedures    p,
           (select    plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
                      sql_id,
                      sql_plan_hash_value,
                      sql_opname, $S1_
                      sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
                      sum(decode(session_state,'ON CPU',wait_time))/1000000     "CPU",
                      (sum(decode(session_state,'WAITING',time_waited))  -  sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0))) )/1000000    "WAIT" ,
                      sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',time_waited,0)))/1000000    "IO" ,
                      round(100*count(*)/ sum(count(1)) over(), 2) activity
            from      v\$active_session_history
   where sample_time $INTERVAL_ $S2_
--   and sql_plan_hash_value <> 0
            group by  plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
                      sql_id,
                      sql_plan_hash_value,
                      sql_opname $S3_ ) x
   where     e.object_id (+) = x.plsql_entry_object_id
   and       e.subprogram_id (+) = x.plsql_entry_subprogram_id
   and       p.object_id (+) = x.plsql_object_id
   and       p.subprogram_id (+) = x.plsql_subprogram_id
   order by   x.activity desc )
   where rownum<31 ;
EOF
  ;;
  *)
SQL_ID_=$(awk '{print $2}' <<< "$*")
SQL_TEXT_=$(shift; tr '[:lower:]' '[:upper:]' <<< "$*")
#echo "SQL_TEXT_="$SQL_TEXT_
if [ -z "$SQL_ID_" ]; then
$SP <<EOF >$LOGF
$SET_COL
PROMPT
PROMPT "Top 20 SQL, CALL from V\$ACTIVE_SESSION_HISTORY where sample_time $INTERVAL_"
BREAK ON SQL_ID ON PLAN_HASH ON TYPE ON TIME_WAITED ON CPU ON WAIT ON IO ON activity SKIP 1 NODUPLICATES
select /*+ LEADING(H_TXT) */ s.*, h_txt.sql_text from (
select * from (
select ash.SQL_ID , ash.SQL_PLAN_HASH_VALUE Plan_hash, aud.name type,
  sum(decode(ash.session_state, 'ON CPU', ash.wait_time, ash.time_waited))/1000000 time_waited,
  sum(decode(ash.session_state,'ON CPU',ash.wait_time))/1000000     "CPU",
  (sum(decode(ash.session_state,'WAITING',time_waited))  -  sum(decode(ash.session_state,'WAITING', decode(ash.wait_class, 'User I/O',ash.time_waited,0))) )/1000000    "WAIT" ,
  sum(decode(ash.session_state,'WAITING', decode(ash.wait_class, 'User I/O',ash.time_waited,0)))/1000000    "IO" ,
  round(100*count(*)/ sum(count(1)) over(), 2) activity
from V\$ACTIVE_SESSION_HISTORY ash,
     audit_actions aud
where ash.SQL_ID is not NULL
   and ash.sql_opcode=aud.action
    and sample_time $INTERVAL_
group by ash.sql_id, SQL_PLAN_HASH_VALUE   , aud.name
order by activity desc
) where rownum < 11) s, V\$SQLTEXT h_txt where s.sql_id=h_txt.sql_id order by activity desc, s.SQL_ID, s.Plan_hash, h_txt.piece;
EOF
else
LEN_=$(expr length $P1_)
P1__=$(tr -d '[:digit:][:lower:]' <<< "$P1_")
if [ -z "$P1__" -a $LEN_ -eq 13 ] ; then
 SQL_="SELECT ash.sql_id, a.plan_hash_value, a.sql_text,a.executions,round(a.disk_reads/decode(a.executions, 0, 1, a.executions),0) pio_per_exec,round(a.buffer_gets /decode(a.executions, 0, 1, a.executions),0) lio_per_exec, round(decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/EXECUTIONS/1000000, 4)),4) cpu_time, round(((elapsed_time / decode(executions, 0, 1, executions)) / 1000000),4) elapsed_time, decode(EXECUTIONS, 0, user_io_wait_time/1000000, round(user_io_wait_time/decode(executions, 0, 1, executions)/1000000, 4)) iowait FROM v\$active_session_history ash, v\$sqlarea a WHERE ash.sql_id = a.sql_id and sample_time $INTERVAL_ and ash.sql_plan_hash_value=a.plan_hash_value AND ash.sql_id = '$P1_' AND rownum=1;"
 PROMPT_="SQL_ID = $SQL_ID_"
else
 SQL_="SELECT ash.sql_id, a.plan_hash_value, a.sql_text,a.executions,round(a.disk_reads/decode(a.executions, 0, 1, a.executions),0) pio_per_exec,round(a.buffer_gets /decode(a.executions, 0, 1, a.executions),0) lio_per_exec, round(decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/EXECUTIONS/1000000, 4)),4) cpu_time, round(((elapsed_time / decode(executions, 0, 1, executions)) / 1000000),4) elapsed_time, decode(EXECUTIONS, 0, user_io_wait_time/1000000, round(user_io_wait_time/decode(executions, 0, 1, executions)/1000000, 4)) iowait FROM v\$active_session_history ash, v\$sqlarea a WHERE ash.sql_id = a.sql_id and sample_time $INTERVAL_ and ash.sql_plan_hash_value=a.plan_hash_value AND upper(a.sql_text) like '%$SQL_TEXT_%' AND rownum=1;"
 PROMPT_="SQL_TEXT like $SQL_TEXT_"
fi
$SP <<EOF >$LOGF
PROMPT
PROMPT "SQL from V\$ACTIVE_SESSION_HISTORY by $PROMPT_ in sample_time $INTERVAL_"
$SET_COL
column executions for 999,999,999 
column pio_per_exec for 999,999,999 heading "PIO\EX"
column lio_per_exec for 99,999,999,999 heading "LIO\EX"
column cpu_time for 999,999.9999 heading "CPU_TIME\EX"
column elapsed_time for 999,999.9999 heading "ELA_TIME\EX"
column iowait for 999,999,999 heading "IOWAIT\EX"
$SQL_
EOF
fi
;;
esac
;;
plan)
  $SP <<EOF >$LOGF
  PROMPT
  PROMPT "Current Plan from V\$SQL_PLAN and V\$ACTIVE_SESSION_HISTORY (dbms_xplan.display_cursor) for sql_id: $P1_ "
  PROMPT
  set lines 250 pages 0 feedback off
  column plan_hash_value for 9999999999
  column OBJECT_NAME for a30
  BREAK ON plan_hash_value SKIP 1 NODUPLICATES
-- select plan_table_output from table(dbms_xplan.display_cursor('$P1_','',format=>nvl('$P2_', '-predicate') ));
  select plan_table_output from table(dbms_xplan.display_cursor('$P1_','',format=>nvl('$P2_', 'typical +outline last') ));
EOF
;;
sqlstat)
SQL_SQLSTAT="
set lines 250 pages 50 feedback off timing off
col sql_id for a15
col plan_hash_value for 999999999999 heading 'PLAN_HASH_VALUE'
col PARSE_CALLS for 999,999,999
col invalidations for 999,999
col fetches for 999,999 heading 'FCH\EX'
col sorts for 999,999 heading 'SORT\EX'
col executions for 999,999,999 heading 'EXEC'
col pio_per_exec for 999,999,999 heading 'PIO\EX'
col lio_per_exec for 99,999,999,999 heading 'LIO\EX'
col rows_processed for 999,999,999 heading 'ROWS_PR\EX'
col cpu_time for 999,999.9999 heading 'CPU_TIME\EX'
col elapsed_time for 999,999.9999 heading 'ELA_TIME\EX'
col iowait for 999999999 heading 'IOWAIT\EX'
"
if [ -n "$P1_" ]; then LEN_=$(expr length $P1_) ; fi
case "$LEN_" in
  13)
$SP <<EOF >$LOGF
PROMPT
PROMPT "After change plan do not forget purge the old statistics:"
set lines 250 pages 50 feedback off timing off
col cmd for a70 heading "COMMAND TO PURGE SQL STATEMENT"
col sql_id for a15
col address for a20
col hash_value for 9999999999 
col executions for 999,999,999
col loads for 999999999
col version_count for 999999
col PARSE_CALLS for 999,999,999
col invalidations for 999,999
select 'exec dbms_shared_pool.purge ('''||address||','||hash_value||''',''C'');' cmd, sql_id,address, hash_value, executions, loads, version_count, invalidations, parse_calls from v\$sqlarea where sql_id  = '$P1_';
select sql_id,users_opening,users_executing,open_versions from v\$sql where sql_id = '$P1_';

PROMPT
PROMPT "SQLStats from V\$SQLSTATS  for sql_id: $P1_"
$SQL_SQLSTAT
select sql_id,plan_hash_value,last_active_time,parse_calls,invalidations,
trunc(fetches / decode(executions, 0, 1, executions)) fetches,
trunc(sorts / decode(executions, 0, 1, executions)) sorts,
executions,
trunc(DISK_READS / decode(executions, 0, 1, executions)) PIO_PER_EXEC,
(buffer_gets / decode(nvl(executions, 0), 0, 1, executions)) LIO_PER_EXEC,
trunc(rows_processed / decode(executions, 0, 1, executions)) rows_processed,
decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/EXECUTIONS/1000000, 4)) cpu_time,
(elapsed_time / decode(nvl(executions, 0), 0, 1, executions)) / 1000000 elapsed_time,
decode(EXECUTIONS, 0, user_io_wait_time/1000000, round(user_io_wait_time/EXECUTIONS/1000000, 4)) iowait,
sharable_mem
FROM V\$SQLSTATS WHERE sql_id = '$P1_';
EOF
;;
  *)
 case "$P1_" in
   pio*) S1_="PIO_PER_EXEC * executions" ;;
   lio*) S1_="LIO_PER_EXEC * executions" ;;
   cpu*) S1_="cpu_time * executions" ;;
   exe*) S1_="executions" ;;
   ela*) S1_="elapsed_time * executions" ;;
   fch*) S1_="fetches * executions" ;;
   sor*|srt*) S1_="sorts * executions" ;;
   iow*) S1_="iowait * executions" ;;
   row*) S1_="rows_processed * executions" ;;
   mem*|sha*) S1_="sharable_mem" ;;
   par*) S1_="parse_calls" ;;
   inv*) S1_="invalidations" ;;
      *) S1_="PIO_PER_EXEC * executions" ;;
 esac
 if [ -z "$P2_" ]; then P2_=1; fi
$SP <<EOF >$LOGF
$SQL_SQLSTAT
PROMPT "TOP 40 SQLStats from V\$SQLSTATS in last_active_time $INTERVAL_  order by $S1_ desc"
select * from (
select sql_id,plan_hash_value,last_active_time,parse_calls,invalidations,
trunc(fetches / decode(executions, 0, 1, executions)) fetches,
trunc(sorts / decode(executions, 0, 1, executions)) sorts,
executions,
trunc(DISK_READS / decode(executions, 0, 1, executions)) PIO_PER_EXEC,
(buffer_gets / decode(nvl(executions, 0), 0, 1, executions)) LIO_PER_EXEC,
trunc(rows_processed / decode(executions, 0, 1, executions)) rows_processed,
decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/EXECUTIONS/1000000, 4)) cpu_time,
(elapsed_time / decode(nvl(executions, 0), 0, 1, executions)) / 1000000 elapsed_time,
decode(EXECUTIONS, 0, user_io_wait_time/1000000, round(user_io_wait_time/EXECUTIONS/1000000, 4)) iowait,
sharable_mem
FROM V\$SQLSTATS where  executions >= $P2_ and last_active_time $INTERVAL_
order by $S1_ desc
) where rownum <=40;
EOF
;;
esac
;;
mchart) awr_mchart v\$active_session_history
;;
cchart) awr_cchart v\$active_session_history
;;
tchart) awr_tchart v\$active_session_history
;;
temp) awr_tempusage v\$active_session_history $P1_
;;
*) echo "Nothing..." ;;
esac
fi
logf
}


spm()
{
type_=$(awk '{print $1}' <<< "$*")

case "$type_" in
  find)  P1_=$(awk '{print $2}' <<< "$*") ; P2_=$(awk '{print $3}' <<< "$*") ; COND1_=" and sql_handle like '$P1_' and plan_name like nvl('$P2_','%') " ; DAYS=10950 ;;
  [0-9]*)  DAYS=$type_ ; shift ; type_=$(awk '{print $1}' <<< "$*") ;;
       *)  COND1_="" ; DAYS=7 ;;
esac
# echo "spm DAYS: "$DAYS
# echo "spm COND1_: "$COND1_

$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 400 timing off
PROMPT
PROMPT Current records in dba_sql_plan_baselines by last days: $DAYS
PROMPT
column SQL_NAME for a30 heading "SQL_HANDLE \ PLAN_NAME"
column SQL_HANDLE for a20
column PLAN_NAME for a30
column creator for a10
column origin for a12
column parsing_schema_name for a10
column created for a10
column last_modified for a10
column last_executed for a10
column enabled for a3
column accepted for a3
column fixed for a3
column optimizer_cost for 9999999 heading COST
column module for a12
column executions for 999999999 heading EXEC
column elapsed_time for 99999.00000 heading ELA_T\EX
column cpu_time for 99999.00000 heading CPU_T\EX
column buffer_gets for 99999999999 heading BUFGETS\EX
column disk_reads for 999999999 heading DISKR\EX
column rows_processed for 999999999 heading ROWS\EX
--ttitle left "View dba_sql_plan_baselines:"
select sql_handle||chr(10)||plan_name sql_name,creator,origin,parsing_schema_name,
cast(created as date) created, cast(last_modified as date) last_modified, cast(last_executed as date) last_executed,
enabled, accepted, fixed, optimizer_cost, module, executions,
decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/decode(executions, 0, 1, executions)/1000000, 4)) cpu_time,
(elapsed_time / decode(executions, 0, 1, executions)) / 1000000 elapsed_time,
trunc(buffer_gets/decode(executions, 0, 1, executions)) buffer_gets,
trunc(disk_reads/decode(executions, 0, 1, executions)) disk_reads,
trunc(rows_processed/decode(executions, 0, 1, executions)) rows_processed
from dba_sql_plan_baselines where created > sysdate-$DAYS  $COND1_  order by cast(created as date), sql_handle;

PROMPT
PROMPT Current records in dba_sql_plan_baselines by last days: $DAYS and condition: $COND1_
PROMPT
set serveroutput on
declare
 v_sqlid VARCHAR2(13);
 v_num number;
 cnt integer;
BEGIN
 cnt:=0;
 dbms_output.put_line('SQL_ID       '||' '|| 'PLAN_HASH_VA'||' '||'SQL_HANDLE          '||' '||'PLAN_NAME                     '||' '||'CREATED            '||' '||'LAST_MODIFIED      '
                    ||' '||'LAST_EXECUTED      '||' '||'ENA'||' '||'ACC'||' '||'FIX'||' '||'   COST'||' '||'     EXEC'||' '||'CPU_T/EX'||' '||'ELA_T/EX'||' '||'BUFGETS/EX'||' '||'DISKR/EX'||' '||'ROWS/EX');
 dbms_output.put_line('-------------'||' '|| '------------'||' '||'--------------------'||' '||'------------------------------'||' '||'-------------------'||' '||'-------------------'
                    ||' '||'-------------------'||' '||'---'||' '||'---'||' '||'---'||' '||'-------'||' '||'---------'||' '||'--------'||' '||'--------'||' '||'----------'||' '||'--------'||' '||'-------');
 for a in (select sql_handle, plan_name, trim(substr(g.PLAN_TABLE_OUTPUT,instr(g.PLAN_TABLE_OUTPUT,':')+1)) plan_hash_value, sql_text, 
            created,last_modified,last_executed,enabled,accepted,fixed,optimizer_cost,module,executions,
             decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/decode(executions, 0, 1, executions)/1000000, 4)) cpu_time,
             (elapsed_time / decode(executions, 0, 1, executions)) / 1000000 elapsed_time,
             trunc(buffer_gets/decode(executions, 0, 1, executions)) buffer_gets,
             trunc(disk_reads/decode(executions, 0, 1, executions)) disk_reads,
             trunc(rows_processed/decode(executions, 0, 1, executions)) rows_processed
                 from (select t.*, c.* from dba_sql_plan_baselines c, table(dbms_xplan.DISPLAY_SQL_PLAN_BASELINE(c.sql_handle, c.plan_name)) t
                 /* where c.sql_handle = 'SQL_0b27795a43a131fa' */) g
                 where PLAN_TABLE_OUTPUT like 'Plan hash value%' $COND1_ and created>sysdate-$DAYS order by created) loop
    v_num := to_number(sys.UTL_RAW.reverse(sys.UTL_RAW.SUBSTR(sys.dbms_crypto.hash(src => UTL_I18N.string_to_raw(a.sql_text || chr(0),'AL32UTF8'), typ => 2),9,4)) || 
             sys.UTL_RAW.reverse(sys.UTL_RAW.SUBSTR(sys.dbms_crypto.hash(src => UTL_I18N.string_to_raw(a.sql_text || chr(0),'AL32UTF8'), typ => 2),13,4)),RPAD('x', 16, 'x'));
    v_sqlid := '';
    FOR i IN 0 .. FLOOR(LN(v_num) / LN(32)) LOOP
        v_sqlid := SUBSTR('0123456789abcdfghjkmnpqrstuvwxyz',FLOOR(MOD(v_num / POWER(32, i), 32)) + 1,1) || v_sqlid;
    END LOOP;
    dbms_output.put_line(lpad(v_sqlid, 13, '0')||' '||rpad(a.plan_hash_value,12)||' '||rpad(a.sql_handle,20)||' '||rpad(a.plan_name,30)||' '||rpad(cast(a.created as date),19)||' '||
     rpad(cast(a.last_modified as date),19)||' '||rpad(nvl(rpad(cast(a.last_executed as date),19),' '),19)||' '||rpad(a.enabled,3)||' '||rpad(a.accepted,3)||' '||rpad(a.fixed,3)||' '||
     lpad(a.optimizer_cost,7)||' '||lpad(a.executions,9)||' '||lpad(a.cpu_time,8)||' '||lpad(a.elapsed_time,8)||' '||lpad(a.buffer_gets,10)||' '||lpad(a.disk_reads,8)||' '||lpad(a.rows_processed,7)
     );
   cnt:=cnt+1;
 end loop;
 dbms_output.put_line(chr(10)||cnt||' rows selected.');
end;
/
EOF


case $type_ in
blplan)
  sql_handle="$2"
  plan_name="$3"
  if [ "$sql_handle" = "%" ]; then sql_handle=""; fi
    $SP <<EOF >$LOGF
    set lines 230
    set echo off feed off veri off tab off pages 400
    ttitle left "DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE(sql_handle=>'$sql_handle',plan_name=>'$plan_name',format=>'-predicate +outline'):"
    select * from table(DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE(sql_handle=>'$sql_handle',plan_name=>'$plan_name',format=>'-predicate +outline'));
EOF
;;
blexec)
  param=$2
  $SP <<EOF >$LOGF
  set lines 230
  set echo off feed off veri off tab off pages 400
  column SQL_HANDLE for a20
  column PLAN_NAME for a30
  column PARSING_SCHEMA_NAME for a20
  column optimizer_cost for 999999 heading COST
  column origin for a20
  column created for a10
  column last_exec for a10
  column last_executed for a11 heading "LAST_EXEC"
  column executions for 999999999
  ttitle left "Join views v\$sql, dba_sql_plan_baselines where baselines.executions >= nvl('$param',1) :"
  select distinct s.sql_id, s.plan_hash_value, b.sql_handle, b.plan_name, b.parsing_schema_name, b.optimizer_cost, b.origin, b.enabled, b.accepted, b.fixed, b.autopurge,
  cast(b.created as date) created,cast(b.last_executed as date) last_exec, b.executions
  from v\$sql s, dba_sql_plan_baselines b where s.exact_matching_signature = b.signature and b.executions >= nvl('$param',1)
  order by created, last_exec;
EOF
;;
bllpfcc)
  sql_id="$2"
  plan_hash_value="$3"
  sql_handle="$4"
  if [ -n "$sql_handle" ]; then
    SQL_=", fixed => 'YES', sql_handle => '$sql_handle'"
  fi
  $SP <<EOF >$LOGF
  set lines 200
  set echo off feed off veri off tab off pages 400
  PROMPT Load the sql_id into the SQL Basesile: DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE( sql_id => '$sql_id', PLAN_HASH_VALUE => '$plan_hash_value', sql_handle => '$sql_handle');
  DECLARE
    my_plans pls_integer;
  BEGIN
    my_plans := DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(
    sql_id => '$sql_id',
    PLAN_HASH_VALUE => '$plan_hash_value'
    $SQL_ ); 
  dbms_output.put_line('Value is '||my_plans);
  END;
/
EOF
;;
bllpfawr)
  sql_id="$2"
  plan_hash_value="$3"
  begin_snap="$4"
  end_snap="$5"
  sqlset="tpi-$sql_id-$(date +%d-%m-%Y)"
  echo "sqlset="$sqlset
$SP <<EOF >$LOGF
set lines 230
exec DBMS_SQLTUNE.CREATE_SQLSET(sqlset_name=>'$sqlset');

column name for a30
column owner for a30
ttitle left "View dba_sqlset before load SQL_ID=$sql_id into SQLSET_NAME=$sqlset: last 15 days"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET where CREATED>sysdate-15;
ttitle off

prompt "Load SQL from AWR to SQLSET:"
declare
 baseline_ref_cursor DBMS_SQLTUNE.SQLSET_CURSOR;
begin
 open baseline_ref_cursor for
 select VALUE(p) from table(DBMS_SQLTUNE.SELECT_WORKLOAD_REPOSITORY($begin_snap,$end_snap,'sql_id='||CHR(39)||'$sql_id'||CHR(39)||' and plan_hash_value=$plan_hash_value',NULL,NULL,NULL,NULL,NULL,NULL,'ALL')) p;
 DBMS_SQLTUNE.LOAD_SQLSET(sqlset_name=>'$sqlset', populate_cursor=>baseline_ref_cursor);
end;
/

column name for a30
column owner for a30
ttitle left "View dba_sqlset after load SQL_ID=$sql_id into SQLSET_NAME=$sqlset: last 15 days"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET where CREATED>sysdate-15;
ttitle off

--Verify the execution Plan of a SQL_ID in the STS for an user sql
set pages 200
ttitle left "Verify the execution Plan of a SQL_ID=$sql_id in the STS=$sqlset for an user sql:"
SELECT * FROM table (DBMS_XPLAN.DISPLAY_SQLSET('$sqlset','$sql_id'));
ttitle off

--Load the Sql Plan Baseline from STS
prompt "Load the SQL Plan into baseline from SQLSET_NAME=$sqlset:"
set serveroutput on
declare
 my_integer pls_integer;
begin
 my_integer := dbms_spm.load_plans_from_sqlset(sqlset_name => '$sqlset', sqlset_owner => 'SYS', fixed => 'NO', enabled => 'YES');
 DBMS_OUTPUT.PUT_line(my_integer);
end;
/
EOF
;;
blchattr)
  sql_handle="$2"
  plan_name="$3"
  attr_name="$4"
  attr_value="$5"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
SET SERVEROUTPUT ON
set lines 180 long 1000 pages 100
--Enable\Disable  a specific sql baseline plan attributes
PROMPT Enable\Disable a specific sql baseline plan attributes: "enabled" YES\NO   "fixed" YES\NO   "autopurge" YES\NO
set serveroutput on
declare
  v_sql_plan_id  pls_integer;
begin
  v_sql_plan_id := dbms_spm.alter_sql_plan_baseline(
    sql_handle      => '$sql_handle',
    plan_name       => '$plan_name',
    attribute_name  => '$attr_name',
    attribute_value => '$attr_value');
end;
/
EOF
;;
blchplan)
  sql_id="$2"
  plan_hash_value="$3"
  sql_handle="$4"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
SET SERVEROUTPUT ON
set lines 180 long 1000 pages 100
PROMPT Change baseline plan:  dbms_spm.load_plans_from_cursor_cache(sql_id => '$sql_id', plan_hash_value => '$plan_hash_value', fixed => 'YES', sql_handle => '$sql_handle', enabled => 'YES')
begin
  dbms_output.put_line(dbms_spm.load_plans_from_cursor_cache(sql_id => '$sql_id', plan_hash_value => '$plan_hash_value', fixed => 'YES', sql_handle => '$sql_handle', enabled => 'YES'));
end;
/
EOF
;;
blevolve)
  sql_handle="$2"
  plan_name="$3"
$SP <<EOF >$LOGF
set lines 2230 pages 400
set long 1000000000 longc 1000000000
set echo off feed off veri off tab off 
set serveroutput on
DECLARE
  report clob;
BEGIN
  report := DBMS_SPM.EVOLVE_SQL_PLAN_BASELINE(sql_handle=>'$sql_handle', plan_name=>'$plan_name', verify=>'YES', commit=>'YES', time_limit=>360);
  DBMS_OUTPUT.PUT_LINE(report);
END;
/
EOF
;;
sqlset_list)
  sqlset_name="$2"
  sqlset_owner="$3"
  echo "sqlset_name="$sqlset_name
  echo "sqlset_owner="$sqlset_owner
$SP <<EOF >$LOGF
set echo off feed off veri off tab off pages 200
set lines 230 
set long 1000
SET SERVEROUTPUT ON

column name for a30
column owner for a30
ttitle left "View dba_sqlset:"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET order by CREATED;
ttitle off

COLUMN SQL_ID FORMAT a13
COLUMN SQL_TEXT FORMAT a80
COLUMN SCHEMA FORMAT a20
COLUMN ELAPSED FORMAT 99999999999
column plan_hash_value for 9999999999
column optimizer_cost for 9999999 heading COST
column module for a12
column executions for 999999999
column buffer_gets for 99999999999
column disk_reads for 999999999
column rows_processed for 9999999999
column fetches for 99999999
ttitle left "Select details from TABLE( DBMS_SQLTUNE.SELECT_SQLSET( '$sqlset_name' ):"
SELECT SQL_ID,PLAN_HASH_VALUE, PARSING_SCHEMA_NAME AS "SCHEMA", SQL_TEXT, ELAPSED_TIME AS "ELAPSED", BUFFER_GETS,disk_reads,rows_processed,fetches,executions,optimizer_cost
FROM TABLE( DBMS_SQLTUNE.SELECT_SQLSET( sqlset_name => '$sqlset_name',  sqlset_owner => '$sqlset_owner' ) );
EOF
;;
sqlset_plan)
  sqlset_name="$2"
  sqlset_sql_id="$3"
  sqlset_phv="$4"
$SP <<EOF >$LOGF
set lines 230 echo off feed off veri off tab off pages 200
SELECT * FROM table(DBMS_XPLAN.DISPLAY_SQLSET(sqlset_name=>'$sqlset_name',sql_id=>'$sqlset_sql_id',plan_hash_value=>'$sqlset_phv',format => 'typical'));
EOF
;;
sqlset_drop)
  sqlset_name="$2"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
SET SERVEROUTPUT ON
column name for a30
column owner for a30
ttitle left "View dba_sqlset before drop DBMS_SQLTUNE.DROP_SQLSET:"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET;
ttitle off
begin
  DBMS_SQLTUNE.DROP_SQLSET ( sqlset_name=>'$sqlset_name' );
end;
/
column name for a30
column owner for a30
ttitle left "View dba_sqlset after drop DBMS_SQLTUNE.DROP_SQLSET:"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET;
ttitle off
EOF
;;
bldrop)
  sql_handle="$2"
  plan_name="$3"
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 400
SET SERVEROUTPUT ON
PROMPT "Drop DBMS_SPM.drop_sql_plan_baseline(sql_handle => '$sql_handle', plan_name  => '$plan_name'):"
DECLARE
  l_plans_dropped  PLS_INTEGER;
BEGIN
  l_plans_dropped := DBMS_SPM.drop_sql_plan_baseline (
    sql_handle => '$sql_handle',
    plan_name  => '$plan_name');
  DBMS_OUTPUT.put_line(l_plans_dropped);
END;
/
EOF
;;
sqltune)
  case "$2" in
   awr|AWR) 
     sql_id="$3"
     begin_snap="$4"
     end_snap="$5"
     task_name="tpi-${sql_id}-$(date +%d%m%y-%H%M)"
SQL_="
PROMPT Creating DBMS_SQLTUNE.CREATE_TUNING_TASK for sql_id=$sql_id begin_snap=$begin_snap end_snap=$end_snap task_name=$task_name from the AWR
SET SERVEROUTPUT ON SIZE UNLIMITED;
DECLARE
  task_name  VARCHAR2(100);
BEGIN
  task_name := DBMS_SQLTUNE.create_tuning_task (
                 begin_snap  => $begin_snap,
                 end_snap    => $end_snap,
                 sql_id      => '$sql_id',
                 scope       => DBMS_SQLTUNE.scope_comprehensive,
                 time_limit  => 240,
                 task_name   => '$task_name',
                 description => 'tpi tuning task for statement $sql_id in AWR.');
  DBMS_OUTPUT.PUT_LINE('Task Name: ''' || task_name || ''' Tuning Task Created');
END;
/
"
   ;;
   *)
     sql_id="$2"
     task_name="tpi-${sql_id}-$(date +%d%m%y-%H%M)"
SQL_="
PROMPT Creating DBMS_SQLTUNE.CREATE_TUNING_TASK for sql_id=$sql_id task_name=$task_name from the cursor cache
SET SERVEROUTPUT ON SIZE UNLIMITED;
DECLARE
  task_name VARCHAR2(30);
BEGIN
  task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK ( sql_id => '$sql_id', scope => 'COMPREHENSIVE', time_limit => 120, task_name => '$task_name');
--  task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK ( sql_id => '$sql_id', scope => 'LIMITED', time_limit => 60, task_name => '$task_name');
  DBMS_OUTPUT.PUT_LINE('Task Name: ''' || task_name || ''' Tuning Task Created');
END;
/
"
   ;;
   esac
$SP <<EOF >$LOGF
set lines 230
--set echo off feed off veri off tab off pages 400
$SQL_
PROMPT Executing DBMS_SQLTUNE.EXECUTE_TUNING_TASK for task_name=$task_name
BEGIN
  DBMS_SQLTUNE.EXECUTE_TUNING_TASK ( task_name => '$task_name');
END;
/
PROMPT Executing DBMS_SQLTUNE.REPORT_TUNING_TASK for task_name=$task_name
SET LONG 2000
SET LONGCHUNKSIZE 2000
SET LINESIZE 10000
DECLARE
    dat clob;
 PROCEDURE DISPLAY_CLOB (P_CLOB IN CLOB) IS
  l_amt NUMBER DEFAULT 32000;
  l_offset NUMBER DEFAULT 1;
  l_length NUMBER DEFAULT NVL (DBMS_LOB.getlength (p_clob), 0);
  x varchar2(32760);
 BEGIN
  WHILE (l_offset < l_length) LOOP
   dbms_lob.read (p_clob, l_amt, l_offset, x);
   l_offset := l_offset + l_amt;
   DBMS_OUTPUT.PUT_LINE(X);
  END LOOP;
 END DISPLAY_CLOB;
BEGIN
    dat := DBMS_SQLTUNE.REPORT_TUNING_TASK ( task_name => '$task_name' , type => 'TEXT' , level => 'TYPICAL' , section => 'ALL' );
    DISPLAY_CLOB(dat);
    dat :=  DBMS_SQLTUNE.SCRIPT_TUNING_TASK('$task_name');
    DISPLAY_CLOB(dat);
END;
/
EOF
echo "Use: spm sqltune_accept for accept profile with FORCE_MATCHING"
;;
sqltune_report)
  task_name="$2"
  echo $task_name
$SP <<EOF >$LOGF
set lines 200
PROMPT Executing DBMS_SQLTUNE.REPORT_TUNING_TASK for task_name=$task_name
SET SERVEROUTPUT ON SIZE 1000000 FOR WRAPPED
SET LONG 20000
SET LONGCHUNKSIZE 20000
SET LINESIZE 32000
DECLARE
    dat clob;
 PROCEDURE DISPLAY_CLOB (P_CLOB IN CLOB) IS
  l_amt NUMBER DEFAULT 32000;
  l_offset NUMBER DEFAULT 1;
  l_length NUMBER DEFAULT NVL (DBMS_LOB.getlength (p_clob), 0);
  x varchar2(32760);
 BEGIN
  WHILE (l_offset < l_length) LOOP
   dbms_lob.read (p_clob, l_amt, l_offset, x);
   l_offset := l_offset + l_amt;
   DBMS_OUTPUT.PUT_LINE(X);
  END LOOP;
 END DISPLAY_CLOB;
BEGIN
    dat := DBMS_SQLTUNE.REPORT_TUNING_TASK ( task_name => '$task_name' , type => 'TEXT' , level => 'TYPICAL' , section => 'ALL' );
    DISPLAY_CLOB(dat);

    dat :=  DBMS_SQLTUNE.SCRIPT_TUNING_TASK('$task_name');
    DISPLAY_CLOB(dat);
END;
/
EOF
;;
sqltune_accept)
  task_name="$2"
  echo $task_name
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT Accepting sql_profile by  dbms_sqltune.accept_sql_profile 
--exec dbms_sqltune.accept_sql_profile(task_name => '$task_name', task_owner => 'SYS', replace => TRUE, name => '$task_name', profile_type => DBMS_SQLTUNE.PX_PROFILE, force_match  => TRUE);
exec dbms_sqltune.accept_sql_profile(task_name => '$task_name', task_owner => 'SYS', replace => TRUE, name => '$task_name', force_match  => TRUE);
EOF
;;
sqltune_create_plan_bl)
  task_name="$2"
  owner="$3"
  plan_hash_value="$4"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT Create dbms_sqltune.create_sql_plan_baseline for task_name='$task_name' owner='$owner' plan_hash_value='$plan_hash_value'
exec dbms_sqltune.create_sql_plan_baseline(task_name => '$task_name', owner_name => '$owner', plan_hash_value => $plan_hash_value);
EOF
;;
sqltune_list)
  task_name="$2"
  cnt="$3"
  if [ -z "$cnt" ]; then
    cnt=30
  fi
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 400
set feed on
column task_id for 999999
column owner for a15
column task_name for a30
column created for a19
column last_modified for a19
column execution_start for a19
column execution_end for a19
column status for a12
ttitle left "List last $cnt tasks from DBA_ADVISOR_TASKS where TASK_NAME like %${task_name}%"
select * from ( SELECT owner, task_id,task_name, created,last_modified,execution_start,execution_end,status FROM DBA_ADVISOR_TASKS WHERE task_name like  '%${task_name}%' order by created ) where rownum <= $cnt;
EOF
;;
sqltune_drop)
  task_name="$2"
  echo $task_name
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT Drop tuning task:  DBMS_SQLTUNE.DROP_TUNING_TASK( $task_name );
exec DBMS_SQLTUNE.DROP_TUNING_TASK(task_name => '$task_name');
EOF
;;
sql_profiles)
$SP <<EOF >$LOGF
set lines 230
set echo off feed on veri off tab off pages 400
set long 100000
column name for a30
column sql_profile_name for a30
column category for a15
column sql_id for a14
column plan_hash_value for 9999999999
column created for a19
column type for a6
column status for a9
column force_matching for a10
column task_id for 999999
column task_exec_name for a16
column sql_text  for a70 word_wrapped
ttitle left "Join Views DBA_SQL_PROFILES, DBA_HIST_SQLSTAT:"
select distinct p.name sql_profile_name, p.category, s.sql_id,s.plan_hash_value,cast(p.created as date) created,p.type,p.status,p.force_matching,p.task_id,p.task_exec_name
from dba_sql_profiles p,DBA_HIST_SQLSTAT s
where p.name=s.sql_profile(+)
order by created,sql_id,plan_hash_value;
EOF
;;
sql_profile_chattr)
  name="$2"
  attribute_name="$3"
  value="$4"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT Change attributes for SQL_PROFILE (STATUS=ENABLED\DISABLED, NAME, DESCRIPTION, CATEGORY).  DBMS_SQLTUNE.ALTER_SQL_PROFILE ( name=>'$name', attribute_name=>'$attribute_name', value=>'$value');
exec DBMS_SQLTUNE.ALTER_SQL_PROFILE ( name=>'$name', attribute_name=>'$attribute_name', value=>'$value');
EOF
;;
sql_profile_drop)
  name="$2"
  echo $name
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT DBMS_SQLTUNE.DROP_SQL_PROFILE( name=$name )
exec DBMS_SQLTUNE.DROP_SQL_PROFILE(name=>'$name');
EOF
;;
hints)
  P2_="$2"
  P3_="$3"
  echo $P2_"="$P3_
  case "$P2_" in
    profile)  method=1 ;;
    baseline) method=2 ;;
    patch)    method=3 ;;
  esac
$SP <<EOF >$LOGF
set lines 230
set echo off feed on veri off tab off pages 400
col rownum for 999 noprint
set long 1000000000 longc 1000000000
--SELECT  LISTAGG(TRIM(outline_hints), ' ') WITHIN GROUP( ORDER BY rownum ) AS RESULT from (
select substr(extractvalue(value(d), '/hint'), 1, 32760) as outline_hints, rownum
  from xmltable('/outline_data/hint' passing
                (select xmltype(comp_data) as xmlval
                   from sys.sqlobj\$data od, sys.sqlobj\$ o
                  where o.obj_type = $method
                    and od.obj_type = $method
                    and o.name = '$P3_'
                    and o.signature = od.signature
                    and o.plan_id = od.plan_id
                    and comp_data is not null)) d
--)
;
EOF
;;
sqlpatch_create)
P2_="$2"
shift
shift
P3_="$*"
# rtpi  z14-1847  RS_T_MSK spm sqlpatch_create qqqqqqqqqqq  'OPTIMIZER_FEATURES_ENABLE('"\'"'11.2.0.4'"\'"') INDEX_RS_ASC(@"SEL$1" "KONTRAHENTAS_T"@"SEL$1" "IDX_FUNCT_KODAS")'
$SP <<EOF >$LOGF
declare
  l_sql_id_trg char(13) := '$P2_';
  l_child_number_src number := 0;        -- v\$sql.child_number  
  l_hints varchar2(32767) := q'[$P3_]';
  l_sql_text clob;
begin
  -- удаление SQL патча, если такой есть 
  dbms_sqldiag.drop_sql_patch(name => 'patch_'||l_sql_id_trg, ignore => true);

  select sql_fulltext into l_sql_text from v\$sql where sql_id = l_sql_id_trg and rownum = 1;
--  select sql_text into l_sql_text from dba_hist_sqltext where sql_id = l_sql_id_trg and rownum = 1;
  
  -- создание SQL патча это PROCEDURE  in 11g
  sys.dbms_sqldiag_internal.i_create_patch(
      sql_text  => l_sql_text,
      hint_text => l_hints,
      name      => 'patch_'||l_sql_id_trg);
  dbms_output.put_line('patch_'||l_sql_id_trg||' was created');    
end;
/
EOF
;;
sqlpatch_list)
$SP <<EOF >$LOGF
set lines 230 long 10000
column name for a20
column sql_text for a140
column created for a20
column last_modified for a20
column status for a10
column force_matching for a5
select name, sql_text, cast(created as date) created, cast(last_modified as date) last_modified, status, force_matching from DBA_SQL_PATCHES order by last_modified;
EOF
;;
sqlpatch_alter)
P2_="$2"
P3_="$3"
$SP <<EOF >$LOGF
exec DBMS_SQLDIAG.ALTER_SQL_PATCH(name=>'$P2_', attribute_name=>'STATUS', value=>'$P3_');
EOF
;;
sqlpatch_drop)
P2_="$2"
$SP <<EOF >$LOGF
exec DBMS_SQLDIAG.DROP_SQL_PATCH(name=> '$P2_');
EOF
;;
report_sql_monitor)
  sql_id="$2"
  echo $name
$SP <<EOF >$LOGF
set lines 255
set echo off feed on veri off tab off pages 400
set long 1000000000 longc 1000000000
--PROMPT DBMS_SQLTUNE.report_sql_monitor(sql_id=>'$sql_id', report_level=>'all')
SELECT DBMS_SQLTUNE.report_sql_monitor(sql_id=>'$sql_id', report_level=>'all') from dual;
EOF
;;
*) :  ;;
esac
logf
}




trace()
{
P1_="$1"
P2_="$2"

case "$P1_" in
 db)  case "$P2_" in
         on) SQL1_="execute dbms_monitor.database_trace_enable(waits=>TRUE, binds=>TRUE, instance_name=> '&instance');" ;;
        off) SQL1_="execute dbms_monitor.database_trace_disable(instance_name=> '&instance');" ;;
      esac
      $SP <<EOF >$LOGF
        set lines 230 echo off feed off veri off tab off pages 60
        column instance_name new_value instance noprint
        select instance_name from v\$instance;
        prompt $SQL1_
        $SQL1_
        col TRACE_TYPE for a20
        col PRIMARY_ID for a20
        col QUALIFIER_ID1 for a20
        col QUALIFIER_ID2 for a20
        select * from dba_enabled_traces;
EOF
 ;;
 *)
SID_="$P1_"
SERIAL_="$P2_"
LEVEL_="$3"
	
if [ -n "$SID_" -a -n "$SERIAL_" -a -n "$LEVEL_" ]; then
 echo "SID: "$SID_"  SERIAL: "$SERIAL_"  LEVEL: "$LEVEL_

 case "$(db_version)" in
  8|9|10)   CMD1_="select u_dump.value || '/' || db_name.value || '_ora_' || v\$process.spid||nvl2(v\$process.traceid, '_' || v\$process.traceid, null )||'.trc' \"Trace File\" from v\$system_parameter u_dump cross join   v\$system_parameter db_name cross join v\$process join v\$session on v\$process.addr = v\$session.paddr where u_dump.name in ('user_dump_dest','background_dump_dest') and  db_name.name = 'db_name' and v\$session.sid=$SID_;"  ;;
  *)  #CMD1_="SELECT VALUE||'/'||'$ORACLE_SID'||'_ora_'||&&SPID||'.trc' \"Trace File\" FROM V\$DIAG_INFO WHERE NAME = 'Diag Trace';" 
      CMD1_="select tracefile from v\$process where spid=&&SPID;" ;;
 esac

$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60 timing off
exec sys.dbms_system.set_ev($SID_, $SERIAL_, 10046, $LEVEL_, '');

column spid format a9
column sid format 9999
column serial# format 99999
column username format a20
column status format a1
column osuser format a15
column machine format a20
column terminal format a20
column program format a30
column module format a26
select p.spid, s.sid, s.serial#, s.username, decode(s.status,'ACTIVE','A','INACTIVE','I','KILLED','K','?') status, s.osuser, s.machine, s.terminal, s.program,s.module
from v\$process p, v\$session s where p.addr = s.paddr and s.sid = $SID_ and s.serial# = $SERIAL_;

col SPID new_value SPID noprint
select p.spid SPID from v\$process p, v\$session s where p.addr = s.paddr and s.sid = $SID_ and s.serial# = $SERIAL_;

column "Trace File" for a150
$CMD1_
EOF
else
SQL_TRACE=" and s.SQL_TRACE='ENABLED' "
init_sql_sess
$SP <<EOF >$LOGF
prompt "Tracing is enabled in these sessions:"
$SQL_SESS
SELECT * FROM dba_enabled_traces;
EOF
fi
;;
esac
touch $LOGF
logf
}


kill_()
{
P1_="$1"
P2_="$2"
if [ -n "$P1_" -a -n "$P2_" ]; then
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
prompt alter system kill session '$P1_, $P2_' immediate;
alter system kill session '$P1_, $P2_' immediate;
EOF
fi
touch $LOGF
logf
}


exec_()
{
P1_="$1"
P2_="$2"
set -f
echo "ALL: "$ALL
$SP <<EOF >$LOGF
set lines 230 tab off echo on feed on veri on pages 60
prompt Execute SQL command: "$ALL"
$ALL
/
EOF
touch $LOGF
logf
}



alert()
{
NUM_="$1"
if [ -z "$NUM_" ]; then
 NUM_=100
fi

VALUEP=$($SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select substr(platform_name,1,instr(platform_name,' ',1,1)) from v$database;
END
)
VALUEP=$(tr -d '\r' <<< "$VALUEP")
DB_VER_=$(db_version)
case $VALUEP in
  Microsoft*) slash='\'
      case $DB_VER_ in
        8|9|10)  CMD1_="select value from v\$system_parameter where name='background_dump_dest';" ;;
        *)       CMD1_="select value from V\$DIAG_INFO where name='Diag Trace';" ;;
      esac ;;
  *)          slash='/'
      case $DB_VER_ in
         8|9|10)  CMD1_="select value||'$slash'||'alert_$ORACLE_SID.log' from v\$system_parameter where name='background_dump_dest';" ;;
         *)       CMD1_="select value||'$slash'||'alert_$ORACLE_SID.log' from V\$DIAG_INFO where name='Diag Trace';" ;;
      esac ;;
esac

case $VALUEP in
  Microsoft*) 
$SP <<EOF >$LOGF
set lines 220 timing off
set echo off feed off veri off tab off termout off pages 0
col value new_value value
col db_name new_value db_name
$CMD1_
select INSTANCE_NAME db_name from v\$instance;

create or replace directory alert_log_dir as '&&value';
drop TABLE alert_log_table ;
CREATE TABLE alert_log_table (TEXT VARCHAR2(400))
ORGANIZATION EXTERNAL (
 TYPE oracle_loader
 DEFAULT DIRECTORY alert_log_dir
 ACCESS PARAMETERS (
  RECORDS DELIMITED BY NEWLINE
  NOBADFILE NODISCARDFILE NOLOGFILE
  FIELDS TERMINATED BY '0x0A'
  MISSING FIELD VALUES ARE NULL)
 LOCATION ('alert_&&db_name..log'))
REJECT LIMIT unlimited;

WITH alert_log AS ( SELECT rownum as lineno, text FROM alert_log_table)
SELECT text FROM alert_log WHERE lineno > (SELECT count(*)-$NUM_ FROM alert_log_table)
ORDER BY lineno;
EOF
     ;;
  *) 
VALUE=$($SP <<END
set pagesize 0 feedback off verify off heading off echo off timing off
$CMD1_
END
)
VALUE=$(tr -d '\r' <<< "$VALUE")
echo $VALUE
tail -$NUM_ $VALUE
  ;;
esac
touch $LOGF
logf
}



report()
{
type_="$1"
TXT_="$2"
DAY_="$3"
HH1_="$4"
HH2_="$5"

DAY2_="$6"
HH21_="$7"
HH22_="$8"

SQL_ID_="$6"
# DB_VER_=$(db_version)

case "$TXT_" in
  text) EXT_='txt' ;;
  html) EXT_='html' ;;
  *)    EXT_='txt' ;;
esac

case "$type_" in 
 ash)  RPT_="define report_type = '$TXT_'; -- 'html' for HTML, 'text' for TXT
        define begin_time  = '$DAY_';  -- Can specify both absolute and relative times in minutes. '-60' - One hour ago. Look in ashrpti.sql for syntax.
        define duration    = '';     -- NULL defaults to  'till'  current time
        define report_name = '/tmp/ashrpt.$EXT_';
        @?/rdbms/admin/ashrpt.sql" ;;
 awr)  RPT_="define report_type='$TXT_';
        define num_days=7;
        col min_snap_id new_value min_snap_id
        col max_snap_id new_value max_snap_id
        select min(snap_id) min_snap_id, max(snap_id) max_snap_id from DBA_HIST_SNAPSHOT where trunc(end_interval_time) = to_date('$DAY_', 'dd/mm/yyyy') and to_number(to_char(end_interval_time,'HH24')) between $HH1_ and $HH2_ order by 1;
        define begin_snap=&&min_snap_id
        define end_snap=&&max_snap_id
        define report_name='/tmp/awrrpt.$EXT_'
        @?/rdbms/admin/awrrpt.sql" ;;
 awrdd)  RPT_="define report_type='$TXT_';
        define num_days=7;
        define num_days2=7;
        col min_snap_id new_value min_snap_id
        col max_snap_id new_value max_snap_id
        select min(snap_id) min_snap_id, max(snap_id) max_snap_id from DBA_HIST_SNAPSHOT where trunc(end_interval_time) = to_date('$DAY_', 'dd/mm/yyyy') and to_number(to_char(end_interval_time,'HH24')) between $HH1_ and $HH2_ order by 1;
        define begin_snap=&&min_snap_id
        define end_snap=&&max_snap_id
	select min(snap_id) min_snap_id, max(snap_id) max_snap_id from DBA_HIST_SNAPSHOT where trunc(end_interval_time) = to_date('$DAY2_', 'dd/mm/yyyy') and to_number(to_char(end_interval_time,'HH24')) between $HH21_ and $HH22_ order by 1;
        define begin_snap2=&&min_snap_id
        define end_snap2=&&max_snap_id
	define report_name='/tmp/awrrpt.$EXT_'
        column dbid new_value dbid noprint
        select dbid from v\$database;
        define dbid2 = &dbid 
        column instance_number new_value inst_num noprint
        select instance_number from v\$instance;
        define inst_num2 = &inst_num
        @?/rdbms/admin/awrddrpi.sql" ;;
 awrsql)  RPT_="define report_type='$TXT_';
        define num_days=7;
        col min_snap_id new_value min_snap_id
        col max_snap_id new_value max_snap_id
        select min(snap_id) min_snap_id, max(snap_id) max_snap_id from DBA_HIST_SNAPSHOT where trunc(end_interval_time) = to_date('$DAY_', 'dd/mm/yyyy') and to_number(to_char(end_interval_time,'HH24')) between $HH1_ and $HH2_ order by 1;
        define begin_snap=&&min_snap_id
        define end_snap=&&max_snap_id
        define sql_id=$SQL_ID_
        define report_name='/tmp/awrrpt.$EXT_'
        @?/rdbms/admin/awrsqrpt.sql " ;;
 addm)  RPT_="define num_days=7;
        col min_snap_id new_value min_snap_id
        col max_snap_id new_value max_snap_id
        select min(snap_id) min_snap_id, max(snap_id) max_snap_id from DBA_HIST_SNAPSHOT where trunc(end_interval_time) = to_date('$DAY_', 'dd/mm/yyyy') and to_number(to_char(end_interval_time,'HH24')) between $HH1_ and $HH2_ order by 1;
        define begin_snap=&&min_snap_id
        define end_snap=&&max_snap_id
        define report_name='/tmp/addmrpt.txt'
        @?/rdbms/admin/addmrpt.sql" ;;
   *)  RPT_="PROMPT UNKNOWN TYPE OF REPORT" ;;
esac

$SP <<EOF >$LOGF
$RPT_
EOF

touch $LOGF
logf
}



corrupt()
{
P1_="$1"
P2_="$2"
P3_="$3"
DB_VER=$(db_version)

shopt -s nocasematch
case "$P1_" in
rowid)
$SP <<EOF >>$LOGF
set lines 230 pages 100
col rowid_ for a20
col object for a30
col FILE_NAME for a90
select '$P2_' as rowid_,
 dbms_rowid.rowid_object('$P2_') as objid, (select owner||'.'|| object_name from dba_objects where object_id=dbms_rowid.rowid_object('$P2_') ) as object,
 dbms_rowid.rowid_relative_fno('$P2_') as relfilenum, (select file_name from dba_data_files where  file_id=dbms_rowid.rowid_relative_fno('$P2_') ) as file_name,
 dbms_rowid.rowid_block_number('$P2_') as blocknum,
 dbms_rowid.rowid_row_number('$P2_') as rowslot
 from dual;
EOF
;;
dba)
$SP <<EOF >>$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column file new_value file for 9999
column block new_value block for 999999999
select dbms_utility.data_block_address_file($P2_) "file", dbms_utility.data_block_address_block($P2_) "block" from dual;
column owner for a15
column segment_name for a30
column PARTITION_NAME for a20
column segment_type for a10
column tablespace_name for a22
select * from dba_extents where file_id=&&file and &&block between block_id and block_id+blocks-1;
EOF
;;
fb)
$SP <<EOF >>$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column owner for a15
column segment_name for a30
column PARTITION_NAME for a20
column segment_type for a10
column tablespace_name for a22
ttitle left "View dba_extents"
select * from dba_extents where file_id=$P2_ and $P3_ between block_id and block_id+blocks-1;
ttitle off
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column CORRUPTION_CHANGE# for 999999999999999
prompt  View v\$database_block_corruption
select * from v\$database_block_corruption order by file#, block#;
EOF
 case "$DB_VER" in
 8|9|10|11) : ;;
 *)
$SP <<EOF >>$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column FILE# for 9999
column NONLOGGED_START_CHANGE# for 999999999999999
column NONLOGGED_END_CHANGE# for 999999999999999
column RESETLOGS_CHANGE# for 999999999999999
column OBJECT# for a12
prompt View v\$nonlogged_block
select * from v\$nonlogged_block order by file#,block#;
EOF
;;
 esac
;;
esac
logf
}

export TERM=xterm
U=$(awk -F_ '{print $1}' <<< $(uname))
case "$U" in
 CYGWIN) echo -n "DB="$sid" ver="$TPIVER"  "$(date +%d/%m/%y"-"%H:%M:%S)"  "$ls2"  " ;;
 AIX)    echo -n "DB="$sid" ver="$TPIVER"  "$(date +%d/%m/%y"-"%H:%M:%S)"  "$ls2"  " ;;
 *)       red=$(tput setaf 1)
	 green=$(tput setaf 2)
	 yellow=$(tput setaf 3)
	 blue=$(tput setaf 4)
	 magneta=$(tput setaf 5)
	 cyan=$(tput setaf 6)
	 reset=$(tput sgr0)
	 echo -n ${green}"DB="$sid" ver="$TPIVER"  "$(date +%d/%m/%y"-"%H:%M:%S)"  "$ls2"  "
 ;;
esac


# echo "ID: "$ID
case "$ID" in
""|a|k|in|access)   echo $a__ ${reset}; active_sessions $ALL ;;
p|ph|services|dir)  echo $p__ ", parameters like: "$ALL ${reset}; parameters $ALL ;;
db)        shift; ALL=$*; echo $db__ ${reset}; db $ALL ;;
lock)      shift; ALL=$*; echo $lock__ ${reset}; lock $ALL ;;
audit)     shift; ALL=$*; echo $audit__ ${reset}; audit $ALL ;;
health)    shift; ALL=$*; echo $health__ ${reset}; health $ALL ;;
oratop)    shift; ALL=$*; echo $oratop__ ${reset}; oratop $ALL ;;
sga)       shift; ALL=$*; echo $sga__ ${reset}; sga $ALL ;;
pga)       shift; ALL=$*; echo $pga__ ${reset}; pga $ALL ;;
size)      shift; ALL=$*; echo $size__ ${reset}; size $ALL ;;
arch)      shift; ALL=$*; echo $arch__ ${reset}; arch $ALL ;;
tbs)       shift; ALL=$*; echo $size__ ${reset}; tbs $ALL ;;
df)        shift; ALL=$*; echo $size__ ${reset}; df $ALL ;;
maxseg)    shift; ALL=$*; echo $size__ ", (TABLESPACE NAME = '"$ALL"'):" ${reset}; maxseg $ALL ;;
fra)       shift; ALL=$*; echo $size__ ${reset}; fra $ALL ;;
redo)      shift; ALL=$*; echo $redo__ ${reset}; redo $ALL ;;
undo)      shift; ALL=$*; echo $undo__ ${reset}; undo $ALL ;;
sesstat)   shift; ALL=$*; echo $sesstat__ ", STATNAME = " $ALL ${reset}; sesstat $ALL ;;
topseg)    shift; ALL=$*; echo $topseg__", SEGMENT_NAME = " $ALL ${reset}; topseg $ALL ;;
o)         shift; ALL=$*; echo $o__ ", ALL  = " $ALL ${reset}; object $ALL ;;
s)         shift; ALL=$*; echo $s__ ", SEGMENT_NAME = " $ALL ${reset}; segment $ALL ;;
t)         shift; ALL=$*; echo $t__ ", PARAMETERS = " $ALL ${reset}; table $ALL ;;
i)         shift; ALL=$*; echo $i__ ", PARAMETERS = " $ALL ${reset}; index $ALL ;;
l)         shift; ALL=$*; echo $l__ ", LOB_NAME = " $ALL ${reset}; lob $ALL ;;
c)         shift; ALL=$*; echo $c__ ", PARAMETERS = " $ALL ${reset}; constraint $ALL ;;
u)         shift; ALL=$*; echo $u__ ", PARAMETERS = " $ALL ${reset}; user $ALL ;;
r)         shift; ALL=$*; echo $r__ ", PARAMETERS = " $ALL ${reset}; role $ALL ;;
trg)       shift; ALL=$*; echo $trg__ $ALL ${reset}; trigger $ALL ;;
profile)   shift; ALL=$*; echo $profile__  ${reset}; profile $ALL ;;
links)     shift; ALL=$*; echo $links__ ${reset} ; links $ALL ;;
latch)     shift; ALL=$*; echo $latch__ ${reset} ; latch $ALL ;;
bind)      shift; ALL=$*; echo $bind__ ", SQL like " $ALL ${reset}; bind $ALL ;;
pipe)      shift; ALL=$*; echo $pipe__ ", PIPE = " $ALL ${reset}; pipe $ALL ;;
longops)   shift; ALL=$*; echo $longops__ ${reset}; longops $ALL ;;
scheduler) shift; ALL=$*; echo $scheduler__ ${reset}; scheduler $ALL ;;
job)       shift; ALL=$*; echo $job__ ${reset}; job $ALL ;;
rman)      shift; ALL=$*; echo $rman__ ${reset}; rman $ALL ;;
get_ddl)   shift; ALL=$*; echo $get_ddl__ ", for: "$ALL ${reset} ; get_ddl $ALL ;;
trace)     shift; ALL=$*; echo $trace__ ${reset}; trace $ALL ;;
kill)      shift; ALL=$*; echo $kill__ ${reset}; kill_ $ALL ;;
exec)      shift; ALL=$*; echo $exec__ ${reset}; exec_ $ALL ;;
alert)     shift; ALL=$*; echo $alert__ ${reset}; alert $ALL ;;
report)    shift; ALL=$*; echo $report__ ${reset}; report $ALL ; echo $report__;;
corrupt)   shift; ALL=$*; echo $corrupt__ ${reset}; corrupt $ALL ;;
sql)       shift; ALL=$*; echo $sql__ ", for: "$ALL  ${reset}; psql $ALL  ;;
ash)       shift; ALL=$*; echo $ash__ ", for: "$ALL  ${reset}; ash $ALL ; echo $ash__ ;;
dhash)     shift; ALL=$*; echo $dhash__ ", for: "$ALL ${reset}; dhash $ALL ; echo $dhash__ ;;
spm)       shift; ALL=$*; echo $spm__ ", Now: "$ALL ${reset}  ; spm $ALL ; echo $spm__ ;;
*)         echo $a__  "process_info"${reset}; process_info $ALL ;; 
esac

