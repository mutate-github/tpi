#!/bin/sh
set -f
# version 01.03.2023 by Talgat Mukhametshin dba.almaty@gmail.com  last version: https://github.com/mutate-github/tpi
# echo "tpi:"$* 
sid=$1

case "$sid" in
cft*|kik*|bd*|prov*)        . ~/db12kik.env ;;
EPS*|creditc)               . ~/db12.env ;;
KIKOPDR)                    . ~/db11.env ;;
jet|ja)                     . /etc/profile.ora ;;
aisutf*|unit*)              . ~/.ora_env ;;
askona*|aixtdb*|sbaskona)   . ~/.profile ;;
egais*|GOLD506*)            . ~/.bashrc ;;
unc*)                       . ~/${sid}_setenv.sh ;;
goldwhs)                    . ~/.bash_profile ;;
*) #        if [ -f ~/.bashrc ]; then . ~/.bashrc ; fi
   #        if [ -f ~/.bash_profile ]; then . ~/.bash_profile ; fi
   #        if [ -f ~/.profile ]; then . ~/.profile ; fi 
   case `uname | awk -F_ '{print $1}'` in
      Linux)  if [ -f ~/.bash_profile ]; then . ~/.bash_profile ; fi 
              rc=`find . -maxdepth 1 -name "${sid}_setenv.sh" -print -quit`
              if [ -n "$rc" ]; then . ~/${sid}_setenv.sh ; fi
	      ;;
      AIX)    if [ -f ~/.profile ]; then . ~/.profile ; fi
              if [ -f ~/.bashrc ]; then . ~/.bashrc ; fi 
              ;;
      *) : ;;
   esac
;;
esac  > /dev/null 2>&1


init_msg()
{
  a__="a - all sessions  | [access OBJECT] - active sessions which accessing OBJECT | SPID\SID\SERIAL# [p] [parameter_name] - session param info from V\$SES_OPTIMIZER_ENV by [parameter_name]" 
  p__="p | ph [PARAMETER] [FALSE] | services | dir - instance parameters or hidden parameters, [FALSE] - only changed parameters, v\$services, dba_directories" 
  db__="db [ nls|option|properties ] - v\$instance, v\$database, dba_registry, dba_registry_sqlpatch, nls_database_paramters, v\$option, database_properties information" 
  health__="health [cr | hot] - Database health parameters (HWM sessions, Hit Ratio / Get Misses cache, System Events Waits, Consistent Read buffers in SGA | Hot buffers)"
  oratop__="oratop [ h ] - Database and Instance parameters, h - history V\$SYSMETRIC_HISTORY V\$ACTIVE_SESSION_HISTORY"
  sga__="sga - SGA information" 
  pga__="pga - PGA sessions information"
  size__="size [days] [ tbs [free] | temp | df [io|usage|lastseg[TBS]] | maxseg TBS | fra | grows (days) ] - Size of DB+archl (7 def), tablespaces, datafiles (HWM in DF+script), maxseg in all DB\TBS, FRA info + db_recovery_file_dest usage" 
  arch__="arch - archivelog, V\$LOG V\$ARCHIVE_DEST V\$ARCHIVE_DEST_STATUS GV\$MANAGED_STANDBY V\$STANDBY_LOG information"
  redo__="redo [logs] - redo information" 
  undo__="undo [recovery] - undo active transaction information, recovery information" 
  sesstat__="sesstat [ list | sess SESS_ID [STATNAME] | STATNAME ] - sesstat information, where 'list' - STATISTIC NAMES, sess SESS_ID - sesstat for session, STATNAME - name particular of STATISTIC NAME" 
  topseg__="topseg - top 20 segments statistics information from V\$SEGMENT_STATISTICS" 
  o__="o OBJECT_NAME | OBJECT_ID - dba_objects information" 
  s__="s SEGMENT_NAME [OWNER] - dba_segments information" 
  t__="t [part] TABLE_NAME [OWNER] - dba_tables, dba_part_tables, dba_tab_partitions, dba_tab_subpartitions information" 
  i__="i [part] INDEX_NAME|TABLE_NAME [OWNER] - dba_indexes, dba_part_indexes, dba_ind_partitions, dba_ind_subpartitions information" 
  l__="l LOB_NAME - dba_lobs information" 
  c__="c [ CONSTRAINT_NAME | T TABLE_NAME | PK PRIMARY_KEY | FK (TABLE_NAME [OWNER] | %) ]  - dba_constraints, dba_cons_columns information, PK - Who refs to the PK, FK - Tables with non-indexed foreign keys" 
  u__="u USERNAME - dba_users information"
  invalid__="invalid [OWNER] - invalid objects" 
  profile__="profile [PROFILE] - profiles information"
  links__="links - links information"
  latch__="latch - latch information"
  lock__="lock [lib | obj OBJECT_NAME] - blocking locks information, lib - library lock information"
  bind__="bind [SQL] - sql not using bind variable information"
  pipe__="pipe [PIPE_NAME] - pipes information, read PIPE_NAME" 
  longops__="longops [SID | MESSAGE | rman] - active session longops for SID or MESSAGE or rman backup elapsed time" 
  scheduler__="scheduler [JOB_NAME | run JOB_NAME [hours] | log] - dba_scheduler_jobs information, log | run JOB_NAME [hours] - dba_scheduler_job_log | dba_scheduler_job_run_details for JOB_NAME in last [hours]" 
  job__="job [OWNER] - dba_jobs information" 
  get_ddl__="get_ddl TYPE OBJECT (OWNER) - dbms_metadata.get_ddl extract dml, OBJECT - may be % or %mask%"
  trace__="trace [SID SERIAL LEVEL] [db on|off] - Trace for session, Level: 0-Disable, 1-Enable, 4-Enable with Binds, 8-Enable with Waits, 12-4+8, Trace all db sessions: on \ off"
  alert__="alert [num] - tail -num alert_[sid].log, default num = 100"
  report__="report [ash text|html -60] -for last hour, [awr text|html DD/MM/YYYY HH24_begin HH24_end], [awrsql text|html DD/MM/YYYY HH24_begin HH24_end sql_id], [addm text DD/MM/YYYY HH24_begin HH24_end] - oracle reports"
  corrupt__="corrupt [DBA (number)] - Find DB Object by DBA number,  [FB (file) (block)] - Find DB Object in dba_extents by file/block, v\$database_block_corruption v\$nonlogged_block information"
  sql__="sql SQL_ID | SQLTEXT [plan SQL_ID] [sqlstat SQL_ID] - Find out sql_id by SQLTEXT\SQL_ID from V\$SQL, plan from VSQL_PLAN by sql_id, sqlstat from V\$SQLSTAT by sql_id"
  ash__="ash [ event [all] (EventName) | sess (SID SERIAL# [all|nosqlid] | SQL_ID) | where [FIELD CONDITION] | sql (SQL_ID|SQL_TEXT) | plan SQL_ID [format display plan] | sqlstat SQL_ID | temp [sizeMb] ] - Top Event, Sessions, SQL V\$ACTIVE_SESSION_HISTORY in last time"
  dhash__="dhash [dd/mm/yyyy+HH24+hours - def3h] [ event [all] (EventName) | sess (SID SERIAL# [all|nosqlid] | SQL_ID) | where [FIELD CONDITION] | sql (SQL_ID|SQL_TEXT) | plan SQL_ID [fmt display plan] | sqlstat SQL_ID | growseg [TBS] [SEGMENT] | segstat [OBJ%TYPE] [SIZE] | temp [sizeMb] ] - Top Events, Sessions, SQL from DBA_HIST_ACTIVE_SESS_HISTORY"
  spm__="spm [days def7 - baselines] [ blplan SQL_HANDLE (PLAN_NAME) | blexec [count] | bllpfcc SQL_ID PLAN_HASH_VALUE [SQL_HANDLE] | bllpfawr SQL_ID PLAN_HASH_VALUE MIN_SNAP_ID MAX_SNAP_ID | blchattr SQL_HANDLE PLAN_NAME ATTR VALUE | blchplan NEW_SQL_ID NEW_PHV OLD_SQLSET_NAME | sqlset_list SQLSET_NAME OWNER | sqlset_plan SQLSET_NAME SQL_ID [PHV] | sqlset_drop SQLSET_NAME | bldrop SQL_HANDLE (PLAN_NAME) | usage SQL_ID | sqltune [SQL_ID | awr SQL_ID begin_snap end_snap]  | sqltune_report TASK_NAME | sqltune_accept TASK_NAME | sqltune_create_plan_bl TASK_NAME OWNER PLAN_HASH_VALUE | sqltune_list [TASK_NAME] [cnt] | sqltune_drop TASK_NAME | sql_profiles | sql_profile_chattr TASK_NAME ATTR VALUE  | sql_profile_drop NAME | report_sql_monitor SQL_ID ]"
}

init_msg

if [ -z "$sid" ]; then
  env | grep ORA
  ps -ef | grep [p]mon
  echo "Usage: $0 <DBSID> sess_id [p|ph <param>] | a(order by u m o l w) | lock | p  . | db [nls|option|properties] | health | oratop [h] | sga | pga | size [days] [ tbs [free] | temp | df [io|usage|lastseg [TABLESPACE]]|maxseg [TABLESPACE]|fra] | arch | redo [logs] | undo [recovery] | sesstat [STATNAME] | topseg | o . | s . | t . | i . | l . | c . | u . | invalid | profile | links | latch | bind [SQL] | pipe | longops [MESSAGE] [rman] | scheduler | job [OWNER] | get_ddl TYPE OBJECT OWNER | trace | alert | report ash/awr | corrupt [DBA (number)] [FB (file) (block)] | sql | ash | dhash | spm"
  echo -e $a__"\n"$p__"\n"$db__"\n"$health__"\n"$oratop__"\n"$sga__"\n"$pga__"\n"$size__"\n"$arch__"\n"$redo__"\n"$undo__"\n"$sesstat__"\n"$topseg__"\n"$o__"\n"$s__"\n"$t__"\n"$i__"\n"$l__"\n"$c__"\n"$u__"\n"$invalid__"\n"$profile__"\n"$links__"\n"$latch__"\n"$lock__"\n"$bind__"\n"$pipe__"\n"$longops__"\n"$scheduler__"\n"$job__"\n"$get_ddl__"\n"$trace__"\n"$alert__"\n"$report__"\n"$corrupt__"\n"$sql__"\n"$ash__"\n"$dhash__"\n"$spm__"\n"
  exit
  echo "NOT EXIT"
fi

ORACLE_SID=$sid
export ORACLE_SID
#NLS_LANG=AMERICAN_AMERICA.CL8MSWIN1251
#export NLS_LANG
shift
ID="$1"
# ALL=$*
# ALL=`echo $* | tr '~' '$'`
ALL=$(echo $*)
# echo "tpi ALL: "$ALL

#for tnsnames connection through .tpi_login file
#format .tpi_login file: sid username/password@tns_alias
path_to_tpi=`dirname $0`
#echo "path_to_tpi: "$path_to_tpi
login_str=`awk '/^'$sid' /{print substr($0,index($0,$2))}' $path_to_tpi/.tpi_login 2>/dev/null`
#echo "login_str: "$login_str

if [ -n "$login_str" ]; then
  SP="eval sqlplus -S $login_str"
else 
  SP="eval sqlplus -S '/ as sysdba'"
fi

cd /tmp

logf()
{
cat $LOGF  | tr -d \~
rm -f $LOGF
#rm -f $LOGINSQL >/dev/null 2>&1
}

is_number()
{
if [ -z "$1" ]; then
 echo 0
 return
fi
case "$1"  in
  *[!0-9]*)  echo 0 ;;
  *)         echo 1 ;;
esac
}

db_version()
{
VALUE=`$SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select substr(version,1,instr(version,'.')-1) from v$instance where rownum=1;
END`
echo $VALUE | tr -d '\r'
# return $VALUE
}

db_is_open()
{
VALUE=`$SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select status from v$instance where rownum=1;
END`
echo $VALUE | tr -d '\r'
}

case $(db_is_open) in
OPEN)
NLS_VALUE=`$SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select case when value like '%UTF%' then value else 'CL8MSWIN1251' end from nls_database_parameters where parameter='NLS_CHARACTERSET';
END`
;;
*) : ;;
esac

NLS_VALUE=`echo $NLS_VALUE | tr -d '\r'`
NLS_LANG=AMERICAN_AMERICA.$NLS_VALUE
# NLS_LANG=AMERICAN_AMERICA.AL32UTF8
export NLS_LANG
WINCP="CL8MSWIN1251"


# SP="eval sqlplus -S '/ as sysdba'"
# SP="eval sqlplus -S sys/sys@$sid as sysdba"
LOGF="/tmp/tpilog_$$.txt"

export ORACLE_PATH=/tmp
LOGINSQL=/tmp/login.sql
cat << CREATELOGINSQL > $LOGINSQL
set echo off
set timing off
set feedback off
/*
begin
 case 
   when dbms_db_version.version in  ('9','10') then null;
   when dbms_db_version.version = 11 then execute immediate 'alter session set "_optimizer_use_feedback"=false';
   when dbms_db_version.version = 12 then  
      execute immediate 'alter session set optimizer_adaptive_features=false';
      execute immediate 'alter session set optimizer_adaptive_plans=false';
      execute immediate 'alter session set optimizer_adaptive_statistics=false';
      execute immediate 'alter session set "_optimizer_use_feedback"=false';
   else null ;
 end case;
 exception when others then raise_application_error(sqlcode, sqlerrm(sqlcode));
end;
/
*/
alter session set statistics_level=basic;
alter session set nls_date_format='dd/mm/yyyy hh24:mi:ss';
--alter session set optimizer_features_enable = '10.2.0.4';
--alter session set optimizer_index_cost_adj = 100;
--alter session set optimizer_index_caching  = 10;
--alter session set optimizer_mode  = 'FIRST_ROWS';
--alter session set optimizer_max_permutations = 1000;
--alter session set optimizer_dynamic_sampling = 0;
--alter session set "_optimizer_ignore_hints"=true;
exec dbms_application_info.set_module('tpi script','oracle');
set timing on
CREATELOGINSQL



active_sessions()
{
P1_=$1 #; echo "P1_: "$P1_
P2_=$2 #; echo "P2_: "$P2_

case "$P1_" in
 access) access_p1_str=",a.owner||'.'||a.object||' '||a.type oot" ; access_p2_str=",v\$access a" ; access_p3_str="and s.sid=a.sid and a.OBJECT = '$P2_'" ; P1_="a" ;;
 *)      : ;;
esac

case "$(db_version)" in
 9|10) SQL_ID_=""
    SQLACTION_="s.action pma,"
    SQLCMD1_=""
    SQLCMD2_=""
    SQLCMD3_=""
    ;;
 *) SQL_ID_="DECODE (s.plsql_subprogram_id, NULL, s.sql_id, NULL) sql_id,"
    SQLACTION_="CASE when '$NLS_VALUE'='$WINCP' then s.action when replace(REGEXP_REPLACE(convert(UNISTR(ASCIISTR(s.action)), '$NLS_VALUE','$WINCP'), '[-*\/_0-9a-zA-Z]', ''), ' ') is null then UTL_RAW.CAST_TO_VARCHAR2(UTL_RAW.CONVERT(UTL_RAW.CAST_TO_RAW(nvl(s.action,' ')),'AMERICAN_AMERICA.$NLS_VALUE', 'AMERICAN_AMERICA.$WINCP')) else s.action end pma,"
    SQLCMD1_="c.command_name, "
    SQLCMD2_=", v\$sqlcommand c "
    SQLCMD3_="and s.command = c.command_type "
    ;;
esac


$SP <<EOF >$LOGF
alter session set "_optimizer_cartesian_enabled"=false;
set lines 300 pages 1000
set echo off feed off veri off tab off
col spid for a8
col sid for 99999
col serial# for 999999
col username for a20 truncated
col osuser for a17 truncated
col machine for a17 truncated
col pma for a60 heading "PROGRAM / MODULE / ACTION" truncated
col pgau for 99999
col logon_time for a11 heading "LOGON"
col last_call_et for 999999 heading "LAST"
col status for a1 heading "S" truncated
col command_name for a6 heading "CMD" truncated
col sql_id for a13
col event for a27 truncated
col sw for 999999
col oot for a40 heading "ACCESS OBJECT" truncated
SELECT /*+ OPT_PARAM('_optimizer_adaptive_plans' 'false') */   /*+ NO_MONITOR */ 
       p.spid, s.sid, s.serial#, /* s.audsid,*/ s.username,
       s.osuser,
       replace(s.machine,CHR(0),'') machine,
       s.program||' / '||s.module||' / '|| $SQLACTION_
       trunc(p.pga_used_mem/1024/1024) pgau, $SQLCMD1_ $SQL_ID_
       w.event /*,w.p1text,w.p1,w.p2text,w.p2*/,
       case when w.seconds_in_wait>8640000 then w.seconds_in_wait/60/60/24*-1 else w.seconds_in_wait/60/60 end sw,
       to_char(s.logon_time,'dd/mm hh24:mi') logon_time,
       case when s.last_call_et>864000 then s.last_call_et/60/60/24*-1 else s.last_call_et end last_call_et, s.status  $access_p1_str
   FROM v\$session s, v\$process p, v\$session_wait w $SQLCMD2_  $access_p2_str
   WHERE p.addr = s.paddr $access_p3_str $SQLCMD3_
       AND s.sid=w.sid AND p.spid IS NOT NULL AND s.type <> 'BACKGROUND' AND s.username IS NOT NULL
       AND (s.status = 'ACTIVE' or nvl('$P1_',' ') = 'a')
   order by to_char(s.last_call_et,'0000000.00') desc, s.osuser,w.event, to_char(s.logon_time,'hh24:mi') ;
EOF
logf
}


process_info()
{
CODE11_="
  if (s.sql_id is not null) then
    dbms_output.put_line(chr(126)||'Explain plan from dbms_xplan.display_cursor:');
    for c1 in (select plan_table_output from   table(dbms_xplan.display_cursor(s.sql_id,s.sql_child_number,'Typical +PEEKED_BINDS')) ) loop
      dbms_output.put_line(chr(126)||chr(32)||c1.plan_table_output);
    end loop;
  end if;
"
CODE11_2_="
-- Binds for verison 10g and above
-- for c1 in ( select distinct sql_id, name, VALUE_STRING from V\$SQL_BIND_CAPTURE where sql_id=s.sql_id and hash_value=s.sql_hash_value and child_number=s.sql_child_number order by 2 ) loop
--    dbms_output.put_line(chr(126)||'Bind variables: v\$sql_bind_capture     NAME: '|| c1.name ||'  VALUE: '||c1.VALUE_STRING);
-- end loop;
"
CODE9_="
  dbms_output.put_line(chr(126)||'Current SQL statement:');
  for c1 in ( select * from sys.v_\$sqltext
              where HASH_VALUE = s.sql_hash_value order by piece) loop
    dbms_output.put_line(chr(126)||chr(32)||c1.sql_text);
  end loop;

  for c1 in ( select * from sys.v_\$sqltext
              where HASH_VALUE = s.sql_hash_value and rownum=1) loop
    dbms_output.put_line(chr(126)||'HASH_VALUE: '||c1.hash_value);
  end loop;
"
CODE9_2_="
  execute immediate 'create or replace view dynamic_plan_table as select rawtohex(address) || ''_'' || child_number statement_id, sysdate timestamp, operation, options, object_node,
  object_owner, object_name, 0 object_instance, optimizer,  search_columns, id, parent_id, position, cost, cardinality, bytes, other_tag, partition_start,
  partition_stop, partition_id, other, distribution, cpu_cost, io_cost, temp_space, access_predicates, filter_predicates from v\$sql_plan';
begin
  SELECT GV\$Session.SQL_Address||'_'|| To_Char(GV\$SQL.Child_Number) into STR_ FROM GV\$Session, X\$KGLLK, GV\$SQL
  WHERE  X\$KGLLK.Inst_Id = GV\$Session.Inst_Id AND X\$KGLLK.KGLLKSNM = GV\$Session.SId AND X\$KGLLK.KGLHDPAR = GV\$Session.SQL_Address AND X\$KGLLK.KGLNAHSH = GV\$Session.SQL_Hash_Value
  AND X\$KGLLK.KGLHDNSP = 0 AND X\$KGLLK.KGLHDPAR != X\$KGLLK.KGLLKHDL AND GV\$SQL.Address = X\$KGLLK.KGLHDPAR AND GV\$SQL.Hash_Value = X\$KGLLK.KGLNAHSH AND GV\$SQL.Child_Address = X\$KGLLK.KGLLKHDL AND GV\$Session.SID=s.sid;
exception when no_data_found THEN null;
 return;
end;
  dbms_output.put_line(chr(126)||'Explain plan from dbms_xplan.display for: s.sql_address=' || s.sql_address||' , s.sql_hash_value=' || s.sql_hash_value || ' ,  SQLADDR_CHILD: '||STR_);
  if (s.sql_hash_value is not null) then
    for c1 in (select /*+ RULE */ plan_table_output from table(dbms_xplan.display('dynamic_plan_table', STR_, 'serial')) ) loop
      dbms_output.put_line(chr(126)||chr(32)||c1.plan_table_output);
    end loop;
  end if;
"

case "$(db_version)" in
8)  echo "Oracle Version 8..." ;;
9)  CMD1_=$CODE9_ 
    CMD2_=$CODE9_2_ ;;
*)  CMD1_=$CODE11_ 
    CMD2_=$CODE11_2_;;
esac

P1_=`echo $ALL | awk '{print $1}' | tr '[:lower:]' '[:upper:]'`
P2_=`echo $ALL | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
P3_=`echo $ALL | awk '{print $3}' | tr '[:lower:]' '[:upper:]'`
case "$P2_" in
P)
$SP <<EOF >$LOGF
set serveroutput on size 500000
set echo off feed off veri off tab off
set lines 230
set pages 100
ttitle left "Session parameters  V\$SES_OPTIMIZER_ENV :"
column NAME for a40 
column SQL_FEATURE for a25 
select SID,ID,NAME,SQL_FEATURE,ISDEFAULT,VALUE from V\$SES_OPTIMIZER_ENV where sid=$P1_ and upper(name) like '%$P3_%';
EOF
;;
*)
$SP <<EOF >$LOGF
set serveroutput on size 500000
set echo off feed off veri off tab off
set lines 230
DECLARE
  id varchar2(20);
  STR_ varchar2(20);
  v_sid number;
  s sys.v_\$session%ROWTYPE;
  p sys.v_\$process%ROWTYPE;
BEGIN
  select '$ID' into id from dual;
  begin
    select s.sid into v_sid
      from sys.v_\$process p, sys.v_\$session s
     where p.addr = s.paddr
       and (p.spid = id or s.sid = id /* or s.serial# = id or s.audsid = id */ ) and rownum=1;
  exception
    when too_many_rows then
      dbms_output.put_line(chr(126)||'There are more than one session !!! Set parameter OSID:');
      for i in (select p.spid, s.audsid, s.serial#, s.username, s.status, s.machine
                  from   sys.v_\$process p, sys.v_\$session s
                 where p.addr = s.paddr
                   and (p.spid = id or s.sid = id or s.serial# = id or s.audsid = id))
      loop
        dbms_output.put_line(chr(126)||i.spid||' / '||i.audsid||' / '||i.serial#||' => '||i.username||' '||i.status||' '||i.machine);
      end loop;
      return;
    when no_data_found then
      dbms_output.put_line(chr(126)||'Unable to find process id '||id||'!!!');
      return;
    when others then
      dbms_output.put_line(chr(126)||sqlerrm);
      return;
  end;

  select * into s from sys.v_\$session where sid  = v_sid;
  select * into p from sys.v_\$process where addr = s.paddr;

  dbms_output.put_line(chr(126)||'===============================================================================');
  dbms_output.put_line(chr(126)||'SID/Serial                : '|| s.sid||'  '||s.serial#);
  dbms_output.put_line(chr(126)||'AUDSID                    : '|| s.audsid);
  dbms_output.put_line(chr(126)||'Foreground                : '|| 'PID: '||s.process);
  dbms_output.put_line(chr(126)||'Shadow                    : '|| 'PID: '||p.spid||' - '||p.program || '  Parent SID: ' || to_number(substr(to_char(s.ownerid, 'XXXXXXXX'),length(to_char(s.ownerid, 'XXXXXXXX'))-3 ),'XXXX') ); 
  dbms_output.put_line(chr(126)||'Terminal                  : '|| s.terminal || '/ ' || p.terminal);
  dbms_output.put_line(chr(126)||'OS User                   : '|| s.osuser||' on '||s.machine);
  dbms_output.put_line(chr(126)||'Oracle User               : '|| s.username);
  dbms_output.put_line(chr(126)||'Program / Module / Action : '|| s.program||' / '||s.module||' / '||s.action);
  dbms_output.put_line(chr(126)||'Status Flags              : '|| s.status||' '||s.server||' '||s.type);
  dbms_output.put_line(chr(126)||'Tran Active               : '|| nvl(s.taddr, 'NONE'));
  dbms_output.put_line(chr(126)||'Login Time                : '|| to_char(s.logon_time, 'Dy HH24:MI:SS'));
  dbms_output.put_line(chr(126)||'Last Call                 : '|| to_char(sysdate-(s.last_call_et/60/60/24), 'Dy HH24:MI:SS') || ' - ' || to_char(s.last_call_et/60, '9999990.0') || ' min');
  dbms_output.put_line(chr(126)||'Lock/ Latch               : '|| nvl(s.lockwait, 'NONE')||'/ '||nvl(p.latchwait, 'NONE'));
  dbms_output.put_line(chr(126)||'Latch Spin                : '|| nvl(p.latchspin, 'NONE'));

  dbms_output.put_line(chr(126)||'Session Waits:');
--  for c1 in ( select * from sys.v_\$session_wait where sid = s.sid) loop
--    dbms_output.put_line(chr(126)||chr(32)||c1.state||': '||c1.event||', '||c1.p1text||'='||c1.p1||', '||c1.p2text||'='||c1.p2||', '||c1.p3text||'='||c1.p3);
    for c1 in ( select w.*, case when event like '%latch%' then ', LatchName: '||l.name else '' end name  from sys.v_\$session_wait w, sys.v\$latchname l where w.p2=l.latch#(+) and w.sid = s.sid) loop
    dbms_output.put_line(chr(126)||chr(32)||c1.state||': '||c1.event||', '||c1.p1text||'='||c1.p1||', '||c1.p2text||'='||c1.p2||', '||c1.p3text||'='||c1.p3||c1.name );
    for c2 in (SELECT MAX (SYS_CONNECT_BY_PATH (name||' '||value,'    ')) scbp from (
                 select a.name, b.value, ROW_NUMBER () OVER (ORDER BY name desc) rn from v\$statname a, v\$sesstat b
                 where a.statistic#=b.statistic# and b.sid=s.sid and a.name in ('db block gets','consistent gets','physical reads')
                 ) START WITH rn = 1 CONNECT BY PRIOR rn = rn - 1) loop
       dbms_output.put_line(chr(126)||chr(32)||c2.scbp);
    end loop;
  end loop;
/*
  dbms_output.put_line(chr(126)||'Current SQL statement:');
  for c1 in ( select * from sys.v_\$sqltext
              where HASH_VALUE = s.sql_hash_value order by piece) loop
    dbms_output.put_line(chr(126)||chr(32)||c1.sql_text);
  end loop;
*/
/*
  dbms_output.put_line(chr(126)||'Explain plan V\$SQL_PLAN: s.sql_id='||s.sql_id||'  s.sql_hash_value='||s.sql_hash_value ||'  s.sql_adress=' ||s.sql_address|| '  s.sql_child_number='||s.sql_child_number);
  for c1 in ( SELECT distinct lpad(id,3,'0')||' '||lpad(' ',depth)||operation||' '||options||' '||object_name|| case options when 'FULL' then '<<< FULL' end ss from v\$sql_plan where address=s.sql_address and hash_value=s.sql_hash_value and child_number=s.sql_child_number order by 1) loop
    dbms_output.put_line(chr(126)||chr(32)||c1.ss);
  end loop;
*/
/*  if (s.sql_id is not null) then
    dbms_output.put_line(chr(126)||'Explain plan from dbms_xplan.display_cursor:');
    for c1 in (select plan_table_output from   table(dbms_xplan.display_cursor(s.sql_id,s.sql_child_number,'Typical +PEEKED_BINDS')) ) loop
      dbms_output.put_line(chr(126)||chr(32)||c1.plan_table_output);
    end loop;
  end if; */

$CMD1_
$CMD2_
-- lock was here

------------
  dbms_output.put_line(chr(126)||'Previous SQL statement:');
  select sql_id into  STR_ from sys.v_\$sqltext where HASH_VALUE = s.prev_hash_value and rownum=1;
  dbms_output.put_line(chr(126)||'sql_id: '||STR_);
  for c1 in ( select * from sys.v_\$sqltext
              where HASH_VALUE = s.prev_hash_value order by piece) loop
    dbms_output.put_line(chr(126)||chr(32)||c1.sql_text);
  end loop;
  dbms_output.put_line(chr(126)||'===============================================================================');
END;
/
spool off
exit
EOF
;;
esac
logf
}



lock()
{
P2_=`echo $ALL | awk '{print $2}'`
P3_=`echo $ALL | awk '{print $3}'`
SETP_="
set echo off feed off veri off tab off 
set lines 230 pages 100
column Action format a10
column SID format 99999
column serail# format 9999999
column PID format a10
column username format a30
column name format a30
column object_name format a30
column lmode format a15
column request format a15
column TYPE format a4
column last_call_et heading 'ET(min)' format a10
PROMPT 0: None
PROMPT 1: Null (NULL)
PROMPT 2: Row-S (SS) Row Share
PROMPT 3: Row-X (SX) Row Exclusive
PROMPT 4: Share (S) Share
PROMPT 5: S/Row-X (SSX) Share/Row Exclusive
PROMPT 6: Exclusive (X) "
case "$P2_" in
lib) $SP <<'END' > $LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column sid for 999999
column serial# for 9999999
column m for 9
column r for 9
column username for a10
column status for a1
column osuser for a13
column machine for a15
column program for a35
column Object for a30
column event for a25
column s_w for 9999
column spid for a16
column logon_time for a20 wrap
prompt "-- kglpnmod M  (0: no lock; 1: null; 2: shared; 3: exclusive)"
SELECT /* +rule */ 'kill -9 '||pr.spid spid, s.sid, s.serial#, sw.event, sw.seconds_in_wait s_w,
ob.kglnaown||'.'||ob.kglnaobj "Object", p.kglpnmod "M", p.kglpnreq "R",
s.username,substr(s.status,1,1) status,s.osuser,s.machine,s.program,to_char(s.logon_time,'dd/mm/yyyy hh24:mi:ss') logon_time
FROM sys.x$kglpn p, sys.v_$session s, sys.v_$process pr, sys.x$kglob ob, sys.v_$session_wait sw
WHERE p.kglpnuse=s.saddr and pr.addr = s.paddr and ob.kglhdadr=p.kglpnhdl
and sw.event like 'lib%'
and sw.p1raw = ob.kglhdadr;
END
;;
obj) $SP <<END > $LOGF
$SETP_
SELECT /*+ rule */ DECODE(w.request,0,'HOLDER: ','Waiter: ') Action, w.sid, P1.spid "PID", s1.status, s1.username, /*w.id1, w.id2,*/ -- w.lmode, w.request,
DECODE(w.lmode, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive') lmode,
DECODE(w.request, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive') request,
w.type, o.name, to_char(s1.last_call_et/60, '9999990.0') last_call_et
FROM V\$LOCK w, sys.obj$ o, sys.v_\$session s1, sys.v_\$process p1
WHERE (w.id1, w.id2, w.type) IN (SELECT id1, id2, type FROM V\$LOCK /* WHERE request>0*/)
and upper(o.name) = upper('$P3_') and w.lmode not in (0,1)
and o.obj# (+) = s1.row_wait_obj# and w.sid = S1.sid (+) and S1.paddr = P1.addr (+)
ORDER BY w.id1, w. request, last_call_et desc;
END
;;
*) $SP <<END > $LOGF
$SETP_
SELECT /*+ rule */ DECODE(w.request,0,'HOLDER: ','Waiter: ') Action, w.sid, s1.serial#, P1.spid "PID", s1.status, s1.username, /*w.id1, w.id2,*/ -- w.lmode, w.request,
DECODE(w.lmode, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive') lmode,
DECODE(w.request, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive') request,
w.type, o.name, to_char(s1.last_call_et/60, '9999990.0') last_call_et
FROM V\$LOCK w, sys.obj$ o, sys.v_\$session s1, sys.v_\$process p1
WHERE (w.id1, w.id2, w.type) IN (SELECT id1, id2, type FROM V\$LOCK WHERE request>0)
and o.obj# (+) = s1.row_wait_obj# and w.sid = S1.sid (+) and S1.paddr = P1.addr (+)
ORDER BY w.id1, w.request, last_call_et desc;
END
;;
esac
logf
}


health()
{
P1_=`echo $ALL | awk '{print $1}'`
case "$P1_" in 
cr)
$SP <<'EOF' >$LOGF
set lines 230 pages 100
ttitle left "Consistent read buffers (>100) v$bh in SGA group by owner,object_name,object_type"
set lines 230 pages 100 timing on
col owner for a30
col dirty for a5
col object_name for a30
col object_type for a10
select d.owner, d.object_name, d.object_type, b.dirty, count(*) cnt
  from v$bh b, dba_objects d
where b.objd = d.data_object_id
   and d.owner not in ('SYS', 'SYSTEM')
   and b.status = 'cr'
group by d.owner, d.object_name, d.object_type, b.dirty
having count(*) > 100
order by cnt desc;
EOF
;;
hot)
$SP <<'EOF' >$LOGF
set lines 230 pages 100
ttitle left "Hot buffers in buffer cache  avg(tch)>100 and count(buffers)>20, 'cache buffers chains' latch contention:" skip 1
column owner for a20
column avg_touches format 999
column myname heading 'Name' format a30
column mytype heading 'Type' format a10
column buffers format 999,999
select b.owner, object_type mytype, object_name myname, blocks, count(1) buffers, avg(tch) avg_touches
from x$bh a, dba_objects b, dba_segments s
where a.obj=b.object_id and b.object_name=s.segment_name and b.owner not in('SYS','SYSTEM')
group by b.owner, object_name, object_type, blocks, obj
having avg(tch) > 100 and count(1) > 20
order by avg_touches desc;
ttitle off
EOF
;;
*)
$SP <<'EOF' >$LOGF
set lines 230 pages 100
set heading on
set feedback off
set termout off
set heading on
set termout on

ttitle left "v$license information about session HWM:"
select sessions_current,sessions_highwater,cpu_count_current from v$license;
ttitle off

ttitle left "Cache usage:"
col name for a70
col Remarks for a70
select 'Data Dictionary cache' Name, round((SUM(GETS - GETMISSES - USAGE - FIXED)) / SUM(GETS) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$ROWCACHE
union all
select 'Library cache' Name, round((SUM(PINS - RELOADS)) / SUM(PINS) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$LIBRARYCACHE
union all
select 'Index usage ratio' Name, round(sum(decode(name,'table fetch by rowid',value,0)) / sum(decode(name,'table fetch by rowid',value,'table scans (short tables)',value,'table scans (long tables)',value,0)) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$SYSSTAT
union all
select 'Memory usage in Sorts ratio' Name, round(sum(decode(name,'sorts (memory)',value,0)) / sum(decode(name,'sorts (memory)',value,'sorts (disk)',value,0)) * 100,4) Ratio, 'Ratio sorts in memory to total sorts' Remarks
    from V$SYSSTAT
union all
select 'Buffer cache hit ratio' Name, round((1 - sum(decode(name,'physical reads',value,0)) / sum(decode(name,'db block gets',value,'consistent gets',value,0))) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$SYSSTAT
union all
select 'Buffer pool: ' || Name || ' block_size: '|| block_size || ' hit ratio' Name, round((1 - physical_reads / (db_block_gets+consistent_gets)) * 100,4) Ratio, 'Target ~ 99%' Remarks
    from V$BUFFER_POOL_STATISTICS
union all
select 'Average buffers scanned' Name, round(1 + sum(decode(name,'free buffer inspected',value,0)) / sum(decode(name,'free buffer requested',value,0)),4), 'Target ~ 1..2, if above -- too low buffers' Remarks
    from V$SYSSTAT
union all
select 'Average dirty buffers' Name, round(sum(decode(name,'dirty buffers inspected',value,0)) / sum(decode(name,'free buffer inspected',value,0)),4), 'Target ~ ??, if too much durty -- too low buffers' Remarks
    from V$SYSSTAT
union all
select 'consistent reads - undo records applied / consistent read rollbacks', round((select value from V$SYSSTAT where name='transaction tables consistent reads - undo records applied')/(select value from V$SYSSTAT where name='transaction tables consistent read rollbacks'),4) ratio, 'Less is better' Remarks
    from dual
union all
select 'Log Buffers space requests' Name, round(sum(decode(name,'redo log space requests',value,0))) Ratio,  'Target (..?)' Remarks
    from V$SYSSTAT
union all
select 'Shared pool free memory (MB)' Name, round(bytes/1024/1024,4) Ration, 'If much free mem -- maybe its redundant??' Remarks
    from V$SGASTAT
    where name = 'free memory' and pool = 'shared pool';
ttitle off

ttitle left "TOP 10 - v$system_event waits:" skip 1
column time_waited for 999999999999
select inst_id, event, time_waited, total_waits, total_timeouts, pct_mis
from (select inst_id, event, time_waited, total_waits, total_timeouts, round(total_timeouts/total_waits*100,3) pct_mis
from gv$system_event where event not in ('rdbms ipc message','smon timer',
'pmon timer','SQL*Net message from client',
'lock manager wait for remote message','ges remote message', 'client message',
'SQL*Net more data from client', 'pipe get', 'Null event', 'PX Idle Wait',
'single-task message', 'wakeup time manager','lreg timer','Streams AQ: deallocate messages from Streams Pool',
'OFS idle','AQPC idle','pman timer','wait for unread message on broadcast channel','DIAG idle wait')
order by time_waited desc)
where rownum <= 10
order by pct_mis desc;
ttitle off
EOF
;;
esac
logf
}


oratop()
{
case "$(db_version)" in
8|9|10)   echo "Oracle Version 8, 9, 10 oratop not supporting..." ; exit ;;
*)     : ; ;;
esac

P1_=`echo $ALL | awk '{print $1}'`
case "$P1_" in
h)
$SP <<'EOF' >$LOGF
set lines 230 pages 100 tab off
prompt NCPU   - Number of CPU                                   AAS    - Average Active Sessions. (red if > #cpu)       SSRT   - Sql service response time (T/call)
prompt HCPUB  - Host cpu busy %(busy/busy+idle). (red if>90%)   AST    - Active user Sessions Total (ASCPU+ASIO+ASWA)   MBPS   - I/O megabytes per second (throughput)
prompt CPUUPS - CPU Usage Per Sec                               ASCPU  - Active Sessions on CPU                         IOPS   - I/O requests per second
prompt LOAD   - Current os load. (red if>2*#CPU and high cpu)   ASIO   - Active Sessions waiting on user I/O            IORL   - I/O avg synch s/b/read latency in msec (red>20ms)
prompt DCTR   - DB CPU time ratio  % Cpu/DB_Time                ASWA   - Active Sessions Waiting, (red if>ASCPU+ASIO)   LOGR   - Logical reads per sec
prompt DWTR   - DB WAIT time ratio (red if>50 and high ASWA)    ASPQ   - Active Parallel Sessions                       PHYR   - Physical reads per sec
prompt SPFR   - Shared pool free %                              UTPS   - User transactions per sec                      PHYW   - Physical writes per sec
prompt TPGA   - Total pga allocated                             UCPS   - User calls per sec                             TEMP   - Temp space used (Mb)                   DBTM - Database Time Per Sec
col NCPU for 9999
col HCPUB for 99999
col CPUUPS for 99999
col SPFR for 99999
col UTPS for 99999
col UCPS for 9999999
col AAS for 99999
col MBPS for 99999
col SSRT for 999999
col IORL for 99999
col LOAD for 99999
col DCTR for 99999
col DWTR for 99999
col NCPU for 9999
col AAS for 9999
col AST for 9999
col ASCPU for 9999
col ASIO for 9999
col ASWA for 9999
col ASPQ for 99999
col TPGA for 999999
col IOPS for 999999
col PHYR for 999999
col PHYW for 99999
col TEMP for 99999
col DBTM for 99999
SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */   /*+ NO_MONITOR */
      begin_time, 
      ncpu,                           --  'NUM_CPUS'
      trunc(hcpu) hcpub,              --   %CPU      [m,N]: host cpu busy %(busy/busy+idle). (red if > 90%)
      trunc(dcpu) cpuups,             --  'CPU Usage Per Sec'  'CentiSeconds Per Second'
      trunc(load) load,               --   LOAD      [m,N]: current os load. (red if > 2*#cpu and high cpu)
      trunc(dbcp) dctr,               --   DCTR      [m,N]: database cpu time ratio    % Cpu/DB_Time
      trunc(dbwa) dwtr,               --   DWTR      [m,N]: database wait time ratio. (red if > 50 and high ASW)
      trunc(sgfr) spfr,               --   %FR       [s,N]: shared pool free %
      round(upga/1024/1024,0) tpga,   --   PGA       [s,N]: total pga allocated
      trunc(saas) aas,                --   AAS       [s,N]: Average Active Sessions. (red if > #cpu)
      ast,                            --   AST       [c,N]: Active user Sessions Total (ASC+ASI+ASW)
      ascpu,                          --?  ASCPU     [c,N]: active Sessions on CPU
      asio,                           --?  ASIO      [c,N]: active Sessions waiting on user I/O
      aswa,                           --?  ASWA      [c,N]: active Sessions Waiting, non-ASI (red if > ASC+ASI)
      aspq,                           --  'Active Parallel Sessions'
      trunc(utps) utps,               --   UTPS      [s,N]: user transactions per sec
      trunc(ucps) ucps,               --   UCPS    [c,m,N]: user calls per sec
      trunc(ssrt*10000) ssrt,         --   SSRT    [c,m,T]: sql service response time (T/call)
      trunc(mbps) mbps,               --   MBPS      [m,N]: i/o megabytes per second (throughput)
      trunc(iops) iops,               --   IOPS      [m,N]: i/o requests per second
      trunc(iorl) iorl,               --   IORL      [m,T]: avg synchronous single-block read latency in msec (red > 20ms)
      trunc(logr) logr,               --   LOGR      [s,N]: logical reads per sec
      trunc(phyr) phyr,               --   PHYR      [s,N]: physical reads per sec
      trunc(phyw) phyw,               --   PHYW      [s,N]: physical writes per sec
      round(temp/1024/1024,0) temp,   --   TEMP      [s,N]: temp space used (Mb)
      trunc(dbtm) dbtm                --'Database Time Per Sec'
  FROM   (  SELECT   begin_time, 
                     SUM(DECODE (metric_name, 'CPU Usage Per Sec', VALUE, 0)) dcpu,
                     SUM(DECODE (metric_name, 'Host CPU Utilization (%)', VALUE, 0)) hcpu,
                     SUM(DECODE (metric_name, 'I/O Megabytes per Second', VALUE, 0)) mbps,
                     SUM(DECODE (metric_name, 'SQL Service Response Time', VALUE, 0)) ssrt,
                     SUM(DECODE (metric_name, 'Average Synchronous Single-Block Read Latency', VALUE, 0)) iorl,
                     SUM(DECODE (metric_name, 'Current OS Load', VALUE, 0)) load, 
                     SUM(DECODE (metric_name, 'Active Parallel Sessions', VALUE, 0)) aspq,
                     SUM(DECODE (metric_name, 'Database CPU Time Ratio', VALUE, 0)) dbcp,
                     SUM(DECODE (metric_name, 'Database Wait Time Ratio', VALUE, 0)) dbwa,
                     SUM(DECODE (metric_name, 'I/O Requests per Second', VALUE, 0)) iops,
                     SUM(DECODE (metric_name, 'Shared Pool Free %', VALUE, 0)) sgfr,
                     SUM(DECODE (metric_name, 'User Transaction Per Sec', VALUE, 0)) utps,
                     SUM(DECODE (metric_name, 'User Calls Per Sec', VALUE, 0)) ucps,
                     SUM(DECODE (metric_name, 'Average Active Sessions', VALUE, 0)) saas,
                     SUM(DECODE (metric_name, 'Total PGA Allocated', VALUE, 0)) upga,
                     SUM(DECODE (metric_name, 'Logical Reads Per Sec', VALUE, 0)) logr,
                     SUM(DECODE (metric_name, 'Physical Reads Per Sec', VALUE, 0)) phyr,
                     SUM(DECODE (metric_name, 'Physical Writes Per Sec', VALUE, 0)) phyw,
                     SUM(DECODE (metric_name, 'Temp Space Used', VALUE, 0)) temp,
                     SUM(DECODE (metric_name, 'Database Time Per Sec', VALUE, 0)) dbtm
              FROM   V$SYSMETRIC_HISTORY
             WHERE   metric_name IN
                             ('CPU Usage Per Sec',
                              'Host CPU Utilization (%)',
                              'I/O Megabytes per Second',
                              'SQL Service Response Time',
                              'Average Synchronous Single-Block Read Latency',
                              'Current OS Load',
                              'Active Parallel Sessions',
                              'Database CPU Time Ratio',
                              'Database Wait Time Ratio',
                              'I/O Requests per Second',
                              'Shared Pool Free %',
                              'User Transaction Per Sec',
                              'User Calls Per Sec',
                              'Logical Reads Per Sec',
                              'Physical Reads Per Sec',
                              'Physical Writes Per Sec',
                              'Temp Space Used',
                              'Database Time Per Sec',
                              'Average Active Sessions',
                              'Total PGA Allocated')
                     AND GROUP_ID in (2,3)
          GROUP BY   begin_time ), 
          (SELECT inst_id id3, TO_NUMBER (VALUE) ncpu  FROM   gv$osstat  WHERE   stat_name = 'NUM_CPUS')
 , (select sample_time, count(*) ast, nvl(round((count(*)/sum(asct))*sum(cpas)),0) ascpu, nvl(round((count(*)/sum(asct))*sum(ioas)),0) asio, nvl(round((count(*)/sum(asct))*sum(waas)),0) aswa
from(
SELECT cast(sample_time as date) sample_time, session_id, "SESSION_SERIAL#",
 COUNT ( * ) asct,
 SUM(DECODE(wait_time, 0, 0, 1)) cpas,
 SUM(DECODE(wait_class, 'User I/O', 1, 0)) ioas,
 SUM(DECODE(wait_time, 0, DECODE (wait_class,'User I/O', 0, 1))) waas
FROM V$ACTIVE_SESSION_HISTORY
WHERE SESSION_TYPE <> 'BACKGROUND' AND user_id > 0
group by cast(sample_time as date), session_id, "SESSION_SERIAL#"
order by sample_time
)
group by sample_time
order by sample_time
) act_sess
where act_sess.sample_time=begin_time
ORDER BY begin_time;
EOF
;;
*)
$SP <<'EOF' >$LOGF
set lines 180
set echo off feed off veri off tab off pages 60
set serveroutput on
begin
for i in (
SELECT   /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */ /*+ NO_MONITOR */     *
  FROM   (SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                trunc(SUM(VALUE)) taas             -- CentiSeconds Per Second
            FROM   gv$sysmetric
           WHERE   metric_name = 'Database Time Per Sec' AND GROUP_ID = 3),
         (SELECT    /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                COUNT(*) sess,
                   COUNT (DISTINCT username) duser
            FROM   gv$session
           WHERE       TYPE <> 'BACKGROUND'
                   AND username IS NOT NULL
                   AND schema# != 0),
         (SELECT   /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                TO_CHAR (MAX(end_time), 'hh24:mi:ss') dbts,
                   round(SUM (VALUE/1024/1024),0) spga
            FROM   gv$sysmetric
           WHERE   metric_name = 'Total PGA Allocated' AND GROUP_ID = 3),
         (SELECT   trunc(SYSDATE - startup_time)/* * 86400 */ uptm FROM v$instance),
         (SELECT     /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                SUM(VALUE) scpu,
                COUNT (DISTINCT inst_id) inst
            FROM   gv$osstat
           WHERE   stat_name = 'NUM_CPUS'),
         (SELECT         /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                round(SUM (VALUE/1024/1024/1024),0) ssga FROM gv$sga),
         (SELECT   /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                SUM(VALUE) prob
            FROM   gv$diag_info
           WHERE   name = 'Active Problem Count'),
         (SELECT   SUM (fra) reco
            FROM   (SELECT   space_used / GREATEST (space_limit, 1) * 100 fra
                      FROM   v$recovery_file_dest
                    UNION
                    SELECT   0 fra FROM DUAL)),
         (SELECT   INITCAP(SUBSTR (SYS_CONTEXT ('USERENV', 'DATABASE_ROLE'), -7, 16)) dbro
            FROM   DUAL),
         (SELECT   SUM (ar) dgar
            FROM   (SELECT    /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                          sofar ar
                      FROM   gv$recovery_progress
                     WHERE  TYPE = 'Media Recovery'
                             AND item = 'Active Apply Rate'
                             AND ROWNUM = 1
                    UNION
                    SELECT   0 ar FROM DUAL)),
         (SELECT   /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                round(MAX(VALUE/1024/1024/1024),0)  pgag
            FROM   gv$pgastat
           WHERE   name = 'aggregate PGA target parameter')
  ) loop

dbms_output.put_line(rpad(rpad(i.uptm,10,' ') || '- Days uptime of database',50,' ')||rpad(rpad(i.prob,8,' ') || '- Active Problem Count',50,' ')||rpad(rpad(i.ssga,6,' ') || '- Global DB MEM total (sga+pga Gb)',50,' '));
dbms_output.put_line(rpad(rpad(i.dbts,10,' ') || '- Last time of PGA Allocated',50,' ')||rpad(rpad(i.spga,8,' ') || '- Total PGA Allocated (Mb)',50,' ')||rpad(rpad(i.pgag,6,' ') || '- Aggregate PGA target parameter (Gb)',50,' '));
end loop;

for i in (
SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */   /*+ NO_MONITOR */
      inid,                           --   ID        [c,N]: inst_id (instance id)
      trunc(hcpu) hcpu,               --   %CPU      [m,N]: host cpu busy %(busy/busy+idle). (red if > 90%)
      trunc(sgfr) sgfr,               --   %FR       [s,N]: shared pool free %
      trunc(utps) utps,               --   UTPS      [s,N]: user transactions per sec
      trunc(ucps) ucps,               --   UCPS    [c,m,N]: user calls per sec
      trunc(saas) saas,               --   AAS       [s,N]: Average Active Sessions. (red if > #cpu)
      trunc(mbps) mbps,               --   MBPS      [m,N]: i/o megabytes per second (throughput)
      trunc(ssrt*10000) ssrt,         --   SSRT    [c,m,T]: sql service response time (T/call)
      trunc(iorl) iorl,               --   IORL      [m,T]: avg synchronous single-block read latency in msec (red > 20ms)
      trunc(load) load,               --   LOAD      [m,N]: current os load. (red if > 2*#cpu and high cpu)
      round(upga/1024/1024,0) upga,   --   PGA       [s,N]: total pga allocated
      aspq,                           --'Active Parallel Sessions'
      trunc(dbcp) dbcp,               --   DCTR      [m,N]: database cpu time ratio    % Cpu/DB_Time
      trunc(dbwa) dbwa,               --   DWTR      [m,N]: database wait time ratio. (red if > 50 and high ASW)
      trunc(iops) iops,               --   IOPS      [m,N]: i/o requests per second
      asct,                           --   AST       [c,N]: Active user Sessions Total (ASC+ASI+ASW)
      isct,                           --   UST       [c,N]: user Sessions Total (ACT/INA)
      cpas,                           --?  ASC       [c,N]: active Sessions on CPU
      ioas,                           --?  ASI       [c,N]: active Sessions waiting on user I/O
      waas,                           --?  ASW       [c,N]: active Sessions Waiting, non-ASI (red if > ASC+ASI)
      trunc(dcpu) dcpu,               --'CPU Usage Per Sec'  'CentiSeconds Per Second'
      ncpu,                           --'NUM_CPUS'
      trunc(logr) logr,               --   LOGR      [s,N]: logical reads per sec
      trunc(phyr) phyr,               --   PHYR      [s,N]: physical reads per sec
      trunc(phyw) phyw,               --   PHYW      [s,N]: physical writes per sec
      round(temp/1024/1024,0) temp,   --   TEMP      [s,N]: temp space used (Mb)
      trunc(dbtm) dbtm                --'Database Time Per Sec'
  FROM   (  SELECT     /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                  inst_id  inid,
                     SUM(DECODE (metric_name, 'CPU Usage Per Sec', VALUE, 0)) dcpu,
                     SUM(DECODE (metric_name, 'Host CPU Utilization (%)', VALUE, 0)) hcpu,
                     SUM(DECODE (metric_name, 'I/O Megabytes per Second', VALUE, 0)) mbps,
                     SUM(DECODE (metric_name, 'SQL Service Response Time', VALUE, 0)) ssrt,
                     SUM(DECODE (metric_name, 'Average Synchronous Single-Block Read Latency', VALUE, 0)) iorl,
                     SUM(DECODE (metric_name, 'Current OS Load', VALUE, 0)) load, 
                     SUM(DECODE (metric_name, 'Active Parallel Sessions', VALUE, 0)) aspq,
                     SUM(DECODE (metric_name, 'Database CPU Time Ratio', VALUE, 0)) dbcp,
                     SUM(DECODE (metric_name, 'Database Wait Time Ratio', VALUE, 0)) dbwa,
                     SUM(DECODE (metric_name, 'I/O Requests per Second', VALUE, 0)) iops
              FROM   gv$sysmetric
             WHERE   metric_name IN
                             ('CPU Usage Per Sec',
                              'Host CPU Utilization (%)',
                              'I/O Megabytes per Second',
                              'SQL Service Response Time',
                              'Average Synchronous Single-Block Read Latency',
                              'Current OS Load',
                              'Active Parallel Sessions',
                              'Database CPU Time Ratio',
                              'Database Wait Time Ratio',
                              'I/O Requests per Second')
                     AND GROUP_ID = 2
          GROUP BY   inst_id),
         (  SELECT   /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                     inst_id id1,
                     SUM(DECODE (metric_name, 'Shared Pool Free %', VALUE, 0)) sgfr,
                     SUM(DECODE (metric_name, 'User Transaction Per Sec', VALUE, 0)) utps,
                     SUM(DECODE (metric_name, 'User Calls Per Sec', VALUE, 0)) ucps,
                     SUM(DECODE (metric_name, 'Average Active Sessions', VALUE, 0)) saas,
                     SUM(DECODE (metric_name, 'Total PGA Allocated', VALUE, 0)) upga,
                     SUM(DECODE (metric_name, 'Logical Reads Per Sec', VALUE, 0)) logr,
                     SUM(DECODE (metric_name, 'Physical Reads Per Sec', VALUE, 0)) phyr,
                     SUM(DECODE (metric_name, 'Physical Writes Per Sec', VALUE, 0)) phyw,
                     SUM(DECODE (metric_name, 'Temp Space Used', VALUE, 0)) temp,
                     SUM(DECODE (metric_name, 'Database Time Per Sec', VALUE, 0)) dbtm
              FROM   gv$sysmetric
             WHERE   metric_name IN
                             ('Shared Pool Free %',
                              'User Transaction Per Sec',
                              'User Calls Per Sec',
                              'Logical Reads Per Sec',
                              'Physical Reads Per Sec',
                              'Physical Writes Per Sec',
                              'Temp Space Used',
                              'Database Time Per Sec',
                              'Average Active Sessions',
                              'Total PGA Allocated')
                     AND GROUP_ID = 3
          GROUP BY   inst_id),
         (  SELECT   id2,
                     SUM (asct) asct,
                     SUM (isct) isct,
                     SUM (cpas) cpas,
                     SUM (ioas) ioas,
                     SUM (waas) waas
              FROM   (  SELECT /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                              inst_id id2,
                                 SUM(DECODE (status, 'ACTIVE', 1, 0)) asct, COUNT ( * ) isct,
                                 SUM(DECODE (status, 'ACTIVE', DECODE (wait_time, 0, 0, 1), 0)) cpas,
                                 SUM(DECODE (status, 'ACTIVE', DECODE (wait_class, 'User I/O', 1, 0), 0)) ioas,
                                 SUM(DECODE (status, 'ACTIVE', DECODE (wait_time, 0, DECODE (wait_class,'User I/O', 0, 1), 0), 0)) waas
                          FROM   gv$session
                         WHERE       TYPE <> 'BACKGROUND'
                                 AND username IS NOT NULL
                                 AND schema# != 0
                      GROUP BY   inst_id
                      UNION ALL
                      SELECT       /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                              inst_id
                                     id2,
                                 0 asct,
                                 0 isct,
                                 0 cpas,
                                 0 ioas,
                                 0 waas
                          FROM   gv$instance)
            GROUP BY   id2),
           (SELECT       /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                  inst_id id3, TO_NUMBER (VALUE) ncpu
              FROM   gv$osstat
             WHERE   stat_name = 'NUM_CPUS')
   WHERE   id1 = inid AND id2 = inid AND id3 = inid AND inid=(select instance_number from v$instance) and  ROWNUM <= 5
ORDER BY   dbtm DESC) loop

dbms_output.put_line(rpad(rpad(i.ncpu,10,' ') || '- Number of CPU',50,' ')||rpad(rpad(i.hcpu,8,' ') || '- Host CPU busy %bsy/bsy+idle (red>90%)',50,' ')||rpad(rpad(i.load,6,' ') || '- Current os load. (red>2*#cpu and high cpu)',60,' '));
dbms_output.put_line(rpad(rpad(i.dcpu,10,' ') || '- CPU Usage per Sec (usec per Sec)',50,' ')||rpad(rpad(i.saas,8,' ') || '- Average Active Sessions. (red > #cpu)',50,' '));
dbms_output.put_line(rpad(rpad(i.cpas,10,' ') || '- Active Sessions on CPU (ASC)',50,' ')||rpad(rpad(i.ioas,8,' ') || '- Active Sess waiting on I/O (ASI)',50,' ')||rpad(rpad(i.waas,6,' ') || '- Active Sess Waiting, non-ASI (ASW) (red>ASC+ASI)',60,' ') );
dbms_output.put_line(rpad(rpad(i.asct,10,' ') || '- Active UserSess Total (ASC+ASI+ASW)',50,' ')||rpad(rpad(i.aspq,8,' ') || '- Active Parallel Sessions',50,' ')||rpad(rpad(i.isct,6,' ') || '- User Sessions Total (ACT/INA)',50,' '));
dbms_output.put_line(rpad(rpad(i.mbps,10,' ') || '- I/O Mbytes per sec (throughput)',50,' ')||rpad(rpad(i.iops,8,' ') || '- I/O requests per sec IOPS',50,' ')||rpad(rpad(i.iorl,6,' ') || '- I/O avg synch s/b/read latency in msec (red>20us)',65,' ') );
dbms_output.put_line(rpad(rpad(i.logr,10,' ') || '- logical reads per sec',50,' ')||rpad(rpad(i.phyr,8,' ') || '- physical reads per sec',50,' ')||rpad(rpad(i.phyw,6,' ') || '- physical writes per sec',50,' '));
dbms_output.put_line(rpad(rpad(i.sgfr,10,' ') || '- shared pool free %',50,' ')||rpad(rpad(i.temp,8,' ') || '- temp space used (Mb)',50,' '));
dbms_output.put_line(rpad(rpad(i.utps,10,' ') || '- user transactions per sec',50,' ')||rpad(rpad(i.ucps,8,' ') || '- user calls per sec',50,' ')||rpad(rpad(i.ssrt,6,' ') || '- sql service response time (T/call) usec',50,' '));
dbms_output.put_line(rpad(rpad(i.dbcp,10,' ') || '- DB cpu time ratio  %Cpu/DB_Time',50,' ')||rpad(rpad(i.dbwa,8,' ') || '- DB wait time ratio %Wait/DB_Time (red>50 and high ASW)',80,' ') );
end loop;
end;
/

set numw 15
column event for a65 heading "EVENT   (Cumulative Top 5 Timed Events)"
column totwa for 999,999,999,999
column twsec for 999,999,999,999
column AVGMS for 999,999,999.00
column wclas for a15
-- ttitle left "Cumulative Top 5 Timed Events:"
SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */  /*+ NO_MONITOR */
         event,
         totwa,
         twsec,
         avgms,
         ROUND (ratio_to_report (twsec) OVER () * 100) pctwa,
         wclas
--         ,evtid
  FROM   (  SELECT       /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                  event,
                     SUM (total_waits) totwa,
                     SUM (time_waited) / 100 twsec,
                     AVG (average_wait) * 10 avgms,
                     wait_class wclas,
                     event_id evtid
              FROM   gv$system_event
             WHERE   wait_class <> 'Idle'
          GROUP BY   event, wait_class, event_id
            HAVING   SUM (total_waits) > 0
          UNION
          SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                  'DB CPU'
                   event,
                   0 totwa,
                   SUM (VALUE) / 100 twsec,
                   0 avgms,
                   NULL wclas,
                   19 evtid
            FROM   gv$sysstat
           WHERE   name LIKE '%CPU used by this session%'
          ORDER BY   twsec DESC)
 WHERE   ROWNUM < 6;
ttitle off
-- ttitle left "Real-Time Top 5 Timed Events:"
column event for a65 heading "EVENT   (Real-Time Top 5 Timed Events)"
column totwa for 999,999,999,999
column twsec for 999,999,999,999
column AVGMS for 999,999,999.00
column wclas for a15
SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */  /*+ NO_MONITOR */
      event,
      totwa,
      twsec,
      avgms,
      ROUND (ratio_to_report (twsec) OVER () * 100) pctwa,
      wclas
--      ,evtid
  FROM   (  SELECT    /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                  sw .event,
                     SUM (se.total_waits) totwa,
                     SUM (se.time_waited) / 100 twsec,
                     SUM (se.time_waited) / (GREATEST (SUM (se.total_waits), 1) * 10)
                     avgms,
                     sw.wait_class wclas,
                     sw.event# evtid
              FROM   gv$session_wait_class se  JOIN   gv$session sw
                     ON se.inst_id = sw.inst_id AND se.sid = sw.sid
             WHERE   se.wait_class != 'Idle' AND sw.wait_class != 'Idle'
          GROUP BY   sw.event, sw.wait_class, sw.event#
            HAVING   SUM (se.total_waits) > 0
          UNION
          SELECT   /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                'DB CPU' event,
                   0 totwa,
                   SUM (VALUE) / 100 twsec,
                   0 avgms,
                   NULL wclas,
                   19 evtid
            FROM  gv$sesstat se JOIN  gv$session s2
                   ON se.inst_id = s2.inst_id AND se.sid = s2.sid
           WHERE   se.statistic# = 19
                   AND se.VALUE > 0
                   AND s2.wait_class != 'Idle'
          ORDER BY   twsec DESC)
 WHERE   ROWNUM < 6;
ttitle off

column PID4 for a8   HEADING "PPID"
column SID4 for 99999 HEADING "SID"
column SERIAL for 99999 HEADING "SERIAL"
column USR4 for a16  HEADING "USERNAME"
column PRG4 for a22  HEADING "PROGRAM"
column MODL for a22  HEADING "MODULE"
column ACTN for a22  HEADING "ACTION"
column pma for a60   HEADING "PROGRAM / MODULE / ACTION"
column PGAU for 9999 HEADING "PGA"
column OPN for a6    HEADING "CMD"
column SQID for a13  HEADING "SQLID"
column ST4 for a1
column SU4 for a3    HEADING "STE"
column EV4 for a24   HEADING "EVENT/*LATCH"
-- column WC4 for a11   HEADING "WAIT_CLASS"
column SIW for 99999999 HEADING "W/T s"
column lcet for 99999999 HEADING "LCET m"
ttitle left "Database active sessions:"
  SELECT  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */ /*+ NO_MONITOR */
--           s.wait_time trm4,
--           s.inst_id id4,
           p.spid pid4,
           s.sid sid4,
           s.serial# serial,
           substr(DECODE (p.background, 1, 'B/G',DECODE (s.username, NULL, 'F/G', s.username)),1,16) usr4,
--           substr(DECODE (p.pname, NULL, s.program, p.pname),1,22) prg4,
--           substr(s.module,1,22) modl,
--           substr(s.action,1,22) actn,
           substr(DECODE(p.pname, NULL, s.program, p.pname)||' / '||case when s.module<>p.pname then s.module else '' end ||' / '||s.action,1,60) pma,
--           substr(DECODE(p.pname, NULL, s.program, p.pname)||' / '||case when s.module<>p.pname then s.module else '' end ||' / '||convert(s.action, 'AL32UTF8','CL8MSWIN1251'),1,60) pma,
--           substr(DECODE(p.pname, NULL, s.program, p.pname)||' / '||case when s.module<>p.pname then s.module else '' end ||' / '||regexp_replace(s.action, '[^[:print:]]', ''), 1, 60) pma,
           trunc(p.pga_used_mem/1024/1024) pgau,
--           p.pga_alloc_mem pgac,
--           p.pga_freeable_mem pgaf,
--           x.pgax pgax,
           substr(c.command_name,1,6) opn,
           DECODE (s.plsql_subprogram_id, NULL, s.sql_id, NULL) sqid,
--           DECODE (s.final_blocking_session_status,'VALID', TO_CHAR (s.final_blocking_instance)|| ':' || TO_CHAR (s.final_blocking_session), NULL) bses,
           substr(s.status,1,1) st4,
           substr(DECODE(s.state,'WAITING',DECODE (s.wait_class, 'User I/O', 'I/O', s.state),'CPU'),1,3) su4,
           CASE
               WHEN s.state <> 'WAITING' AND s.time_since_last_wait_micro < 1000000
               THEN 'cpu runqueue'
               ELSE substr(event,1,24)
           END ev4,
--           substr(s.wait_class,1,11) wc4,
           s.wait_time_micro/1000000 siw,
           s.last_call_et/60 lcet
--           s.server sded,
--           s.service_name svcn,
--           DECODE (n.name, NULL, NULL, '*' || n.name) lp2n,
--           DECODE (s.row_wait_obj#, -1,NULL,SUBSTR (TO_CHAR (s.row_wait_file#)|| ':' || TO_CHAR (s.row_wait_block#),1,24)) fbon
     FROM  gv$session s JOIN gv$process p
       ON (p.inst_id = s.inst_id AND p.addr = s.paddr)
     LEFT OUTER JOIN v$sqlcommand c
       ON (s.command = c.command_type)
     LEFT OUTER JOIN v$latchname n
       ON (s.p2 = n.latch#),
           (SELECT     /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */
                   inst_id,
                   MAX (pga_max_mem) pgax
              FROM   gv$process
          GROUP BY   inst_id) x
   WHERE   x.inst_id = s.inst_id AND s.wait_class <> 'Idle'
ORDER BY lcet desc,  siw DESC;
EOF
;;
esac
logf
}


parameters()
{
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}' | tr '[:upper:]' '[:lower:]'`
P3_=`echo $ALL | awk '{print $3}' | tr '[:lower:]' '[:upper:]'`
case "$P1_" in
services)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
set lines 230
col host_name    format a25
col service_name format a25
col network_name format a25
prompt v\$services:
select (select host_name from v\$instance) host_name, name service_name,  network_name from v\$services;
col name format a25
prompt gv\$active_services:
select service_id,name,  network_name, creation_date from  gv\$active_services order by service_id;
EOF
;;
dir)
$SP <<EOF >$LOGF
set echo off feed off veri off tab off pages 50
set lines 230
col OWNER for a20
col DIRECTORY_NAME for a30
col DIRECTORY_PATH for a80
prompt dba_directories:
SELECT * FROM dba_directories order by owner,directory_name;
EOF
;;
ph)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column parameter for a43
column Description for a70
column "Sess Value" for a40
column "DefSessVal" for a10
column "Inst Value" for a40
column "DefInstVal" for a10
SELECT a.ksppinm  "Parameter", a.ksppdesc "Description", b.ksppstvl "Sess Value", b.ksppstdf "DefSessVal", c.ksppstvl "Inst Value", c.ksppstdf "DefInstVal"
FROM  x\$ksppi a, x\$ksppcv b, x\$ksppsv c WHERE  a.indx = b.indx AND a.indx = c.indx AND a.ksppinm LIKE '%$P2_%' and c.ksppstdf like  nvl('$P3_','%')
order by a.ksppinm;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column name for a43
column type for a11
column isdefault for a9
column ISMODIFIED for a10
column value for a50
column Description for a70
select name,decode(type,'1','Boolean',2,'String',3,'Integer',4,'Parameter file',5,'Reserved',6,'Big integer') type,value,isdefault,ISMODIFIED,description from v\$parameter where name like '%$P2_%';
-- show parameter $P2_
EOF
;;
esac
logf
}



db()
{
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
case "$P2_" in
PROPERTIES)
$SP <<EOF > $LOGF
set lines 230
set echo off feed off veri off tab off pages 40
prompt
prompt database_properties:
set pages 50
column PROPERTY_NAME for a40
column PROPERTY_VALUE for a40
column DESCRIPTION for a55
SELECT PROPERTY_NAME,PROPERTY_VALUE,DESCRIPTION FROM database_properties order by PROPERTY_NAME;
EOF
;;
NLS)
$SP <<'END' > $LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column parameter for a30
column value for a40
select * from nls_database_parameters;
END
;;
OPTION)
$SP <<'END' > $LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column parameter for a50
column value for a20
select * from v$option;
END
;;
*)
 SQL_TEXT="select dbid,name,to_char(created,'dd/mm/yyyy') created,log_mode, resetlogs_time,open_mode,database_role,current_scn,protection_level,switchover_status,force_logging,supplemental_log_data_min,FLASHBACK_ON,platform_name from v\$database;"
 REL=$(db_version)
 case $REL in
   9) SQL_TEXT="select dbid,name,to_char(created,'dd/mm/yyyy') created,log_mode, resetlogs_time,open_mode,database_role,protection_level,switchover_status,force_logging,supplemental_log_data_min from v\$database;"
   ;;
   12|18|19) SQL_TEXT12="prompt
      prompt DBA_REGISTRY_SQLPATCH:
      column DESCRIPTION for a120
      select action_time, PATCH_ID, PATCH_UID, VERSION, STATUS, DESCRIPTION from DBA_REGISTRY_SQLPATCH order by action_time;"
   ;;
  esac
$SP <<EOF > $LOGF
set lines 230 timing off
set echo off feed off veri off tab off pages 50
prompt v\$instance:
column instance_name for a15
column host_name for a25
column version for a10
column status for a10
column ARCHIVER for a10
column LOGINS for a10
column DATABASE_STATUS for a15
column instance_role for a20
select INSTANCE_NAME, HOST_NAME, VERSION, STARTUP_TIME,STATUS, ARCHIVER, LOGINS, DATABASE_STATUS, INSTANCE_ROLE from v\$instance;
prompt
prompt v\$database:
column current_scn for 99999999999999
column resetlogs_time for a19 heading "RESLOGTIME"
column dbid for 99999999999
column name for a8
column created for a10
column LOG_MODE for a13
column open_mode for a20
column database_role for a20 heading "DB_ROLE"
column protection_level for a20 heading "PROTECTION_LEVEL"
column switchover_status for a15 heading "SWITCH_STATUS"
column force_logging for a8 heading "FORCELOG"
column supplemental_log_data_min for a8 heading "SUPPLLOG"
column FLASHBACK_ON for a9 heading "FLASHB_ON"
column platform_name for a28
$SQL_TEXT
EOF

$SP <<END >> $LOGF
set lines 230 timing off
set echo off feed off veri off tab off pages 40 
column COMP_ID for a10
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'DD/MM/YYYY HH24:MI:SS';
column COMP_NAME for a40
column VERSION  for a12
column STATUS for a12
column MODIFIED for a20
column SCHEMA for a15
column procedure for a45
prompt
prompt DBA_REGISTRY:
select comp_id, comp_name, version, status, modified, schema, procedure from dba_registry;
column action_time for a19
column action for a15
column namespace for a15
column version for a15
column comments for a70
column BUNDLE_SERIES for a20
prompt
prompt REGISTRY\$HISTORY:
select * from sys.registry\$history;
$SQL_TEXT12
END
;;
esac
logf
}

sga()
{
$SP <<'EOF' >$LOGF
set lines 230 numw 15
set echo off feed off veri off tab off pages 40
column component for a40
prompt Size of v$sga_dynamic_components :
select COMPONENT,CURRENT_SIZE,MIN_SIZE,MAX_SIZE from v$sga_dynamic_components;

prompt Size of db_cache_size:
column name for a20
select name,block_size,resize_state,current_size,buffers,target_size,target_buffers,prev_size,prev_buffers from V$BUFFER_POOL;

prompt 
prompt Sizes in v$sgastat:
column bytes for 999999999999
select * from v$sgastat where pool is null;

prompt
prompt Shared pool details and autocalculate:
column remarks for a70
select /*+ rule */ to_number(value) shared_pool_size, 
                         sum_obj_size,
                         sum_sql_size, 
                         sum_user_size, 
(sum_obj_size + sum_sql_size+sum_user_size)* 1.3 min_shared_pool
  from (select sum(sharable_mem) sum_obj_size 
          from v$db_object_cache where type <> 'CURSOR'),
               (select sum(sharable_mem) sum_sql_size
          from v$sqlarea),
               (select sum(250 * users_opening) sum_user_size
          from v$sqlarea), v$parameter
 where name = 'shared_pool_size';

prompt
prompt Pools of "free memory" size and free percent in v$sgastat:
select to_number(v$parameter.value) value, v$sgastat.pool, v$sgastat.bytes,
case when v$parameter.value<>0 then round((v$sgastat.bytes/v$parameter.value)*100,2) else round(to_number(v$parameter.value),2) end "Percent Free"
from v$sgastat, v$parameter
where v$sgastat.name = 'free memory'
and v$parameter.name = 'shared_pool_size';

prompt 
prompt Shared pool usage:
column name for a40
select 'Data Dictionary cache' Name,
        round((SUM(GETS - GETMISSES - USAGE - FIXED)) / SUM(GETS) * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$ROWCACHE
union all
select 'Library cache' Name,
        round((SUM(PINS - RELOADS)) / SUM(PINS) * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$LIBRARYCACHE
union all
select 'Index usage ratio' Name,
        round(sum(decode(name,'table fetch by rowid',value,0))
            / sum(decode(name,'table fetch by rowid',value,'table scans (short tables)',value,'table scans (long tables)',value,0))
            * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$SYSSTAT
union all
select 'Memory usage in Sorts ratio' Name,
        round(sum(decode(name,'sorts (memory)',value,0))
            / sum(decode(name,'sorts (memory)',value,'sorts (disk)',value,0))
            * 100,4) Ratio,
        'Relatively of sorting in Memories to all sorting' Remarks
    from V$SYSSTAT
union all
select 'Cache hit ratio' Name,
        round((1 - sum(decode(name,'physical reads',value,0))
            / sum(decode(name,'db block gets',value,'consistent gets',value,0))
        ) * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$SYSSTAT
union all
select 'Buffer pool ' || Name || ' hit ratio' Name,
        round((1 - physical_reads
            / (db_block_gets+consistent_gets)
        ) * 100,4) Ratio,
        'Must be about 99%' Remarks
    from V$BUFFER_POOL_STATISTICS
union all
select 'Average buffers scanned' Name,
        round(1 + sum(decode(name,'free buffer inspected',value,0))
           / sum(decode(name,'free buffer requested',value,0)),4),
        'Must be 1..2, if more than 2 -- not enough buffers for server' Remarks
    from V$SYSSTAT
union all
select 'Average dirty buffers' Name,
        round(sum(decode(name,'dirty buffers inspected',value,0))
        / sum(decode(name,'free buffer inspected',value,1)),4),
        'Must be <, if too much "dirty" -- not enough buffers for server' Remarks
    from V$SYSSTAT
union all
select 'Shared pool free memory (MB)' Name,
        round(bytes/1024/1024,4) Ration,
        'If too much free memory -- may be excess of mem ?' Remarks
    from V$SGASTAT
    where name = 'free memory'
        and pool = 'shared pool';
EOF
logf
}

pga()
{
$SP <<'EOF' >$LOGF
set lines 170
set echo off feed off veri off tab off pages 80
COLUMN sid FORMAT 9999 HEADING 'SID'
COLUMN username FORMAT a15 HEADING 'Oracle User' JUSTIFY right TRUNC
COLUMN osuser FORMAT a15 HEADING 'O/S User' JUSTIFY right TRUNC
COLUMN program FORMAT a28 HEADING 'Session Program' TRUNC
COLUMN machine FORMAT a20 HEADING 'Machine' JUSTIFY right TRUNC
COLUMN session_pga_memory FORMAT 9,999,999,999 HEADING 'PGA Memory'
COLUMN session_pga_memory_max FORMAT 9,999,999,999 HEADING 'PGA Memory Max'
COLUMN session_uga_memory FORMAT 9,999,999,999 HEADING 'UGA Memory'
COLUMN session_uga_memory_max FORMAT 9,999,999,999 HEADING 'UGA Memory MAX'
SELECT /*+ RULE */
s.sid sid
, s.username
, s.osuser
, s.program
, s.machine 
, (select ss.value from v$sesstat ss, v$statname sn
where ss.sid = s.sid and
sn.statistic# = ss.statistic# and
sn.name = 'session pga memory') session_pga_memory
, (select ss.value from v$sesstat ss, v$statname sn
where ss.sid = s.sid and
sn.statistic# = ss.statistic# and
sn.name = 'session pga memory max') session_pga_memory_max
, (select ss.value from v$sesstat ss, v$statname sn
where ss.sid = s.sid and
sn.statistic# = ss.statistic# and
sn.name = 'session uga memory') session_uga_memory
, (select ss.value from v$sesstat ss, v$statname sn
where ss.sid = s.sid and
sn.statistic# = ss.statistic# and
sn.name = 'session uga memory max') session_uga_memory_max
FROM
v$session s
ORDER BY session_pga_memory DESC
/
EOF
logf
}

segment()
{
P1_="$1"
P2_="$2"
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 80
column owner for a20
column segment_name for a30
column segment_type for a15
column PARTITION_NAME for a50
column SEGMENT_SUBTYPE for a15
column max_size for 999,999,999,999
column tablespace_name for a22
ttitle left "Segment name from DBA_SEGMENTS:"
BREAK ON REPORT
COMPUTE SUM LABEL 'SUM' OF size_Mb on report
select tablespace_name, owner, segment_name, PARTITION_NAME, segment_type, SEGMENT_SUBTYPE, bytes/(1024*1024) size_Mb, blocks, max_size
from dba_segments where segment_name like '$P1_' and owner like nvl(trim('$P2_'),'%')
order by owner, segment_name, segment_type, PARTITION_NAME;

ttitle left "Table name from DBA_LOBS:"
column table_name for a30
column column_name for a30
select tablespace_name, owner, segment_name, table_name, column_name, partitioned, compression
from dba_lobs where table_name like '$P1_' and owner like nvl(trim('$P2_'),'%');

ttitle left "Lob segment name from DBA_SEGMENTS, DBA_LOBS:"
column index_name for a30
select s.tablespace_name, s.owner, s.segment_name, s.PARTITION_NAME, l.INDEX_NAME, s.segment_type, s.SEGMENT_SUBTYPE, s.bytes/(1024*1024) size_Mb, s.blocks, s.max_size
from dba_segments s, dba_lobs l where s.owner=l.owner and s.segment_name=l.segment_name and l.table_name like '$P1_' and s.owner like nvl(trim('$P2_'),'%')
order by owner, segment_name, segment_type, PARTITION_NAME;
EOF
logf
}

topseg()
{
$SP <<'EOF' >$LOGF
set lines 170
set echo off feed off veri off tab off pages 40
column owner for a15
column object_name for a30
column object_type for a20
column statistic_name for a25
column value for 99999999999999

prompt
prompt top row lock waits:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='row lock waits'
order by value desc
) where rownum<21;

prompt
prompt top buffer busy waits:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='buffer busy waits'
order by value desc
) where rownum<21;

prompt
prompt top logical reads:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='logical reads'
order by value desc
) where rownum<21;

prompt
prompt top physical reads\writes:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
-- where statistic_name='physical reads'
where statistic_name in ('physical reads','physical reads direct', 'physical writes','physical writes direct')
order by value desc
) where rownum<21;

prompt
prompt top space allocated:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='space allocated'
order by value desc
) where rownum<21;

prompt
prompt top ITL waits:
select * from (select owner, object_name, object_type, statistic_name, value
from v$segment_statistics
where statistic_name='ITL waits'
order by value desc
) where rownum<21;
EOF
logf
}



object()
{
P1_="$1"
if [ $(is_number $P1_) -eq 0 ]; then 
    SQL_="select OBJECT_ID, owner, object_name, object_type, CREATED, LAST_DDL_TIME, STATUS from dba_objects where object_name like upper('$P1_');"
else
    SQL_="select OBJECT_ID, owner, object_name, object_type, CREATED, LAST_DDL_TIME, STATUS from dba_objects where object_id = '$P1_';"
fi

$SP <<EOF >$LOGF
set lines 170
set echo off feed off veri off tab off pages 40
prompt
prompt dba_objects:
column object_name for a30
column owner for a30
column object_type for a20
$SQL_
EOF
logf
}


table()
{
P2_=`echo $ALL | awk '{print $2}'`
P3_=`echo $ALL | awk '{print $3}' | tr '[:lower:]' '[:upper:]'`
P4_=`echo $ALL | awk '{print $4}' | tr '[:lower:]' '[:upper:]'`
REL=$(db_version)
case $REL in
  8|9) SQL_TEXT1="" ; SQL_TEXT2="" ;;
  *)   SQL_TEXT1=" t.compression, t.compress_for, " ; SQL_TEXT2=" , HISTOGRAM " ;;
esac

case "$P2_" in
part)
$SP <<EOF >$LOGF
set lines 230 numw 6 pages 60
col OWNER for a20
col TABLE_NAME for a30
col PARTITIONING_TYPE for a6
col SUBPARTITIONING_TYPE for a6
col PARTITION_COUNT for 9999999 heading "P_CNT"
col DEF_SUBPARTITION_COUNT for 99 heading "DEF_SUBP_CNT"
col PARTITIONING_KEY_COUNT for 99 heading "P_KEY_CNT"
col SUBPARTITIONING_KEY_COUNT for 99 heading "SUBP_KEY_CNT"
col STATUS for a8
col DEF_TABLESPACE_NAME for a20 heading "DEF_TBS"
col DEF_PCT_FREE for 99 heading "PCT_FR"
col DEF_PCT_USED for 99 heading "PCT_US"
col DEF_LOGGING for a6 heading "DEF_LOG"
col DEF_COMPRESSION for a8 heading "DEF_COMPR"
col DEF_COMPRESS_FOR for a8 heading "DEF_COM_FOR"
col INTERVAL for a30
prompt dba_part_tables:
select owner,table_name,partitioning_type,subpartitioning_type,partition_count,def_subpartition_count,partitioning_key_count,subpartitioning_key_count,
status,def_tablespace_name,def_pct_free,def_pct_used,def_logging,def_compression,def_compress_for, interval from dba_part_tables
where table_name='$P3_' and owner like nvl('$P4_','%') order by owner,TABLE_NAME;

col table_owner for a20
col table_name for a30
col partition_name for a25
col high_value for a50 heading "HIGH_VALUE" 
col high_value_length for 99 heading "HVLEN"
col partition_position for 999 heading "PPOS"
col tablespace_name for a15
col logging for a4
col compression for a8
col compress_for for a8
col num_rows for 999999999 heading "ROWS"
col blocks for 999999
col empty_blocks for 9999 heading "EMPBL"
col avg_space for 9999 heading "AVGSP"
col chain_cnt for 9999 heading "CHCNT"
col avg_row_len for 9999 heading "AVGRLEN"
col sample_size for 999999999
col last_analyzed for a19
col interval for a4
col segment_created for a4  heading "SCR"
prompt dba_tab_partitions:
select table_owner,table_name,partition_name,high_value,/*high_value_length,*/partition_position,tablespace_name,logging,compression,compress_for, 
num_rows,blocks,/*empty_blocks,avg_space, chain_cnt,avg_row_len,sample_size,*/last_analyzed,interval,segment_created from DBA_TAB_PARTITIONS
where table_name='$P3_' and table_owner like nvl('$P4_','%') order by table_owner,TABLE_NAME,partition_position;

set lines 230 
set long 10000
col table_owner for a20
col table_name for a30
col subpartition_name for a30
col high_value for a50 heading "HIGH_VALUE" 
col high_value_length for 99 heading "HVLEN"
col subpartition_position for 999 heading "PPOS"
col tablespace_name for a20
col logging for a4
col compression for a8
col compress_for for a8
col num_rows for 999999999 heading "ROWS"
col blocks for 999999
col empty_blocks for 9999 heading "EMPBL"
col avg_space for 9999 heading "AVGSP"
col chain_cnt for 9999 heading "CHCNT"
col avg_row_len for 9999 heading "AVGRLEN"
col sample_size for 999999999
col last_analyzed for a17
col interval for a4
col segment_created for a4  heading "SCR"
prompt dba_tab_subpartitions:
select table_owner,table_name,subpartition_name,high_value,/*high_value_length,*/subpartition_position,tablespace_name,logging,compression,compress_for, 
num_rows,blocks,/*empty_blocks,avg_space, chain_cnt,avg_row_len,sample_size,*/last_analyzed,interval,segment_created  from DBA_TAB_SUBPARTITIONS
where table_name='$P3_' and table_owner like nvl('$P4_','%') order by table_owner,TABLE_NAME,subpartition_position;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 300
set echo off feed off veri off tab off pages 45
column owner for a20
column segment_name for a30
column table_name for a30
column logging for a6
column num_rows for 9999999999
column avg_row_len for 999999
column "SIZE_MB" for 99999999
column "EST_MB" for 99999999
column "DIFF_MB" for 99999999
column segment_type for a20
column tablespace_name for a22
column compression for a11
column compress_for for a15
column partitioned for a4
column iot_type for a8
select t.tablespace_name, owner, table_name, t.logging, num_rows, avg_row_len,
ROUND((BLOCKS*tbs.block_size/1024/1024),0) "SIZE_MB", ROUND((NUM_ROWS*AVG_ROW_LEN/1024/1024),0) "EST_MB", ROUND((BLOCKS*tbs.block_size/1024/1024),0) - ROUND((NUM_ROWS*AVG_ROW_LEN/1024/1024),0) "DIFF_MB",
last_analyzed, $SQL_TEXT1 partitioned, iot_type, temporary
from dba_tables t, dba_tablespaces tbs where t.tablespace_name=tbs.tablespace_name(+) and table_name like '$P2_' and owner like nvl('$P3_','%') order by owner;

prompt
prompt indexes:
column index_type for a15
column index_name for a33
column compression for a15
column UNIQUENESS for a10
column blevel for 99
column distinct_keys for 99999999999
column status for a10
column VISIBILITY for a9
select tablespace_name, owner, index_name, index_type, uniqueness, blevel, distinct_keys, status, num_rows, last_analyzed, compression, partitioned,VISIBILITY
from dba_indexes where table_name like '$P2_' and owner like nvl('$P3_','%') order by owner,index_name;

prompt
prompt index_columns:
column index_owner for a20
column index_name for a33
column COLUMN_NAME for a30
select index_owner,index_name,column_name,column_position,column_length,descend
from dba_ind_columns where table_name like '$P2_' and table_owner like nvl('$P3_','%') order by index_owner,index_name,column_position;
/*
prompt
prompt constraints:
column owner for a20
column r_owner for a20
column CONSTRAINT_NAME for a30
column R_CONSTRAINT_NAME for a25
col STATUS for a10
col DEFERRABLE for a15
col DEFERRED for a15
col VALIDATED for a15
select OWNER,CONSTRAINT_NAME,CONSTRAINT_TYPE, R_OWNER,R_CONSTRAINT_NAME, STATUS,DEFERRABLE,DEFERRED,VALIDATED,LAST_CHANGE,INVALID
from dba_constraints where upper(table_name) = '$P2_' and owner like nvl('$P3_','%') order by owner,CONSTRAINT_NAME;
*/
prompt
prompt columns statistic information:
col owner for a20
col table_name for a25
col COLUMN_NAME for a30
col NUM_DISTINCT for 999999999999
col NUM_NULLS for 999999999999
col NUM_BUCKETS for 99999
col SAMPLE_SIZE for 999999999999
col low_value for a15
col high_value for a15
col HISTOGRAM for a30
select OWNER,COLUMN_NAME,NUM_DISTINCT,DENSITY,NUM_NULLS,NUM_BUCKETS,LAST_ANALYZED,SAMPLE_SIZE,GLOBAL_STATS,USER_STATS,AVG_COL_LEN $SQL_TEXT2
from dba_tab_col_statistics where table_name like '$P2_' and owner like nvl('$P3_','%') order by owner,table_name,COLUMN_NAME;
EOF
;;
esac
logf
}


index()
{
P2_=`echo $ALL | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
P3_=`echo $ALL | awk '{print $3}' | tr '[:lower:]' '[:upper:]'`
P4_=`echo $ALL | awk '{print $4}' | tr '[:lower:]' '[:upper:]'`

case "$P2_" in
PART)
$SP <<EOF >$LOGF
set lines 230 numw 6
set echo off feed off veri off tab off pages 70
col OWNER for a20
col INDEX_NAME for a30
col TABLE_NAME for a30
col PARTITIONING_TYPE for a6
col SUBPARTITIONING_TYPE for a6
col PARTITION_COUNT for 9999999 heading "P_CNT"
col PARTITIONING_KEY_COUNT for 99 heading "P_KEY_CNT"
col SUBPARTITIONING_KEY_COUNT for 99 heading "SUBP_KEY_CNT"
col DEF_TABLESPACE_NAME for a20 heading "DEF_TBS"
col DEF_PCT_FREE for 99 heading "PCT_FR"
prompt DBA_PART_INDEXES
select owner,index_name,table_name,partitioning_type,subpartitioning_type,partition_count,partitioning_key_count,subpartitioning_key_count, def_tablespace_name,def_pct_free 
from dba_part_indexes where (table_name='$P3_' or  index_name='$P3_') and owner like nvl('$P4_','%') order by owner,table_name,index_name;

col index_owner for a20
col index_name for a30
col partition_name for a30
col high_value for a25 heading "HIGH_VALUE" 
--col high_value_length for 99 heading "HVLEN"
col partition_position for 9999 heading "PPOS"
col status for a8
col tablespace_name for a20
col pct_free for 999 heading "PFRE"
col compression for a8
col blevel for 999 heading "BLEV"
col leaf_blocks for 9999999 heading "LEAF_B"
col distinct_keys for 999999 heading "DIS_KEYS"
col num_rows for 999999999 heading "ROWS"
col last_analyzed for a19
col global_stats  for a3 heading "GLST"
col interval for a4
col segment_created for a4  heading "SCR"
prompt DBA_IND_PARTITIONS
select index_owner,index_name,partition_name,high_value,/*high_value_length,*/ partition_position, status,tablespace_name, pct_free,compression,
blevel, leaf_blocks,distinct_keys,num_rows,last_analyzed,global_stats,interval,segment_created 
from DBA_IND_PARTITIONS where index_name='$P3_' and index_owner like nvl('$P4_','%') order by index_owner,index_name,partition_position;

col subpartition_position for 999 heading "PPOS"
prompt DBA_IND_SUBPARTITIONS
select index_owner,index_name,partition_name,high_value,/*high_value_length,*/subpartition_position, status,tablespace_name, pct_free,compression,
blevel, leaf_blocks,distinct_keys,num_rows,last_analyzed,global_stats,interval,segment_created 
from DBA_IND_SUBPARTITIONS where index_name='$P3_' and index_owner like nvl('$P4_','%') order by index_owner,index_name,subpartition_position;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 70

prompt
column tablespace_name for a15
column owner for a20
column index_type for a15
column table_name for a33
column index_name for a33
column compression for a12
column UNIQUENESS for a10
column distinct_keys for 9999999999
column num_rows for 9999999999
column status for a10
column partitioned for a4
column degree for a2
column VISIBILITY for a9
prompt dba_indexes for index_name = $P2_
select tablespace_name,table_name,owner,index_name,index_type,uniqueness,distinct_keys, status, num_rows, last_analyzed, compression, partitioned, degree, VISIBILITY
from dba_indexes where upper(index_name) = upper('$P2_') order by owner,index_name;

set longc 100000000
column index_owner for a30
column index_name for a30
column table_owner for a30
column table_name for a30
column column_expression for a50
column column_position for 99
prompt dba_ind_expressions for index_name = $P2_
select index_owner,index_name,table_owner,table_name,column_expression,column_position from dba_ind_expressions where upper(index_name) = upper('$P2_') order by table_owner,table_name,index_name,column_position;
EOF
;;
esac
logf
}



constraint()
{
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
P3_=`echo $ALL | awk '{print $3}' | tr '[:lower:]' '[:upper:]'`
P4_=`echo $ALL | awk '{print $4}' | tr '[:lower:]' '[:upper:]'`

#echo "P1_: "$P1_"  P2_: "$P2_"  P3_: "$P3_

SET_COLUMNS="column owner for a17
column table_name for a25
column constraint_name for a25
column column_name for a20
column position for 99 heading 'P'
column constraint_type for a2
column search_condition for a30
column r_owner for a17
column r_constraint_name for a25
column delete_rule for a10
column status for a9
column deferrable for a14
column deferred for a10
column validated for a10
column last_change for a19"

case "$P2_" in
T)
$SP <<EOF >$LOGF
set lines 230 pages 60
set echo off feed off veri off tab off
set longc 100000000
prompt
prompt dba_constraints dba_cons_columns for table: $P3_
$SET_COLUMNS
select col.owner,col.table_name,col.constraint_name,column_name,position,c.constraint_type,c.search_condition,
c.r_owner,c.r_constraint_name,c.delete_rule,c.status, /*c.deferrable,c.deferred,*/ c.validated,c.last_change
from DBA_CONS_COLUMNS col, dba_constraints c
where c.owner=col.owner and c.table_name=col.table_name and c.constraint_name=col.constraint_name
--and c.owner='DMS'
and col.table_name='$P3_'
order by col.table_name, col.constraint_name, col.position;
EOF
;;
PK)
$SP <<EOF >$LOGF
set lines 230 pages 60
column owner for a30
column constraint_name for a30
column table_name for a30
PROMPT
PROMPT What Foregin Key references to PK: $P3_
select owner, constraint_name, table_name from all_constraints where constraint_type='R' and r_constraint_name='$P3_';
PROMPT
PROMPT Script to disable the restriction that refers to the PK: $P3_:
select 'alter table '||owner||'.'||table_name||' disable constraint '|| constraint_name||';' script from dba_constraints where constraint_type='R' and r_constraint_name='$P3_';
EOF
;;
FK)
$SP <<EOF >$LOGF
set lines 230 pages 60
column owner for a20
column table_name for a30
column constraint_name for a30
column columns for a22
column create_index_ddl for a123
PROMPT Tables with non-indexed foreign keys: Table: $P3_:
SELECT   owner, table_name,
           constraint_name,
              cname1
           || NVL2 (cname2, ',' || cname2, NULL)
           || NVL2 (cname3, ',' || cname3, NULL)
           || NVL2 (cname4, ',' || cname4, NULL)
           || NVL2 (cname5, ',' || cname5, NULL)
           || NVL2 (cname6, ',' || cname6, NULL)
           || NVL2 (cname7, ',' || cname7, NULL)
           || NVL2 (cname8, ',' || cname8, NULL)
               columns,
               'create index '||owner||'.'||'IDX_'||constraint_name||'_'||rownum||' on '||owner||'.'||table_name||'('||cname1|| NVL2 (cname2, ',' || cname2, NULL)|| NVL2 (cname3, ',' || cname3, NULL)|| NVL2 (cname4, ',' || cname4, NULL)|| NVL2 (cname5, ',' || cname5, NULL)|| NVL2 (cname6, ',' || cname6, NULL)|| NVL2 (cname7, ',' || cname7, NULL)|| NVL2 (cname8, ',' || cname8, NULL)||') tablespace '||(select  tablespace_name from dba_indexes where table_name like '$P3_' and owner like '%$P4_%' and rownum=1)||';' create_index_ddl
    FROM   (  SELECT   b.owner, b.table_name,
                       b.constraint_name,
                       MAX (DECODE (position, 1, column_name, NULL)) cname1,
                       MAX (DECODE (position, 2, column_name, NULL)) cname2,
                       MAX (DECODE (position, 3, column_name, NULL)) cname3,
                       MAX (DECODE (position, 4, column_name, NULL)) cname4,
                       MAX (DECODE (position, 5, column_name, NULL)) cname5,
                       MAX (DECODE (position, 6, column_name, NULL)) cname6,
                       MAX (DECODE (position, 7, column_name, NULL)) cname7,
                       MAX (DECODE (position, 8, column_name, NULL)) cname8,
                       COUNT ( * ) col_cnt
                FROM   (SELECT   SUBSTR (table_name, 1, 30) table_name,
                                 SUBSTR (constraint_name, 1, 30) constraint_name,
                                 SUBSTR (column_name, 1, 30) column_name,
                                 position
                          FROM   dba_cons_columns) a, dba_constraints b
               WHERE   a.constraint_name = b.constraint_name and b.owner like '%$P4_%'  and b.table_name like '$P3_'
                       AND b.constraint_type = 'R'
            GROUP BY   b.owner, b.table_name, b.constraint_name) cons
   WHERE   col_cnt >
               ALL (  SELECT   COUNT ( * )
                        FROM   dba_ind_columns i
                       WHERE   i.table_name = cons.table_name and i.table_owner like '%$P4_%' and i.table_name like '$P3_'
                               AND i.column_name IN
                                          (cname1,
                                           cname2,
                                           cname3,
                                           cname4,
                                           cname5,
                                           cname6,
                                           cname7,
                                           cname8)
                               AND i.column_position <= cons.col_cnt
                    GROUP BY   i.index_name)
ORDER BY  owner, table_name, constraint_name, columns;
EOF
;;
*) 
$SP <<EOF >$LOGF
set lines 230 pages 60
set echo off feed off veri off tab off
set longc 100000000
prompt
prompt dba_constraints dba_cons_columns for constraint: $P2_
$SET_COLUMNS
select col.owner,col.table_name,col.constraint_name,column_name,position,c.constraint_type,c.search_condition,
c.r_owner,c.r_constraint_name,c.delete_rule,c.status, /*c.deferrable,c.deferred,*/ c.validated,c.last_change
from DBA_CONS_COLUMNS col, dba_constraints c 
where c.owner=col.owner and c.table_name=col.table_name and c.constraint_name=col.constraint_name
--and c.owner='DMS' 
and col.constraint_name='$P2_' 
order by col.table_name, col.constraint_name, col.position;
EOF
;;
esac
logf
}



lob()
{
P1_=$1
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 40
column owner for a20
column segment_name for a30
column table_name for a30
column index_name for a30
column column_name for a30
column segment_type for a20
column tablespace_name for a15
column compression for a15
prompt
prompt Segment from dba_lobs where segment_name = upper('$P1_');
select owner,table_name,column_name,segment_name,tablespace_name,index_name,partitioned from dba_lobs where segment_name = upper('$P1_');
prompt
prompt Index from dba_lobs where index_name = upper('$P1_');
select owner,table_name,column_name,segment_name,tablespace_name,index_name,partitioned from dba_lobs where index_name = upper('$P1_');
EOF
logf
}



redo()
{
P1_=`echo $* | awk '{print $1}'`
case "$P1_" in
logs)
$SP <<'EOF' >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column member for a80
select group#, member, type, status from v$logfile order by group#,member;
column bytes for 99,999,999,999
select group#, bytes, status, archived, SEQUENCE# from v$log;
EOF
;;
*)
$SP <<'EOF' >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
prompt Top 25 ACTIVE Sessions Generating Lots of Redo v$session, v$sess_io:
col sid for 99999
col serial# for 9999999
col username for a25
col osuser for a25
col pma for a100
col changes for 999,999,999 heading "Changes Mb"
select * from (
--SELECT s.sid, s.serial#, s.username, s.osuser, REGEXP_REPLACE(CONVERT(s.program||' \ '||s.module||' \ '||s.action, 'AL32UTF8', 'CL8MSWIN1251'), '[^[:print:]]', '') pma, i.block_changes, round(i.block_changes * TO_NUMBER(x.value)/(1024*1024),0) changes
SELECT s.sid, s.serial#, s.username, s.osuser, s.program||' \ '||s.module||' \ '||s.action pma, i.block_changes, round(i.block_changes * TO_NUMBER(x.value)/(1024*1024),0) changes
FROM v$session s, v$sess_io i, sys.v_$parameter x
WHERE s.sid = i.sid and BLOCK_CHANGES > 0 and s.serial#<>'1' and s.type <> 'BACKGROUND' and x.name  = 'db_block_size' and s.status='ACTIVE'
ORDER BY i.block_changes desc, 1, 2, 3, 4
) where rownum < 26;

prompt Top 25 ACTIVE Sessions Generating Lots of Redo v$session, v$transactionv Run the query multiple times and examine the delta between each occurrence of USED_UBLK and USED_UREC:
select * from (
SELECT s.sid, s.serial#, s.username, s.program, t.used_ublk, t.used_urec, t.start_time
FROM v$session s, v$transaction t
WHERE s.taddr = t.addr and s.status='ACTIVE'
ORDER BY 7 , 5 desc, 6 desc, 1, 2, 3, 4
) where rownum < 26;
EOF
esac
logf
}


undo()
{
P1_=`echo $* | awk '{print $1}'`
case "$P1_" in
recovery) 
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
prompt
prompt Recovering transactions v\$fast_start_transactions:
col usn for 9999
col estimated for a19 heading "Estimated time"
select usn, state, xid, pid, rcvservers,
--undoblockstotal "TotalBlk", undoblocksdone "DoneBlk", undoblockstotal-undoblocksdone "ToDoBlk",
round(undoblockstotal * TO_NUMBER(x.value)/(1024*1024),2) "Total Mb", round(undoblocksdone * TO_NUMBER(x.value)/(1024*1024),2) "Done Mb", round((undoblockstotal-undoblocksdone) * TO_NUMBER(x.value)/(1024*1024),2) "ToDo Mb",
decode(cputime,0,'unknown',sysdate+(((undoblockstotal-undoblocksdone) / (undoblocksdone / cputime)) / 86400)) estimated, sysdate
from v\$fast_start_transactions, sys.v_\$parameter x where x.name  = 'db_block_size' and state='RECOVERING' order by undoblockstotal desc;

prompt
prompt If v\$fast_start_transactions not work then x\$ktuxe:
col sysdate for a22
col ktuxesiz for 999999999 heading "Rollback Blk"
col undo for 9,999,999.00 heading "Undo Mb"
select ktuxeusn, to_char(sysdate,'DD/MM/YYYY HH24:MI:SS') "SYSDATE", ktuxesiz, round(ktuxesiz*8192/(1024*1024),2) undo, ktuxesta
from x\$ktuxe where ktuxecfl = 'DEAD' and ktuxesiz>0;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
prompt
prompt Sessions with active transactions v\$session, v\$transaction, dba_undo_extents (F: 0-triansaction, 8-rollback), estimate USED_UBLK: (used_later / (used_now - used_later)) :
col sid for 99999
col serial# for 9999999
col username for a15
col osuser for a15
col segment_name for a23
col used_ublk for 9999999
col undo for 99,999 heading "Undo Mb"
col extent_id for 99999 heading "ExtCNT"
col pma for a70 heading "PROGRAM \ MODULE \ ACTION"
col status for a10
col last_call_et for a25
SELECT s.sid, s.serial#, s.username, s.osuser, u.segment_name, t.XID, substr(to_char(t.flag,'0000000X'),length(to_char(t.flag,'0000000X'))-1,1) flag, count(u.extent_id) extent_id, t.used_ublk,
round(t.used_ublk * TO_NUMBER(x.value)/(1024*1024),2) undo, s.program||' \ '||s.module||' \ '||s.action pma, u.status,
to_char(sysdate-(s.last_call_et/60/60/24), 'Dy HH24:MI:SS') || ' - ' || ltrim(to_char(s.last_call_et/60, '9999990.0')) || ' min' last_call_et
FROM v\$session s, v\$transaction t, dba_undo_extents u, sys.v_\$parameter x
WHERE s.taddr = t.addr and u.segment_name like '_SYSSMU'||t.xidusn||'_%$' and u.status = 'ACTIVE' and x.name  = 'db_block_size'
GROUP BY s.sid, s.serial#, s.username, s.osuser, u.segment_name, t.xid, to_char(t.flag,'0000000X'), t.used_ublk, round(t.used_ublk * TO_NUMBER(x.value)/(1024*1024),2), s.program||' \ '||s.module||' \ '||s.action, u.status, s.last_call_et
ORDER BY t.used_ublk desc, s.sid, s.serial#, s.username;
EOF
;;
esac
logf
}



sesstat()
{
P1_=`echo $* | awk '{print $1}'`
P2_=`echo $* | awk '{print $2}'`
SET_COL='set lines 230
set echo off feed off veri off tab off pages 70
col sid for 99999
col serial# for 999999
col username for a25
col osuser for a20
col module for a50
col action for a30
col name for a70
col value for 999999999999999'

case "$P1_" in
list)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
select statistic#, name, decode(class, 1, 'User', 2, 'Redo', 4, 'Enqueue', 8, 'Cache', 16, 'OS', 32, 'RAC', 64, 'SQL', 128, 'Debug', 'Unknown') CLASS from v\$statname;
EOF
;;
sess)
shift
shift
ALL="$*"
echo "sess) ALL: " $ALL
$SP <<EOF >$LOGF
$SET_COL
prompt
prompt Top 60 Session event for SID = $P2_ and name like "$ALL%":
select * from (
select b.sid, s.serial#, s.username, s.osuser, s.module, a.name, decode(class, 1, 'User', 2, 'Redo', 4, 'Enqueue', 8, 'Cache', 16, 'OS', 32, 'RAC', 64, 'SQL', 128, 'Debug', 'Unknown') CLASS, b.value
from v\$statname a, v\$sesstat b, v\$session s where a.statistic#=b.statistic#
and s.sid=b.sid and s.serial#<>'1' and s.sid = '$P2_' and name like '$ALL%' order by value desc
) where rownum < 61;
EOF
;;
*)
echo "*) ALL: " $ALL
$SP <<EOF >$LOGF
$SET_COL
prompt
prompt Sessions of top 60 event $P1:
select * from (
select b.sid, s.serial#, s.username, s.osuser, s.module, a.name, decode(class, 1, 'User', 2, 'Redo', 4, 'Enqueue', 8, 'Cache', 16, 'OS', 32, 'RAC', 64, 'SQL', 128, 'Debug', 'Unknown') CLASS, b.value
from v\$statname a, v\$sesstat b, v\$session s where a.statistic#=b.statistic#
and s.sid=b.sid and s.serial#<>'1' and name like '$ALL%' order by value desc
) where rownum < 61;
EOF
;;
esac
logf
}




dbsize()
{
CNT=$1
if [ -z "$CNT" ]; then
 CNT=7
fi
$SP <<EOF >$LOGF
set lines 180
set echo off feed off veri off tab off pages 40
--size by hour
set numw 15 pages 50
column sum_mb format 999,999,999,999
BREAK ON REPORT
COMPUTE AVG SUM LABEL 'SUM' OF sum_Mb  on report
ttitle left "Archive logs size information by last $CNT hours:"
select to_char(first_time,'dd/mm/yyyy HH24') date_by_hours, round(sum(blocks*block_size)/1024/1024) sum_Mb from v\$archived_log
where dest_id=(select dest_id from V\$ARCHIVE_DEST where status='VALID' and archiver='ARCH' and valid_type in ('ONLINE_LOGFILE','ALL_LOGFILES')) and first_time>sysdate-($CNT/24) group by to_char(first_time,'dd/mm/yyyy HH24') order by 1;
ttitle off

--size by day and avg size
set numw 15 pages 50
column sum_mb format 999,999,999,999
BREAK ON REPORT
COMPUTE AVG SUM LABEL 'SUM' OF sum_Mb  on report
ttitle left "Archive logs size information by last $CNT days:"
select trunc(first_time) date_, round(sum(blocks*block_size)/1024/1024) sum_Mb from v\$archived_log
where dest_id=(select dest_id from V\$ARCHIVE_DEST where status='VALID' and archiver='ARCH' and valid_type in ('ONLINE_LOGFILE','ALL_LOGFILES')) and first_time>sysdate-$CNT group by trunc(first_time) order by 1;
ttitle off

ttitle left "Archived logs Switches information and SizeGb from v\$arhived_log by last $CNT days:"
alter session set nls_date_format='dd/mm/yy';
set pages 999 lines 400
col Day for a3
col thread# for 999
col TotalSwitch for 9999 heading "Total|Switch"
col TotalSizeGb for 999,999.99 heading "Total|Size GB"
col h00 format 999.9
col h01 format 999.9
col h02 format 999.9
col h03 format 999.9
col h04 format 999.9
col h05 format 999.9
col h06 format 999.9
col h07 format 999.9
col h08 format 999.9
col h09 format 999.9
col h10 format 999.9
col h11 format 999.9
col h12 format 999.9
col h13 format 999.9
col h14 format 999.9
col h15 format 999.9
col h16 format 999.9
col h17 format 999.9
col h18 format 999.9
col h19 format 999.9
col h20 format 999.9
col h21 format 999.9
col h22 format 999.9
col h23 format 999.9
col AvgGb for 9999.00
SELECT TRUNC (first_time) "Date", THREAD# , TO_CHAR (first_time, 'Dy') "Day",
COUNT (1) "TotalSwitch", sum(round((blocks * block_size)/(1024*1024*1024),2)) "TotalSizeGb",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '00', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h00",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '01', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h01",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '02', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h02",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '03', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h03",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '04', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h04",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '05', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h05",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '06', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h06",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '07', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h07",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '08', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h08",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '09', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h09",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '10', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h10",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '11', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h11",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '12', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h12",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '13', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h13",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '14', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h14",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '15', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h15",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '16', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h16",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '17', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h17",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '18', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h18",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '19', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h19",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '20', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h20",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '21', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h21",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '22', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h22",
SUM (DECODE (TO_CHAR (first_time, 'hh24'), '23', round((blocks * block_size)/(1024*1024*1024),2), 0)) "h23",
ROUND ( sum((blocks * block_size)/(1024*1024*1024)) / 24, 2) AvgGb
FROM v\$archived_log
WHERE thread# = 1 and dest_id=(select dest_id from V\$ARCHIVE_DEST where status='VALID' and archiver='ARCH' and valid_type in ('ONLINE_LOGFILE','ALL_LOGFILES'))
AND first_time > sysdate - $CNT
GROUP BY TRUNC (first_time),"THREAD#" , TO_CHAR (first_time, 'Dy')
ORDER BY 1,2;


ttitle left "Archive logs dest information from v\$arhive_dest:"
column status for a10
column dest_name for a30
column destination for a90
select dest_name, status, destination from v\$archive_dest where status<>'INACTIVE';

column Db_size_Gb format 999,999,999,999
ttitle left "Overall database size:"
column DB_size_MB format 999,999,999,999.00
select round(sum(s),2) DB_size_MB from
(select sum(bytes/(1024*1024)) s from dba_data_files
union
select sum(bytes/(1024*1024)) s from dba_temp_files
union
select sum(bytes/(1024*1024)) s from v\$log
);
ttitle off
EOF
logf
}


grows()
{
CNT=$1
if [ -z "$CNT" ]; then
 CNT=7
fi
$SP <<EOF >$LOGF
set lines 180
set echo off feed off veri off tab off pages 50
PROMPT Database grows size information from v\$datafile by last year:
select to_char(creation_time, 'RRRR MM') "Month",
trunc(sum(bytes)/1024/1024/1024) "Growth in Gb"
from sys.v_\$datafile
where creation_time > SYSDATE-365
group by to_char(creation_time, 'RRRR MM')
order by 1;
PROMPT
PROMPT "DBA_HIST_SEG_STAT: The database grows for $CNT days:"
PROMPT
set serveroutput on
Declare
  v_BaselineSize  number(20);
  v_CurrentSize   number(20);
  v_TotalGrowth   number(20);
  v_Space         number(20);
  v_Space2        number(20);
  cursor usageHist is
          select a.snap_id, SNAP_TIME, sum(TOTAL_SPACE_ALLOCATED_DELTA) over ( order by a.SNAP_ID) ProgSum
      from
        (select ccast, max(snap_id) snap_id, sum(TOTAL_SPACE_ALLOCATED_DELTA) TOTAL_SPACE_ALLOCATED_DELTA from (
            select SNAP_ID, trunc(row_number() over (order by snap_id ) ) ccast,
            sum(SPACE_ALLOCATED_DELTA) TOTAL_SPACE_ALLOCATED_DELTA
            from DBA_HIST_SEG_STAT
            group by SNAP_ID
            having sum(SPACE_ALLOCATED_TOTAL)>0
            order by 1
            )
        group by ccast
        order by ccast
         ) a,
          (select distinct SNAP_ID, to_char(END_INTERVAL_TIME,'DD-Mon-YYYY HH24:Mi') SNAP_TIME from DBA_HIST_SNAPSHOT where end_interval_time > sysdate-$CNT ) b
      where a.snap_id=b.snap_id;
Begin
    select sum(SPACE_ALLOCATED_DELTA) into v_TotalGrowth from DBA_HIST_SEG_STAT;
    select sum(bytes) into v_CurrentSize from dba_segments;
    v_BaselineSize := v_CurrentSize - v_TotalGrowth ;

    dbms_output.put_line('SNAP_TIME                    Database Size(MB)      Grows Size(MB)');
    v_Space2:=0;
    for row in usageHist loop
            v_Space := (v_BaselineSize + row.ProgSum)/(1024*1024);
            v_Space2 := v_Space-v_Space2;
        dbms_output.put_line(row.SNAP_TIME || '  ' || to_char(v_Space,'999,999,999,999,999')|| '           ' || to_char(v_Space2,'999,999,999') );
            v_Space2 := v_Space;
    end loop;
end;
/
EOF
logf
}



tbs()
{
P1_=`echo $ALL | awk '{print $1}' | tr '[:lower:]' '[:upper:]'`
case "$P1_" in
FREE)
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
select a.tablespace_name as "Tablespace Name",
       round(maxbytes/1024 / 1024) "Max. Bytes (MB)",
       round(a.bytes_alloc / 1024 / 1024) "Allocated (MB)",
       round(nvl(b.bytes_free, 0) / 1024 / 1024) "Free (MB)",
       round((a.maxbytes - nvl(b.bytes_free, 0)) / 1024 / 1024) "Used (MB)",
       round(((nvl(b.bytes_free, 0)) / a.maxbytes) * 100,2) "% Free",
       100 - round(((nvl(b.bytes_free, 0)) / a.maxbytes) * 100,2) "% Used"
from  ( select  f.tablespace_name,
               sum(f.bytes) bytes_alloc,
               sum(decode(f.autoextensible, 'YES', f.maxbytes, 'NO', f.bytes)) maxbytes
            from dba_data_files f
            group by tablespace_name) a,
      ( select tablespace_name, sum(free) bytes_free from
          ( select d.tablespace_name, d.file_name, case when autoextensible='YES' then (d.maxbytes-d.bytes)+nvl(f.bytes,0) else nvl(f.bytes,0) end free
               from (select tablespace_name, file_id, sum(bytes) bytes from dba_free_space
           group by tablespace_name,file_id) f, dba_data_files d where f.file_id(+)=d.file_id )
          group by tablespace_name
      ) b
where a.tablespace_name = b.tablespace_name (+)
union all
select f.tablespace_name,
round(sum(f.total_bytes/(1024*1024))) total,
sum(s.used_blocks*f.block_size/(1024*1024)),
round(sum(f.total_bytes/(1024*1024))-sum(s.used_blocks*f.block_size/(1024*1024))) free,
sum(s.used_blocks*f.block_size/(1024*1024)),
round(((sum(f.total_bytes)-sum(s.used_blocks*f.block_size))/sum(f.total_bytes))*100) free_per,
100-round(((sum(f.total_bytes)-sum(s.used_blocks*f.block_size))/sum(f.total_bytes))*100) used_per from
( select tablespace_name, block_size, sum(total_bytes) total_bytes from (
 select f.tablespace_name, case when autoextensible='YES' then f.maxbytes else f.user_bytes end total_bytes, t.block_size from dba_temp_files f, dba_tablespaces t
 where t.contents='TEMPORARY' and f.tablespace_name=t.tablespace_name )
group by tablespace_name, block_size ) f,
 v\$sort_segment s
where f.tablespace_name=s.tablespace_name
group by f.tablespace_name
ORDER BY "% Used" desc;

exit
column tablespace_name for a30
column free for 999999999.99
column total for 999999999.99
column used_per for 9999.99
select  /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */ /*+ NO_MONITOR */  t.tablespace_name, free, total, 100-((free/total)*100) used_per from
(select tablespace_name,sum(total)/(1024*1024) total from
  (select tablespace_name, case when autoextensible='YES' then maxbytes else bytes end total from dba_data_files)
group by tablespace_name) t,
(select tablespace_name, sum(free)/(1024*1024) free from
  (select d.tablespace_name, d.file_name, case when autoextensible='YES' then (d.maxbytes-d.bytes)+nvl(f.bytes,0) else nvl(f.bytes,0) end free
  from (select tablespace_name, file_id, sum(bytes) bytes from dba_free_space group by tablespace_name,file_id) f,dba_data_files d where f.file_id(+)=d.file_id
)
group by tablespace_name) f
where t.tablespace_name = f.tablespace_name
union
select f.tablespace_name, (sum(f.total_bytes/(1024*1024))-sum(s.used_blocks*f.block_size/(1024*1024))) free, sum(f.total_bytes/(1024*1024)) total,
100-(((sum(f.total_bytes)-sum(s.used_blocks*f.block_size))/sum(f.total_bytes))*100) used_per from
( select tablespace_name, block_size, sum(total_bytes) total_bytes from (
 select f.tablespace_name, case when autoextensible='YES' then f.maxbytes else f.user_bytes end total_bytes, t.block_size from dba_temp_files f, dba_tablespaces t
 where t.contents='TEMPORARY' and f.tablespace_name=t.tablespace_name )
group by tablespace_name, block_size ) f,
 v\$sort_segment s
where f.tablespace_name=s.tablespace_name
group by f.tablespace_name order by used_per desc;
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 230
column TABLESPACE_NAME for a30
column BLOCK_SIZE for 99999
column status for a10
column contents for a10
column logging for a10
column EXTENT_MANAGEMENT for a10
column ALLOCATION_TYPE for a10
column SEGMENT_SPACE_MANAGEMENT for a10
column retention for a12
column DEF_TAB_COMPRESSION for a13
column encrypted for a10
select TABLESPACE_NAME,BLOCK_SIZE,status,contents,logging,EXTENT_MANAGEMENT,ALLOCATION_TYPE,SEGMENT_SPACE_MANAGEMENT,retention,DEF_TAB_COMPRESSION,encrypted from dba_tablespaces order by contents,TABLESPACE_NAME;
EOF
;;
esac
logf
}


temp()
{
$SP <<'EOF' >$LOGF
TTitle left "TEMP Tablespace Usage information:" skip 1
SET PAGESIZE 60
SET LINESIZE 230
COLUMN tablespace FORMAT A12
COLUMN temp_size FORMAT 99,999,999 heading "TEMP_SIZE Mb"
COLUMN spid FORMAT a8
COLUMN sid_serial FORMAT A15
COLUMN username FORMAT A20
COLUMN osuser FORMAT A20
COLUMN machine FORMAT A30
COLUMN program FORMAT A45
COLUMN STATUS FORMAT A8
SELECT b.tablespace,
        ROUND(((b.blocks*p.value)/1024/1024),2) temp_size,
        p.spid,
        a.sid||' '||a.serial# AS sid_serial,
        NVL(a.username, '(oracle)') AS username,
        a.osuser AS osuser,
        a.machine AS machine,
        a.program,
        a.status,
        a.sql_id
FROM gv$session a,
     v$process p,
     gv$sort_usage b,
     gv$parameter p
WHERE p.addr(+) = a.paddr
AND a.type <> 'BACKGROUND'
AND p.name  = 'db_block_size'
AND a.saddr = b.session_addr
AND a.inst_id=b.inst_id
AND a.inst_id=p.inst_id
and a.status<>'INACTIVE'
ORDER BY b.tablespace, b.blocks desc;

col free for 999,999 heading "FREE Mb"
col total for 999,999 heading "TOTAL Mb"
col used_per for 999.00
select f.tablespace_name, (sum(f.total_bytes/(1024*1024))-sum(s.used_blocks*f.block_size/(1024*1024))) free, sum(f.total_bytes/(1024*1024)) total,
100-(((sum(f.total_bytes)-sum(s.used_blocks*f.block_size))/sum(f.total_bytes))*100) used_per from
( select tablespace_name, block_size, sum(total_bytes) total_bytes from (
 select f.tablespace_name, case when autoextensible='YES' then f.maxbytes else f.user_bytes end total_bytes, t.block_size from dba_temp_files f, dba_tablespaces t
 where t.contents='TEMPORARY' and f.tablespace_name=t.tablespace_name )
group by tablespace_name, block_size ) f,
 v$sort_segment s
where f.tablespace_name=s.tablespace_name
group by f.tablespace_name;
EOF
logf
}



df()
{
P1_=`echo $ALL | awk '{print $1}' | tr '[:lower:]' '[:upper:]'`
P2_=`echo $ALL | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
case "$P1_" in
IO)
$SP <<'EOF' >$LOGF
set lines 220
set echo off feed off veri off tab off pages 80
set numwidth 15
col file# for 999 heading "ID"
col name for a52 heading "File Name"
col phyrds for 9999999999 heading "Phy Reads"
col phywrts for 9999999999 heading "Phy Writes"
col phyblkrd for 9999999999 heading "Blk Reads"
col phyblkwrt for 9999999999 heading "Blk Writes"
col readtim for 999999999 heading "Read Time"
col writetim for 9999999999 heading "Write Time"
column "File Total" format 99,999,999,999,999
ttitle left "DataFile's Disk Activity information:"
select df.file#, name, phyrds, phywrts, phyblkrd, phyblkwrt, readtim, writetim,
       (sum(phyrds+phywrts+phyblkrd+phyblkwrt+readtim)) "File Total"
from v$filestat fs, v$datafile df
where fs.file# = df.file#
group by df.file#, df.name, phyrds, phywrts, phyblkrd, phyblkwrt, readtim, writetim
order by sum(phyrds+phywrts+phyblkrd+phyblkwrt+readtim) desc, df.name;
EOF
;;
USAGE)
$SP <<'EOF' >$LOGF
set lines 220
set echo off feed off veri off tab off pages 40
set numwidth 15

column "Total Bytes" format 9,999,999,999,999
column "SQL Blocks" format 999,999,999,999
column "VMS Blocks" format 999,999,999,999
column "Bytes Free" format 9,999,999,999,999
column "Bytes Used" format 9,999,999,999,999
column "% Free" format 9999.999
column "% Used" format 9999.999
break on report
compute sum of "Total Bytes" on report
compute sum of "SQL Blocks" on report
compute sum of "VMS Blocks" on report
compute sum of "Bytes Free" on report
compute sum of "Bytes Used" on report
compute avg of "% Free" on report
compute avg of "% Used" on report
TTitle left "Tablespace\Datafiles Usage information:" skip 1
select  substr(fs.FILE_ID,1,3) "ID#",
        fs.tablespace_name,
        df.bytes "Total Bytes",
        df.blocks "SQL Blocks",
        df.bytes/512 "VMS Blocks",
        sum(fs.bytes) "Bytes Free",
        (100*((sum(fs.bytes))/df.bytes)) "% Free",
        df.bytes-sum(fs.bytes) "Bytes Used",
    (100*((df.bytes-sum(fs.bytes))/df.bytes)) "% Used"
from sys.dba_data_files df, sys.dba_free_space fs
where df.file_id(+) = fs.file_id
group by fs.FILE_ID, fs.tablespace_name, df.bytes, df.blocks
order by fs.tablespace_name;
EOF
;;
LASTSEG)
echo $P2_
if [ -z "$P2_" ];then
 P2_="%"
fi
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
column owner for a15
column FILE_ID for 9999
column segment_name for a33
column segment_type for a20
column partition_name for a15
column tablespace_name for a22
select /*+ R ULE */ * from dba_extents eo where (eo.file_id, eo.block_id) in (select e.file_id, max(BLOCK_ID) from dba_extents e
where e.tablespace_name like upper('$P2_')
and e.file_id in (select f.file_id from dba_data_files f where f.tablespace_name like upper('$P2_') )
group by e.file_id)
order by eo.file_id
/

prompt
prompt Smallest used position in datafiles:
set verify off
column file_name format a70 word_wrapped
column smallest format 999,990 heading "Smallest|Size|Poss."
column currsize format 999,990 heading "Current|Size"
column savings  format 999,990 heading "Poss.|Savings"
break on report
compute sum of savings on report

column value for a10 new_val blksize
select value from v\$parameter where name = 'db_block_size'
/

select a.file_id, file_name, ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) smallest, ceil( blocks*&&blksize/1024/1024) currsize,
       ceil( blocks*&&blksize/1024/1024) - ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) savings
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+) and a.tablespace_name like upper('$P2_')
/

column cmd format a150 word_wrapped
prompt
prompt Script with commands for resize datafiles:
select 'alter database datafile '''||file_name||''' resize ' ||
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 )  || 'm;' cmd
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+)
  and ceil( blocks*&&blksize/1024/1024) - ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) > 0
  and a.tablespace_name like upper('$P2_')
/
EOF
;;
*)
case $(db_is_open) in
 OPEN) SQL_="select ddf.tablespace_name,ddf.file_id,ddf.file_name,df.status,df.enabled, df.block_size, ddf.bytes, ddf.maxbytes, ddf.autoextensible from v\$datafile df, dba_data_files ddf where ddf.file_id=df.file# order by ddf.tablespace_name,ddf.file_name;
select ddf.tablespace_name,ddf.file_id,ddf.file_name,df.status,df.enabled, df.block_size, ddf.bytes, ddf.maxbytes, ddf.autoextensible from v\$tempfile df, dba_temp_files ddf where ddf.file_id=df.file# order by ddf.tablespace_name,ddf.file_name;"
 ;;
 *) SQL_="select dfh.tablespace_name,dfh.file#,dfh.name,df.status,df.enabled, df.block_size, dfh.bytes, dfh.recover, dfh.CHECKPOINT_CHANGE# from v\$datafile df, V\$DATAFILE_HEADER dfh where dfh.file#=df.file# order by dfh.tablespace_name,dfh.name;"
 ;;
esac
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 1000
set numwidth 15
column file_id for 999
column file# for 999
column block_size for 99999
column tablespace_name format a25
column file_name format a60
column name format a60
column status format a10
column enabled format a15
ttitle left "DataFiles information:"
$SQL_
EOF
;;
esac
logf
}


maxseg()
{
P1_=$(echo $* | awk '{print $2}')
REL=$(db_version)
case $REL in
  8|9) SQL_TEXT1="" ;;
  *)   SQL_TEXT1=" , compression "  ;;
esac

$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 500
column OWNER for a30
column SEGMENT_NAME for a40
column SEGMENT_TYPE for a20
column compression for a15
column Mbytes for 999999999999999
select * from (
select tablespace_name, owner, segment_name, segment_type $SQL_TEXT1 , sum(bytes/(1024*1024)) Mbytes
 from  ( select s.tablespace_name, l.owner, l.table_name segment_name, segment_type $SQL_TEXT1 , bytes
    from  dba_lobs l, dba_segments s
    where s.segment_type = 'LOBSEGMENT'  and s.segment_name = l.segment_name and l.owner=s.owner and s.tablespace_name = upper('$P1_')
  union all
   select  s.tablespace_name,t.owner, t.table_name segment_name, segment_type $SQL_TEXT1 , bytes
    from  dba_tables t, dba_segments s
    where s.segment_name = t.table_name and t.owner=s.owner and s.tablespace_name = upper('$P1_')
  union all
   select  s.tablespace_name,i.owner, i.index_name segment_name, segment_type $SQL_TEXT1 , bytes
     from  dba_indexes i, dba_segments s
     where s.segment_name = i.index_name and i.owner=s.owner and s.tablespace_name = upper('$P1_') )
 group by tablespace_name,owner, segment_name, segment_type $SQL_TEXT1
 order by Mbytes desc
) where rownum <= 50
/
EOF
logf
}



fra()
{
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 50
column NAME for a32
column DISPLAY_VALUE for a50
column DEFAULT_VALUE for a13
column ismodified for a10
column description for a57
select name,display_value,/*default_value,*/ismodified,description from SYS.V_\$PARAMETER
where name like 'db_recovery_file_dest%'  or name = 'db_flashback_retention_target';

ttitle left "View: V\$FLASH_RECOVERY_AREA_USAGE"
select * from V\$FLASH_RECOVERY_AREA_USAGE;
column name for a60
column space_limit for 999,999,999,999,999
column space_available for 999,999,999,999,999
column space_used for 999,999,999,999,999
column space_reclaimable for 999,999,999,999,999
ttitle left "View: v\$recovery_file_dest"
select name, space_limit, (space_limit - space_used + space_reclaimable) space_available, round((space_used - space_reclaimable)/space_limit * 100, 1) as pct_full from v\$recovery_file_dest;
select name,space_limit,space_used, space_reclaimable, number_of_files from v\$recovery_file_dest;
ttitle off
EOF
logf
}


arch()
{
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
P3_=`echo $ALL | awk '{print $3}' | tr '[:lower:]' '[:upper:]'`

$SP <<EOF >$LOGF
set lines 230
set pages 60

ttitle left "V\$LOG :"
col bytes for 999999999999
column status for a12
select group#,thread#,sequence#,bytes,archived,status from v\$log;

column "Archive_dest" for a50
ttitle left "V\$ARCHIVE_DEST :"
column DEST_ID for 99
column LOG_SEQUENCE for 999999999
column binding for a10
column target for a7
column compression for a7
column valid_type for a15
column valid_role for a12
column DESTINATION for a55
column ERROR for a75
SELECT DEST_ID, log_sequence,  STATUS, binding, target, compression, valid_type, valid_role, DESTINATION, ERROR FROM V\$ARCHIVE_DEST WHERE DEST_ID <= 10 and status <> 'INACTIVE';

ttitle left "V\$ARCHIVE_DEST_STATUS :"
column recovery_mode for a25
column database_mode for a15
SELECT DEST_ID, RECOVERY_MODE, status, database_mode, archived_thread#, archived_seq#, applied_seq# FROM V\$ARCHIVE_DEST_STATUS WHERE DEST_ID <= 10 and status <> 'INACTIVE';

ttitle left "V\$ARCHIVED_LOG transport lag archivelog standby:"
set linesize 230 pages 70
col THREAD format 999
col PRIMARY_SEQ format 9999999999
col STANDBY_THREAD format 999
col STANDBY_SEQ format 9999999999
col PRIMARY_TIME format a20
col STANDBY_COMPLETION_TIME format a23
col STANDBY_NEXT_TIME format a23
col SEQ_GAP format 9999999
col LAG_MINUTES format 9999999.99
/*
SELECT   prim.thread# thread, prim.dest_id, prim.seq primary_seq, TO_CHAR (prim.tm, 'DD/MM/YYYY HH24:MI:SS') primary_time, tgt.thread# standby_thread, tgt.dest_id, tgt.seq standby_seq,
         TO_CHAR (tgt.tm, 'DD/MM/YYYY HH24:MI:SS') standby_next_time, prim.seq - tgt.seq seq_gap, (prim.tm - tgt.tm) * 24 * 60 lag_minutes
  FROM   (SELECT thread#,dest_id, MAX(sequence#) seq, MAX(next_time) tm FROM v\$archived_log where RESETLOGS_CHANGE#=(select RESETLOGS_CHANGE# from v\$database) GROUP BY thread#,dest_id) prim,
         (SELECT thread#,dest_id, MAX(sequence#) seq, MAX(next_time) tm FROM v\$archived_log where RESETLOGS_CHANGE#=(select RESETLOGS_CHANGE# from v\$database)
                                                             and dest_id IN (SELECT dest_id FROM v\$archive_dest WHERE target = 'STANDBY') AND applied = 'YES' GROUP BY thread#, dest_id) tgt
 WHERE   prim.thread# = tgt.thread# and prim.dest_id = tgt.dest_id order by prim.thread#, prim.dest_id;
*/
SELECT   prim.thread# thread, prim.dest_id, tgt.status, prim.seq primary_seq, TO_CHAR (prim.tm, 'DD/MM/YYYY HH24:MI:SS') primary_time, tgt.thread# standby_thread, tgt.dest_id, tgt.seq standby_seq,
         TO_CHAR (tgt.tm, 'DD/MM/YYYY HH24:MI:SS') standby_next_time, prim.seq - tgt.seq seq_gap, (prim.tm - tgt.tm) * 24 * 60 lag_minutes
  FROM   (SELECT thread#, dest_id, MAX(sequence#) seq, MAX(next_time) tm FROM v\$archived_log where RESETLOGS_CHANGE#=(select RESETLOGS_CHANGE# from v\$database) GROUP BY thread#,dest_id) prim,
         (SELECT thread#, al.dest_id, ad.status, MAX(sequence#) seq, MAX(next_time) tm FROM v\$archived_log al, v\$archive_dest ad where al.dest_id=ad.dest_id and ad.target='STANDBY' and RESETLOGS_CHANGE#=(select RESETLOGS_CHANGE# from v\$database) and applied = 'YES' GROUP BY thread#, al.dest_id, ad.status) tgt
 WHERE   prim.thread# = tgt.thread# and prim.dest_id = tgt.dest_id order by prim.thread#, prim.dest_id;

column deleted format a7
column reclaimable format a11
col APPLIED for a9
col backup_count for 99999
col count(*) for 99999
col first_time for a15
col last_time for a15
col first_seq for 999999999
col last_seq for 999999999
ttitle left "Reclaimable v\$archived_log join sys.x\$kccagf   exec dbms_backup_restore.refreshagedfiles; :"
select applied,deleted,backup_count
 ,decode(rectype,11,'YES','NO') reclaimable,count(*) 
 ,to_char(min(completion_time),'dd/mm/yy hh24:mi') first_time
 ,to_char(max(completion_time),'dd/mm/yy hh24:mi') last_time
 ,min(sequence#) first_seq,max(sequence#) last_seq
from v\$archived_log left outer join sys.x\$kccagf using(recid)
where is_recovery_dest_file='YES' and deleted<>'YES'
group by applied,deleted,backup_count,decode(rectype,11,'YES','NO') order by min(sequence#);

ttitle left "GV\$MANAGED_STANDBY :"
col thread# for 99
col SEQUENCE# for 999999999
col PROCESS for a7
col PID for 999999999
select thread#,sequence#,process, pid,status from gv\$managed_standby order by THREAD#, SEQUENCE#, PROCESS;

--ttitle left "V\$STANDBY_LOG :"
--select group#,thread#,sequence#,bytes,used,archived,status from v\$standby_log;
EOF
logf
}


size()
{
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
P3_=`echo $ALL | awk '{print $3}' | tr '[:lower:]' '[:upper:]'`
case "$P2_" in
  TBS)      shift; shift; ALL=$*; tbs $ALL ;;
  TEMP)     temp ;;
  DF)       shift; shift; ALL=$*; df $ALL ;;
  MAXSEG)   shift; ALL=$*; maxseg $ALL ;;
  FRA)      fra ;;
  GROWS)    grows $P3_ ;;
  *)        dbsize $P2_ ;;
esac
}


user()
{
P1_=$1
case "$(db_version)" in
8|9|10|11)  CMD1_="SELECT username, ACCOUNT_STATUS,lock_date,expiry_date,default_tablespace,TEMPORARY_TABLESPACE,created, profile FROM dba_users where upper(username) like upper('$P1_');" ;;
*)          CMD1_="SELECT username, ACCOUNT_STATUS,lock_date,expiry_date,default_tablespace,TEMPORARY_TABLESPACE,created, profile,cast(last_login as date) last_login FROM dba_users where upper(username) like upper('$P1_');" ;;
esac

$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 50
set numwidth 15
column username for a30
column table_name for a20
column privilege for a15
column account_status for a20
column default_tablespace for a20
column TEMPORARY_TABLESPACE for a20
column profile for a20
column last_login for a19
$CMD1_
prompt
prompt sys privs:

column grantee for a20
column GRANTED_ROLE for a30
column privilege for a30
select * from dba_sys_privs where grantee=upper('$P1_') order by privilege;

prompt
prompt role privs:
select * from dba_role_privs where grantee=upper('$P1_') order by granted_role;

prompt
prompt tab privs:
column table_name for a30
column grantee for a20
column grantor for a20
column owner for a25
column PRIVILEGE for a15
column type for a15
select * from dba_tab_privs where grantee=upper('$P1_') order by grantor, table_name, PRIVILEGE;

prompt
prompt usage tablespace:
break on report
COMPUTE SUM OF SUM_ on report
column sum_ format 99999999.00 heading "SUM (Mb)"
select owner,tablespace_name, sum(bytes/1024/1024) sum_ from dba_segments where owner=upper('$P1_') group by owner,tablespace_name order by 3 desc;
EOF
logf
}

invalid()
{
P1_="$1"
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column owner for a25
column object_name for a30
column OBJECT_TYPE for a25
column status for a20
BREAK ON REPORT
COMPUTE SUM  LABEL 'SUM' OF count(*) on report
select owner, count(*)  from dba_objects where status!='VALID' and upper(owner) like nvl(upper('$P1_'),'%') group by owner order by owner;
column OBJECT_NAME for a30
select owner, object_name, object_type,status from dba_objects where status!='VALID' and upper(owner) like nvl(upper('$P1_'),'%') order by owner, object_type, object_name;
EOF
logf
}


profile()
{
P1_="$1"
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
column PROFILE for a30
column RESOURCE_NAME for a30
column LIMIT for a30
select * from dba_profiles where profile like nvl(upper('$P1_'),'%') order by profile, RESOURCE_NAME;
EOF
logf
}

links()
{
REL=$(db_version)
case $REL in
9)  $SP <<EOF >$LOGF
set lines 300
set echo off feed off veri off tab off pages 0
select 'create database link '||l.name||' connect to '||l.userid||' identified by "'||l.password||'" using '''||l.host||''';' 
from sys.link$ l, sys.user$ u where l.owner#=u.user#;
EOF
;;
*) $SP <<EOF >$LOGF
set lines 300
set echo off feed off veri off tab off pages 0
select 'create database link '||l.name||' connect to '||l.userid||' identified by values '''||l.passwordx||''' using '''||l.host||''';'
from sys.link$ l, sys.user$ u where l.owner#=u.user# order by l.name;
EOF
;;
esac

$SP <<EOF >>$LOGF
set lines 180
alter session set NLS_DATE_FORMAT='dd/mm/yyyy hh24:mi:ss';
set echo off feed off veri off tab off pages 40
column owner for a30
column name for a35
column userid for a30
column host for a45
column ctime for a20
select u.name owner,l.name,l.userid,l.host,l.ctime from sys.link$ l, sys.user$ u where l.owner#=u.user# order by owner, l.name;
prompt
EOF
logf
}

latch()
{
$SP <<'EOF' >$LOGF
set lines 230
set echo off feed off veri off tab off pages 140
ttitle left "Latch Contention information:" skip 1
column name for a40
column gets for 999999999999999
column misses for 999999999999
column im_gets for 999999999999
column im_misses for 999999999999
select n.name name, l.gets gets, l.misses misses, l.sleeps sleep ,
l.immediate_gets im_gets,l.immediate_misses im_misses,
round(decode(l.gets,0,0,misses/l.gets*100),3) pct,
round(decode(l.immediate_gets,0,0,l.immediate_misses/l.immediate_gets*100),3) im_pct
from v$latchname n, v$latchholder h, v$latch l
where l.latch#=n.latch#
and l.addr=h.laddr(+)
and (l.immediate_misses*100>0.5*l.immediate_gets
or misses*100>0.5*l.gets)
order by misses/l.gets desc;
ttitle off


DEF _lhp_what="sid,name,func"
DEF _lhp_sid="%"
DEF _lhp_name="%"
DEF _lhp_samples="100000"

set lines 180
set pages 50
SET VERIFY OFF
set feedback off echo off
COL name FOR A40 WRAP
COL latchprof_total_ms HEAD "Held ms" FOR 999999.999
COL latchprof_pct_total_samples head "Held %" format 999.99
COL latchprof_avg_ms   HEAD "Avg hold ms" FOR 999999.999
COL dist_samples       HEAD Gets
COL total_samples      HEAD Held
COL ksllwnam           FOR A40 TRUNCATE
COL ksllwlbl           FOR A20 TRUNCATE
COL objtype            FOR A20 TRUNCATE
COL object             FOR A17 WRAP JUST RIGHT
COL hmode              FOR A12 TRUNCATE
COL what               FOR A17 WRAP
COL func               FOR A40 TRUNCATE
COL timemodel          FOR A32 WORD_WRAP

BREAK ON lhp_name SKIP 1

DEF _IF_ORA_10_OR_HIGHER="--"

--PROMPT -- LatchProfX 2.03 by Tanel Poder ( https://blog.tanelpoder.com )

COL latchprof_oraversion NEW_VALUE _IF_ORA_10_OR_HIGHER NOPRINT

SET TERMOUT OFF
SELECT 
    DECODE(SUBSTR(BANNER, INSTR(BANNER, 'Release ')+8,1), 1, '', '--') latchprof_oraversion 
FROM v$version WHERE ROWNUM=1;
SET TERMOUT ON

WITH 
    t1 AS (SELECT hsecs FROM v$timer),
    samples AS (
        SELECT /*+ ORDERED USE_NL(l.x$ksuprlat) USE_NL(s.x$ksuse) NO_TRANSFORM_DISTINCT_AGG */
            &_lhp_what
            &_IF_ORA_10_OR_HIGHER , COUNT(DISTINCT gets)        dist_samples
          , COUNT(*)                    total_samples
          , COUNT(*) / &_lhp_samples    total_samples_pct
        FROM 
            (SELECT /*+ NO_MERGE */ 1 FROM DUAL CONNECT BY LEVEL <= &_lhp_samples) s,
            (SELECT ksuprpid PID, ksuprsid SID, ksuprlnm NAME, ksuprlat LADDR, ksulawhr, 
                    TO_CHAR(ksulawhy,'XXXXXXXXXXXXXXXX') object
                    &_IF_ORA_10_OR_HIGHER , ksulagts GETS
                    &_IF_ORA_10_OR_HIGHER , lower(ksuprlmd) HMODE
             FROM x$ksuprlat) l,
            (SELECT
                    indx
                  , ksusesqh     sqlhash
                  , ksusesql     sqladdr 
                  &_IF_ORA_10_OR_HIGHER , CASE WHEN BITAND(ksusstmbv, POWER(2, 01)) = POWER(2, 01) THEN 'DBTIME '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 02)) = POWER(2, 02) THEN 'BACKGROUND '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 03)) = POWER(2, 03) THEN 'CONNECTION_MGMT '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 04)) = POWER(2, 04) THEN 'PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 05)) = POWER(2, 05) THEN 'FAILED_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 06)) = POWER(2, 06) THEN 'NOMEM_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 07)) = POWER(2, 07) THEN 'HARD_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 08)) = POWER(2, 08) THEN 'NO_SHARERS_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 09)) = POWER(2, 09) THEN 'BIND_MISMATCH_PARSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 10)) = POWER(2, 10) THEN 'SQL_EXECUTION '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 11)) = POWER(2, 11) THEN 'PLSQL_EXECUTION '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 12)) = POWER(2, 12) THEN 'PLSQL_RPC '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 13)) = POWER(2, 13) THEN 'PLSQL_COMPILATION '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 14)) = POWER(2, 14) THEN 'JAVA_EXECUTION '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 15)) = POWER(2, 15) THEN 'BIND '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 16)) = POWER(2, 16) THEN 'CURSOR_CLOSE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 17)) = POWER(2, 17) THEN 'SEQUENCE_LOAD '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 18)) = POWER(2, 18) THEN 'INMEMORY_QUERY '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 19)) = POWER(2, 19) THEN 'INMEMORY_POPULATE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 20)) = POWER(2, 20) THEN 'INMEMORY_PREPOPULATE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 21)) = POWER(2, 21) THEN 'INMEMORY_REPOPULATE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 22)) = POWER(2, 22) THEN 'INMEMORY_TREPOPULATE '  END
                  &_IF_ORA_10_OR_HIGHER ||CASE WHEN BITAND(ksusstmbv, POWER(2, 23)) = POWER(2, 23) THEN 'TABLESPACE_ENCRYPTION ' END timemodel
                  &_IF_ORA_10_OR_HIGHER , ksusesph planhash
                  &_IF_ORA_10_OR_HIGHER , ksusesch sqlchild
                  &_IF_ORA_10_OR_HIGHER , ksusesqi sqlid
             FROM x$ksuse) s,
            (SELECT indx, 
                    ksllwnam func, ksllwnam,
                    ksllwlbl objtype, ksllwlbl 
             FROM x$ksllw) w
        WHERE
            l.sid LIKE '&_lhp_sid'
        AND l.ksulawhr = w.indx (+)
        AND l.sid = s.indx
        AND (LOWER(l.name) LIKE LOWER('%&_lhp_name%') OR LOWER(RAWTOHEX(l.laddr)) LIKE LOWER('%&_lhp_name%'))
        GROUP BY
            &_lhp_what
        ORDER BY
            total_samples DESC
    ),
    t2 AS (SELECT hsecs FROM v$timer)
SELECT /*+ ORDERED */
    &_lhp_what
  , s.total_samples
  &_IF_ORA_10_OR_HIGHER , s.dist_samples
--  , s.total_samples_pct
  , s.total_samples / &_lhp_samples * 100 latchprof_pct_total_samples
  , (t2.hsecs - t1.hsecs) * 10 * s.total_samples / &_lhp_samples latchprof_total_ms
--  , s.dist_events
    &_IF_ORA_10_OR_HIGHER , (t2.hsecs - t1.hsecs) * 10 * s.total_samples / dist_samples / &_lhp_samples latchprof_avg_ms
  FROM
    t1,
    samples s,
    t2
  WHERE ROWNUM <= 40
/
EOF
logf
}

# rtpi 192.168.1.131 askona1 bind | egrep -v "SQL|------" | sed '/^$/d' | awk '{print "/home/oracle/tal/run_tpi.sh 192.168.1.131 askona1 bind  "sq substr($0,1,60) sq}' sq="~" | awk -F"'" '{print $1 }'| sed -e 's|"|\\"|g' -e 's|(|\\(|g' -e 's|)|\\)|g' -e "s|~|\'|g"
bind()
{
if [ -n "$ALL" ]; then
$SP <<EOF >>$LOGF
 set lines 200
 set echo off feed off veri off tab off pages 50
 prompt sql_text
 break on SQL_text
 column name for a5
 column VALUE_STRING for a25
 column SQL_text for a130
 column module for a16
 column SQL_ID for a14
 select a.module, a.SQL_ID, a.SQL_text, b.name, b.VALUE_STRING from v\$sqlarea a, V\$SQL_BIND_CAPTURE b
 where a.sql_id  = b.sql_id (+) and a.sql_text like '%$ALL%' and a.sql_text not like '%select a.module, a.SQL_ID, a.SQL_text%' and rownum < 11;
EOF
else
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 50
column sql for a60
select * from (
SELECT substr(sql_text,1,60) "SQL",
         count(*) ,
         sum(executions) "TotExecs"
    FROM v\$sqlarea
   WHERE executions < 5
   GROUP BY substr(sql_text,1,60)
  HAVING count(*) > 30
   ORDER BY 2 desc
) where rownum <60;
EOF
fi
logf
}


pipe()
{
if [ -n "$ALL" ]; then
$SP <<EOF >$LOGF
set lines 230
set serveroutput on
set echo off feed off veri off tab off pages 0
declare
v_pipe varchar2(32) := '$ALL';
v_p pls_integer;
v_data VARCHAR2(4000);
v_out clob;
begin
 v_out :='';
 v_p := DBMS_PIPE.RECEIVE_MESSAGE(v_pipe, 0);
        WHILE v_p = 0 LOOP
                DBMS_PIPE.UNPACK_MESSAGE(v_data);
                v_out := v_out || v_data ||chr(13)||chr(10);
                v_p := DBMS_PIPE.RECEIVE_MESSAGE(v_pipe, 0);
        END LOOP;
  dbms_output.put_line(v_out);
end;
/
EOF
else
$SP <<'EOF' >$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
column name for a40
select name,pipe_size from sys.V_$DB_PIPES
where name not like '%LOCK%'
order by pipe_size desc;
EOF
fi
logf
}

longops()
{
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}'`
case "$P2_" in
rman)
$SP <<EOF >$LOGF
set lines 230
col filename for a60
col bytes for 999999999999
PROMPT v\$block_change_tracking information:
select status, filename, bytes from v\$block_change_tracking;

COLUMN CLIENT_INFO FORMAT a30
COLUMN SID FORMAT 99999
COLUMN SPID FORMAT 999999
PROMPT
PROMPT RMAN sessions:
SELECT s.SID, p.SPID, s.CLIENT_INFO FROM V\$PROCESS p, V\$SESSION s WHERE p.ADDR = s.PADDR AND CLIENT_INFO LIKE 'rman%';
col dbsize_gbytes for 99,999,990.00 justify right head "DBSIZE_GB"
col input_gbytes for 99,999,990.00 justify right head "READ_GB"
col output_gbytes for 99,999,990.00 justify right head "WRITTEN_GB"
col output_device_type for a10 justify left head "DEVICE"
col complete for 990.00 justify right head "COMPLETE %"
col compression for 990.00 justify right head "COMPRESS|% ORIG"
col est_complete for a20 head "ESTIMATED COMPLETION"
col recid for 9999999 head "ID"
col start_time for a10
col end_time for a10
col est_complete for a10
col sysdate for a10
PROMPT
PROMPT v\$rman_status Estimate time of current backup if block_change_tracking is disabled:
col status for a10
col object_type for a15
select recid, status, object_type, start_time, end_time, output_device_type, dbsize_gbytes
, input_bytes/1024/1024/1024 input_gbytes, output_bytes/1024/1024/1024 output_gbytes
, (output_bytes/input_bytes*100) compression , ((mbytes_processed)/dbsize_gbytes/1024*100) complete
, to_char(start_time + (sysdate-start_time)/(mbytes_processed/dbsize_gbytes/1024),'DD/MM/YYYY HH24:MI:SS') est_complete , sysdate
from v\$rman_status rs, (select sum(bytes)/1024/1024/1024 dbsize_gbytes from v\$datafile)
where status like 'RUNNING%' and
output_device_type is not null
and start_time>sysdate-3 and mbytes_processed>0
order by  start_time;

PROMPT v\$rman_backup_job_details v\$rman_status Estimate time of current backup if block_change_tracking is enabled:
select df_total, df_backuped, round((df_backuped*100)/nvl(df_total,1),2) percent_complete, start_time
, to_char(start_time + (sysdate-start_time)/decode( (df_backuped/df_total), '0', '1', df_backuped/df_total) , 'DD/MM/YYYY HH24:MI:SS') est_complete
from (SELECT count(vbd.file#) df_backuped
FROM v\$rman_backup_job_details vrbjd, v\$backup_datafile vbd
WHERE vbd.file#>0 and vbd.completion_time BETWEEN vrbjd.start_time AND vrbjd.end_time
AND vrbjd.input_type <> 'ARCHIVELOG'
and vrbjd.start_time >= (select max(start_time) from v\$rman_status where status like 'RUNNING%' and operation like 'RMAN%')
), (select count(*) df_total from v\$datafile),
(select max(start_time) start_time from v\$rman_status where status like 'RUNNING%' and operation like 'RMAN%') ;
EOF
;;
*)
MESSAGE_=`echo $* | awk '{print $2}'`
case "$(is_number $MESSAGE_)" in
0) SQL_="print_table('select b.* from v\$session a, v\$session_longops b where a.sid = b.sid and a.serial# = b.serial# and a.status=''ACTIVE'' and b.message like ''%$MESSAGE_%'' and SOFAR<>TOTALWORK order by b.sid,b.start_time');" ;;
1) SQL_="print_table('select b.* from v\$session a, v\$session_longops b where a.sid = b.sid and a.serial# = b.serial# and a.status=''ACTIVE'' and a.sid = $MESSAGE_ and SOFAR<>TOTALWORK order by b.sid,b.start_time');" ;;
esac

$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 40
set serveroutput on size 1000000
declare
procedure print_table( p_query in varchar2 )
is
    l_theCursor     integer default dbms_sql.open_cursor;
    l_columnValue   varchar2(4000);
    l_status        integer;
    l_descTbl       dbms_sql.desc_tab;
    l_colCnt        number;
begin
    dbms_sql.parse(  l_theCursor,  p_query, dbms_sql.native );
    dbms_sql.describe_columns( l_theCursor, l_colCnt, l_descTbl);
    for i in 1 .. l_colCnt loop
        dbms_sql.define_column(l_theCursor, i, l_columnValue, 4000);
    end loop;
    l_status := dbms_sql.execute(l_theCursor);
    while ( dbms_sql.fetch_rows(l_theCursor) > 0 ) loop
        for i in 1 .. l_colCnt loop
           dbms_sql.column_value( l_theCursor, i, l_columnValue );
           dbms_output.put_line( rpad( l_descTbl(i).col_name, 30 )
                                  || ': ' ||
                                  l_columnValue );
        end loop;
        dbms_output.put_line( '---------------------------------------------------' );
    end loop;
exception
    when others then
        dbms_sql.close_cursor( l_theCursor );
        RAISE;
end;

begin
 $SQL_
end;
/
EOF
;;
esac
logf
}


scheduler()
{
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}'`
P3_=`echo $ALL | awk '{print $3}'`
case "$P1_" in
log)
$SP <<EOF >$LOGF
prompt dba_scheduler_job_log for job_name like '$P2_' and LOG_DATE > nvl('$P3_',24) hours
set echo off feed off veri off tab off pages 70
set lines 230 pages 60 long 10000
col LOG_ID for 999999999
col LOG_DATE for a19
col OWNER for a20
col JOB_NAME for a30
col JOB_CLASS for a30
col OPERATION for a10
col STATUS for a10
col USER_NAME for a20
col ADDITIONAL_INFO for a50
select LOG_ID,cast(LOG_DATE as date) LOG_DATE,OWNER,JOB_NAME,JOB_CLASS,OPERATION,STATUS,USER_NAME,ADDITIONAL_INFO from DBA_SCHEDULER_JOB_LOG 
where job_name='$P2_' and LOG_DATE > sysdate - (1*(nvl('$P3_',24)/24)) order by LOG_DATE;
EOF
;;
run)
$SP <<EOF >$LOGF
prompt dba_scheduler_job_run_details for job_name like '$P2_' and ACTUAL_START_DATE > nvl('$P3_',24) hours
set echo off feed off veri off tab off pages 70
set lines 230
col owner for a25
col job_name for a30
col STATUS for a10
col SESSION_ID for a14
col SLAVE_PID for a10
col ERROR# for 9999999
col ACTUAL_START_DATE for a19
col RUN_DURATION for a20
select owner, job_name, STATUS, SESSION_ID, SLAVE_PID, ERROR#, cast(ACTUAL_START_DATE as date) ACTUAL_START_DATE, RUN_DURATION  from dba_scheduler_job_run_details 
where job_name like '$P2_' and ACTUAL_START_DATE > sysdate - (1*(nvl('$P3_',24)/24)) 
--and run_duration > interval '10' second
order by ACTUAL_START_DATE;
EOF
;;
*)
$SP <<EOF >$LOGF
set echo off feed off veri off tab off pages 60
set lines 230
col owner for a15
col job_name for a30
--col PROGRAM_OWNER for a10
--col PROGRAM_NAME for a30
col PROGRAM for a18
col JOB_ACTION for a100
col ENABLED for a7
col REPEAT_INTERVAL for a22
col LAST_START_DATE for a10
col LAST_RUN_DURATION for a14
select owner, job_name, (PROGRAM_OWNER || CASE when PROGRAM_OWNER is null then '' else '.' END || PROGRAM_NAME) PROGRAM, JOB_ACTION, ENABLED, REPEAT_INTERVAL,
cast(LAST_START_DATE as date) LAST_START_DATE, LAST_RUN_DURATION
from dba_scheduler_jobs where job_name like nvl('$P1_','%') --and ENABLED='TRUE'
order by owner, job_name;

prompt "View: dba_scheduler_running_jobs"
col elapsed_time for a16
col cpu_used for a16
col job_action for a50
--select owner,job_name,session_id,slave_os_process_id,elapsed_time,cpu_used from dba_scheduler_running_jobs;
select r.owner,r.job_name,r.session_id,r.slave_os_process_id,r.elapsed_time,r.cpu_used,s.job_action
from dba_scheduler_running_jobs r, dba_scheduler_jobs s
where s.owner=r.owner and s.job_name=r.job_name;
ttitle off
EOF
;;
esac
logf
}


job()
{
P1_=$1
$SP <<EOF >$LOGF
set lines 250
set echo off feed off veri off tab off pages 40
column job  for 999999999
column log_user  for a12
column last_date  for a10
column next_date  for a10
column interval for a15
column FAILURES for 999999
column WHAT for a100
select JOB, LOG_USER, LAST_DATE,NEXT_DATE,BROKEN,INTERVAL,FAILURES, WHAT from dba_jobs  where LOG_USER like upper('${P1_}%'); 

PROMPT join views  dba_jobs_running, dba_jobs, v\$process, v\$session
set lines 200
column spid for a18
column sid for 99999
column serial# for 999999
column job for 99999999
column username for a15
column schemaname for a15
column log_user for a15
column program for a20
column what for a40
column logon_time  for a10
select /*+rule*/ 'kill -9 '||p.spid spid, d_j.job,
  s.sid, s.serial#, p.program,  s.username,  s.schemaname, 
  d_j.log_user, d_j.what, s.logon_time, d_j.next_date
   from v\$process p, v\$session s, dba_jobs_running j, dba_jobs d_j
   where p.addr = s.paddr and j.sid=s.sid and d_j.job(+)=j.job ;
EOF
logf
}


get_ddl()
{
echo "usage: get_ddl TYPE OBJECT OWNER"
if [ -n "$ALL" ]; then
type_=`echo $ALL | awk '{print $1}' | tr '[:lower:]' '[:upper:]'`
object_=`echo $ALL | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
owner_=`echo $ALL | awk '{print $3}' | tr '[:lower:]' '[:upper:]'`
echo "TYPE: "$type_"  OBJECT: "$object_"  OWNER: "$owner_

case "$type_" in
 PACKAGE_SPEC)            o_type_='PACKAGE' ;;
 PACKAGE_BODY)            o_type_='PACKAGE BODY' ;;
 JAVA_SOURCE)             o_type_='JAVA SOURCE' ;;
 DB_LINK)                 o_type_='DATABASE LINK' ;;
 TYPE_BODY)               o_type_='TYPE BODY' ;;
 MATERIALIZED_VIEW)       o_type_='MATERIALIZED VIEW' ;;
 MATERIALIZED_VIEW_LOG)   o_type_='MATERIALIZED VIEW LOG' ;;
 RMGR_CONSUMER_GROUP)     o_type_='CONSUMER GROUP' ;;
 RMGR_PLAN)               o_type_='RESOURCE PLAN' ;;
 ROLE)                    o_type_='ROLE' ;;
 *)                       o_type_=$type_ ;;
esac

case "$type_" in
USER)
$SP <<EOF >>$LOGF
SET LONG 20000 LONGCHUNKSIZE 20000 PAGESIZE 0 LINESIZE 180 FEEDBACK OFF VERIFY OFF TRIMSPOOL ON
BEGIN
   DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
   DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'PRETTY', true);
END;
/
-- SELECT dbms_metadata.get_ddl('USER','$object_') FROM dual;
prompt "SYSTEM_GRANTS:"
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','$object_') from dual;
prompt "ROLE_GRANTS:"
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','$object_') from dual;
prompt "OBJECT_GRANTS:"
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','$object_') from dual;
EOF
;;
JOB)
$SP <<EOF >>$LOGF
SET LONG 20000 LONGCHUNKSIZE 20000 PAGESIZE 0 LINESIZE 230 FEEDBACK OFF VERIFY OFF TRIMSPOOL ON
SELECT dbms_metadata.get_ddl('PROCOBJ','$object_', '$owner_') from dual;
EOF
;;
TABLESPACE)
$SP <<EOF >>$LOGF
SET LONG 20000 LONGCHUNKSIZE 20000 PAGESIZE 0 LINESIZE 230 FEEDBACK OFF VERIFY OFF TRIMSPOOL ON
exec DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
select dbms_metadata.get_ddl('$type_','$object_') from dual;
EOF
;;
ROLE)
$SP <<EOF >>$LOGF
set long 1000000 longchunksize 20000 pagesize 0 linesize 1000 feedback off verify off trimspool on
column ddl format a1000
begin
   dbms_metadata.set_transform_param (dbms_metadata.session_transform, 'SQLTERMINATOR', true);
   dbms_metadata.set_transform_param (dbms_metadata.session_transform, 'PRETTY', true);
end;
/
variable v_role VARCHAR2(30);
exec :v_role := upper('$object_');
select dbms_metadata.get_ddl('ROLE', r.role) AS ddl
from   dba_roles r
where  r.role = :v_role
union all
select dbms_metadata.get_granted_ddl('ROLE_GRANT', rp.grantee) AS ddl
from   dba_role_privs rp
where  rp.grantee = :v_role
and    rownum = 1
union all
select dbms_metadata.get_granted_ddl('SYSTEM_GRANT', sp.grantee) AS ddl
from   dba_sys_privs sp
where  sp.grantee = :v_role
and    rownum = 1
union all
select dbms_metadata.get_granted_ddl('OBJECT_GRANT', tp.grantee) AS ddl
from   dba_tab_privs tp
where  tp.grantee = :v_role
and    rownum = 1
/
EOF
;;
*)
$SP <<EOF >$LOGF
set echo off feed off veri off tab off
alter session set NLS_DATE_FORMAT='dd/mm/yyyy hh24:mi:ss';
prompt "NLS_DATE_FORMAT='dd/mm/yyyy hh24:mi:ss'"
set linesize 5000 pages 0
set long 10000000 longc 10000000
SET SERVEROUTPUT ON SIZE UNLIMITED;
declare
 c clob;
 PROCEDURE DISPLAY_CLOB (P_CLOB IN CLOB) IS
--  l_amt NUMBER DEFAULT 32000;
  l_amt NUMBER DEFAULT 24000;
  l_offset NUMBER DEFAULT 1;
  l_length NUMBER DEFAULT NVL (DBMS_LOB.getlength (p_clob), 0);
  x varchar2(32760);
 BEGIN
  WHILE (l_offset < l_length) LOOP
   dbms_lob.read (p_clob, l_amt, l_offset, x);
   l_offset := l_offset + l_amt;
   DBMS_OUTPUT.PUT_LINE(X);
  END LOOP;
 END DISPLAY_CLOB;
begin
   DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
   for i in (select owner,object_name,object_type from dba_objects where owner='$owner_' and object_name = '$object_' and object_type='$o_type_' order by object_name) loop
     select dbms_metadata.get_ddl('$type_',i.object_name,'$owner_') into c from dual;
       DISPLAY_CLOB(c);
--     DBMS_OUTPUT.PUT_LINE(c);
   end loop;
end;
/
--exec DBMS_METADATA.set_transform_param (DBMS_METADATA.session_transform, 'SQLTERMINATOR', true);
--select dbms_metadata.get_ddl('$type_','$object_','$owner_') from dual;
EOF
;;
esac
logf
else
echo " ORACLE 9.0.1 "
echo "  "
echo " Type Name                       Meaning "
echo " ASSOCIATION                     associate statistics  "
echo " AUDIT                           audits of SQL statements  "
echo " AUDIT_OBJ                       audits of schema objects  "
echo " CLUSTER                         clusters  "
echo " COMMENT                         comments  "
echo " CONSTRAINT                      constraints  "
echo " CONTEXT                         application contexts  "
echo " DB_LINK                         database links  "
echo " DEFAULT_ROLE                    default roles  "
echo " DIMENSION                       dimensions  "
echo " DIRECTORY                       directories  "
echo " FUNCTION                        stored functions  "
echo " INDEX                           indexes  "
echo " INDEXTYPE                       indextypes  "
echo " JAVA_SOURCE                     java sources  "
echo " LIBRARY                         external procedure libraries  "
echo " MATERIALIZED_VIEW               materialized views  "
echo " MATERIALIZED_VIEW_LOG           materialized view logs  "
echo " OBJECT_GRANT                    object grants  "
echo " OPERATOR                        operators  "
echo " OUTLINE                         stored outlines  "
echo " PACKAGE                         stored packages  "
echo " PACKAGE_SPEC                    package specifications  "
echo " PACKAGE_BODY                    package bodies  "
echo " PROCEDURE                       stored procedures  "
echo " PROFILE                         profiles  "
echo " PROXY                           proxy authentications  "
echo " REF_CONSTRAINT                  referential constraint  "
echo " ROLE                            roles  "
echo " ROLE_GRANT                      role grants  "
echo " ROLLBACK_SEGMENT                rollback segments  "
echo " SEQUENCE                        sequences  "
echo " SYNONYM                         synonyms  "
echo " SYSTEM_GRANT                    system privilege grants  "
echo " TABLE                           tables  "
echo " TABLESPACE                      tablespaces  "
echo " TABLESPACE_QUOTA                tablespace quotas  "
echo " TRIGGER                         triggers  "
echo " TRUSTED_DB_LINK                 trusted links  "
echo " TYPE                            user-defined types  "
echo " TYPE_SPEC                       type specifications  "
echo " TYPE_BODY                       type bodies  "
echo " USER                            users  "
echo " VIEW                            views  "
echo " XMLSCHEMA                       XML schema  "
echo "  "
echo "  "
echo " ORACLE 10.1.0 "
echo "  "
echo " Type Name                       Meaning "
echo " AQ_QUEUE                        queues  "
echo " AQ_QUEUE_TABLE                  additional metadata for queue tables  "
echo " AQ_TRANSFORM                    transforms  "
echo " DATABASE_EXPORT                 all metadata objects in a database  "
echo " FGA_POLICY                      fine-grained audit policies  "
echo " INDEX_STATISTICS                indextypes  "
echo " JOB                             scheduler jobs (Current support scheduled for 11.2 .. See NOTE:567504.1)   "
echo " REFRESH_GROUP                   refresh groups  "
echo " RESOURCE_COST                   resource cost info  "
echo " RLS_CONTEXT                     driving contexts for enforcement of fine-grained access-control policies  "
echo " RLS_GROUP                       fine-grained access-control policy groups  "
echo " RLS_POLICY                      fine-grained access-control policies  "
echo " RMGR_CONSUMER_GROUP             resource consumer groups  "
echo " RMGR_INTITIAL_CONSUMER_GROUP    assign initial consumer groups to users  "
echo " RMGR_PLAN                       resource plans  "
echo " RMGR_PLAN_DIRECTIVE             resource plan directives  "
echo " SCHEMA_EXPORT                   sequences  "
echo " TABLE_DATA                      metadata describing row data for a table, nested table, or partition  "
echo " TABLE_EXPORT                    metadata for a table and its associated objects  "
echo " TABLE_STATISTICS                precomputed statistics on tables  "
echo " TRANSPORTABLE_EXPORT            metadata for objects in a transportable tablespace set "
echo ""
echo " Extract DDL for job:"
echo " PROCOBJ YOURJOBNAME YOURJOBOWNER  Capture DDL for Scheduler Jobs"
fi
}



psql()
{
if [ -z "$*" ]; then echo "No parameters"; return ; fi
TEXT_=`echo $ALL | tr '[:upper:]' '[:lower:]'`
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}'`
case "$P1_" in
sqlstat)
ash sqlstat $P2_
return
;;
plan)
echo "v\$sql_plan where sql_id = "$P2_
$SP <<EOF >$LOGF
set lines 220
set pages 200
column id noprint
column plan for a130
BREAK ON timestamp ON sql_id ON plan_hash_value ON child_number SKIP 1 NODUPLICATES
SELECT  distinct sql_id,plan_hash_value, child_number, cost, cardinality, bytes, id, lpad(id,3,'0') ||' '|| lpad (' ', depth) || operation ||' '|| options ||' '|| object_name plan
from v\$sql_plan where  sql_id = '$P2_'
order by sql_id,plan_hash_value,child_number,id;
EOF
;;
*)
LEN_=`expr length $P1_`
SQL_ID__=`echo $P1_ | tr -d '[:digit:][:lower:]'`
if [ -z "$SQL_ID__" -a $LEN_ -eq 13 ] ; then
SQL_="SELECT sql_id, plan_hash_value, child_number, SQL_FULLTEXT, module, action FROM v\$sql where sql_id = '$P1_';"
echo " v\$sql where sql_id = "$P1_
else
SQL_="SELECT sql_id, plan_hash_value, child_number, SQL_FULLTEXT, module, action FROM v\$sql where lower(sql_text) like '%$TEXT_%';"
echo "v\$sql where lower(sql_text) like "$TEXT_
fi
$SP <<EOF >$LOGF
set lines 220
set long 1000000000 longc 1000000000
set pages 90
column sql_id for a13
column plan_hash_value for 99999999999999
column SQL_FULLTEXT for a120
column module for a27
column action for a25
$SQL_
EOF
;;
esac
logf
}


awr_tempusage()
{
view_=$1
allocated_=$2
limit_=1024
if [ -z "$allocated_" ]; then
  allocated_=$limit_
fi
if [ -z "$HHE_" ]; then
  HHE_=3
  DD_=`date +%d/%m/%Y`
  HHB_=`date +%H`
  HHB_=`expr $HHB_ - 3`
fi
$SP <<EOF >$LOGF
set lines 230 
PROMPT  AWR_tempusage from $view_ for limit >= $allocated_ Mb and last hours $HHE_  $xrange
set timing on
col SAMPLE_TIME for a15
col SQL_ID  for a15
col TEMP_DIFF for 9999999999
select session_id,session_serial#, t.sample_time, t.sql_id, /*t.temp_mb,*/ t.temp_diff
  from ( select session_id,session_serial#,
               to_char(sample_time, 'DD/MM/YYYY HH24') sample_time,sql_id, /*sum(temp_mb) temp_mb,*/ sum(temp_diff) temp_diff
               , row_number() over (partition by to_char(sample_time, 'DD/MM/YYYY HH24') order by sum(temp_mb) desc nulls last) as rn
          from ( select sample_time,session_id,session_serial#,sql_id,temp_space_allocated/(1024*1024) temp_mb,
                       temp_space_allocated/1024/1024-lag(temp_space_allocated/1024/1024,1,0) over (partition by session_id,"SESSION_SERIAL#",sql_id order by sample_time) as temp_diff
                 from $view_
                where temp_space_allocated > 0
--                  and sample_time >=  sysdate - (1*(nvl('$HHB_',24)/24)))               
		  and sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
       )
         group by session_id,session_serial#, to_char(sample_time, 'DD/MM/YYYY HH24'), sql_id
         having sum(temp_diff) >= nvl('$allocated_', $limit_)
       ) t
 order by sample_time, temp_diff desc;
EOF
}


dhash()
{
case "$(db_version)" in
8|9)  echo "Current Oracle Version doesn't have AWR..." ; exit ;;
*)  : ;;
esac

if [ -z "$*" ]; then

$SP <<EOF >$LOGF
set lines 250 
set feedback off
PROMPT
PROMPT Snap_intervel and Retention period from view: DBA_HIST_WR_CONTROL
column SNAP_INTERVAL for a30
column RETENTION for a30
SELECT DBID, SNAP_INTERVAL, RETENTION FROM DBA_HIST_WR_CONTROL where dbid=(select dbid from v\$database);
PROMPT
PROMPT "Avilable period at WRM\$_SNAPSHOT_DETAILS:"
column min_begin_time for a20
column max_end_time for a20
column drop_snapshot_range for a110
select dbid,min(snap_id), cast(min(begin_time) as date) min_begin_time,max(snap_id), cast(max(end_time) as date) max_end_time,
'exec DBMS_WORKLOAD_REPOSITORY.DROP_SNAPSHOT_RANGE(low_snap_id=>'||min(snap_id)||',high_snap_id=>'||max(snap_id)||',dbid =>'||dbid||');' drop_snapshot_range
 from WRM\$_SNAPSHOT_DETAILS group by dbid order by min(begin_time);
--select dbid, to_char(min(sample_time),'dd/mm/yyyy hh24:mi:ss') min_sample_time, min(snap_id), to_char(max(sample_time),'dd/mm/yyyy hh24:mi:ss') max_sample_time, max(snap_id) from dba_hist_active_sess_history group by dbid order by min_sample_time desc;
EOF

else

if [ $(is_number `echo $* | awk -F+ '{print $2}'`)  -eq 0 ]; then
 DD_=`date +%d/%m/%Y`
 HHB_=`date +%H`
 HHB_=`expr $HHB_ - 3`
 HHE_=3
else
 DD_=`echo $* | awk -F+ '{print $1}'`
 HHB_=`echo $* | awk -F+ '{print $2}'`
 HHE_=`echo $* | awk -F+ '{print $3}' | cut -d' ' -f1`
 shift
fi

xrange=`$SP <<END
set pagesize 0 feedback off verify off heading off echo off timing off
select  'in   ' || to_char(to_date('$DD_ $HHB_','dd/mm/yyyy hh24'),'dd/mm/yyyy hh24:mi:ss') ||'  -  ' || to_char(to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute , 'dd/mm/yyyy hh24:mi:ss')||'  period' from dual;
END`
# echo $xrange | tr -d '\r'

type_=`echo $* | awk '{print $1}' | tr '[:upper:]' '[:lower:]'`

SET_COL='set lines 250 pages 80
# column TIME for a9
column TIME for a17
column SID for 99999
column SERIAL for 999999
column USERNAME for a20
column EVENT for a30
column OBJ# for 99999999
column FILE# for 999
column BLOCK# for 9999999
column BLSID for 99999
column BLSERIAL for 999999
column BLSTATUS for a11
column PROGRAM for a21
column MODULE for a20
column ACTION for a16
column MACHINE for a20
#column PMAM for a85 heading "PROGRAM \ MODULE \ ACTION \ MACHINE"
column PMAM for a77 heading "PROGRAM \ MODULE \ ACTION \ MACHINE"
column CPU for 999999
column WAIT for 999999
column IO for 999999
column TOTAL for 999999
column owner for a30
column OBJECT_NAME for a35'

case $type_ in
event)
P1_=`echo $* | awk '{print $2}'`
#echo "P1_: "$P1_

if [ -z "$P1_" ]; then
$SP <<EOF >$LOGF
set lines 250 pages 60 
PROMPT "Top 4 Waits in every hour from DBA_HIST_ACTIVE_SESS_HISTORY by last $HHE_ hours " $xrange
column event for a50
column SAMPLE_HR for a15
column wait_rnk for 9
column instance_number for 9 heading "INSTANCE|NUMBER"
BREAK ON instance_number ON sample_hr SKIP 1 NODUPLICATES
select * from (
select  event, instance_number, sample_hr, cnt_waiting, dense_rank () over (partition by instance_number, sample_hr order by cnt_waiting desc) wait_rnk
from
(
select nvl(event,'ON CPU') event,  instance_number,  to_char(sample_time, 'DD-MON-YYYY HH24') sample_hr,
       sum(decode(ash.session_state,'WAITING',1,0)) cnt_waiting
from
   dba_hist_active_sess_history ash
where  dbid=(select dbid from v\$database) 
   and sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
group by
   nvl(event,'ON CPU'),
   instance_number,
   to_char(sample_time, 'DD-MON-YYYY HH24')
order by 3 desc
 )
)
 where wait_rnk < 5
order by sample_hr, wait_rnk;

PROMPT
PROMPT "Top 20 events from DBA_HIST_ACTIVE_SESS_HISTORY by last $HHE_ hours " $xrange
select * from ( select nvl(EVENT, 'ON CPU') EVENT, count(*) from DBA_HIST_ACTIVE_SESS_HISTORY
where sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute  and dbid=(select dbid from v\$database) group by EVENT order by count(*) desc ) where rownum<21;

PROMPT
PROMPT "Top 50 SQL TIME_WATED from DBA_HIST_ACTIVE_SESS_HISTORY by last $HHE_ hours " $xrange
col entry_name for a45
col proc_name for a45
col sql_id for a14
col sql_plan_hash_value for 9999999999 heading "PLAN_HASH_V"
col module for a45
col event for a40
col time_waited for 999999.99
col cnt for 9999999
select * from (
select   e.object_name || decode(e.object_name,'','','.') || e.procedure_name entry_name, p.object_name || decode(p.object_name,'','','.') || p.procedure_name proc_name,
x.sql_id, x.sql_plan_hash_value, /* x.module, */ x.event, x.time_waited, x.cnt
from      dba_procedures    e, dba_procedures    p,
           (select    plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
--                      module,
                      sql_id,
                      sql_plan_hash_value,
                      nvl(event,'ON CPU') event,
                      sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
                      count(*) cnt
            from      dba_hist_active_sess_history
where     sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
and       sql_id is not null
            group by  plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
--                      module,
                      sql_id,
                      sql_plan_hash_value,
                      event) x
where     e.object_id (+) = x.plsql_entry_object_id
and       e.subprogram_id (+) = x.plsql_entry_subprogram_id
and       p.object_id (+) = x.plsql_object_id
and       p.subprogram_id (+) = x.plsql_subprogram_id
--order by  x.cnt desc, 1, 2, 3, 4 )
order by  x.cnt * x.time_waited desc, 1, 2, 3, 4 )
where rownum<51 ;
EOF
elif [ "$P1_" = "all" ]; then
shift
shift
EVENT_="$*"
echo "ENTER ALL, EVENT_: "$EVENT_
$SP <<EOF >$LOGF
PROMPT "Events from DBA_HIST_ACTIVE_SESS_HISTORY by filter: Last hours: $HHE_ " $xrange ", Event: $EVENT_"
PROMPT
$SET_COL
select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,event,"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action,machine*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM
from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id and dbid=(select dbid from v\$database) and 
sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
and event like '%$EVENT_%' order by sample_time;
EOF
else
shift
EVENT_="$*"
echo "EVENT_: "$EVENT_
$SP <<EOF >$LOGF
set lines 250 pages 80 
PROMPT "Top 50 SESS TIME_WATED from DBA_HIST_ACTIVE_SESS_HISTORY by last $HHE_ hours  $xrange, Event: $EVENT_"
col entry_name for a45
col sql_id for a14
col sql_plan_hash_value for 9999999999 heading "PLAN_HASH_V"
col module for a45
col event for a40
col time_waited for 999999.99
col cnt for 999999
select * from (
select  session_id, "SESSION_SERIAL#", e.object_name || decode(e.object_name,'','','.') || e.procedure_name entry_name, 
x.sql_id, x.sql_plan_hash_value, /* x.module, */ x.event, x.time_waited, x.cnt
from      dba_procedures    e,
           (select    session_id, "SESSION_SERIAL#", 
                      plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
--                      module,
                      sql_id,
                      sql_plan_hash_value,
                      nvl(event,'ON CPU') event,
                      sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
                      count(*) cnt
            from      dba_hist_active_sess_history
where     sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
--and       sql_id is not null
and       event like '%$EVENT_%'
            group by  session_id, "SESSION_SERIAL#", 
                      plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
--                      module,
                      sql_id,
                      sql_plan_hash_value,
                      event) x
where     e.object_id (+) = x.plsql_entry_object_id
and       e.subprogram_id (+) = x.plsql_entry_subprogram_id
order by  x.cnt desc, 1, 2, 3, 4 )
where rownum<51 ;
EOF
fi
;;
sess)
P1_=`echo $* | awk '{print $2}'`
P2_=`echo $* | awk '{print $3}'`
P3_=`echo $* | awk '{print $4}'`
if [ -n "$P1_"  -a -n "$P2_" -a "$P3_" = "all" ]; then
$SP <<EOF >$LOGF
PROMPT "Session from DBA_HIST_ACTIVE_SESS_HISTORY by filter: Last hours: $HHE_  $xrange  for SID: $P1_  SERIAL: $P2_"
$SET_COL
select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action,machine*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM
from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id 
and dbid=(select dbid from v\$database) and sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute  and  session_id = '$P1_' and "SESSION_SERIAL#" = '$P2_' order by sample_time;
EOF
elif [ -n "$P1_" -a -n "$P2_" -a "$P3_" = "nosqlid" ]; then
$SP <<EOF >$LOGF
PROMPT "Top 30 SUM of SESSION_STATE from DBA_HIST_ACTIVE_SESS_HISTORY by filter: Last hours: $HHE_  $xrange  for sid = '$P1_' and serial = '$P2_'"
$SET_COL
select * from (
select session_id sid,"SESSION_SERIAL#" serial,username,nvl(event,'ON CPU') event, --session_state, /*program,module,action,machine*/  program||' \ '||module||' \ '||action||' \ '||machine PMAM,
 sum(decode(h.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(h.session_state,'WAITING',1,0))    -
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(h.session_state,'ON CPU',1,1))     "TOTAL"
from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id
and dbid=(select dbid from v\$database) and sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
and  sql_id is not null
group by session_id,"SESSION_SERIAL#",username,event --,session_state,program,module,action,machine
order by "TOTAL" desc
) where sid = '$P1_' and serial = '$P2_' and rownum<31;
EOF
elif [ -n "$P1_" -a -n "$P2_" ]; then
$SP <<EOF >$LOGF
PROMPT "Top 30 SUM of SESSION_STATE from DBA_HIST_ACTIVE_SESS_HISTORY by filter: Last hours: $HHE_  $xrange  for sid = '$P1_' and serial = '$P2_'"
$SET_COL
select * from (
select session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event, --session_state, /*program,module,action,machine*/  program||' \ '||module||' \ '||action||' \ '||machine PMAM,
 sum(decode(h.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(h.session_state,'WAITING',1,0))    -
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(h.session_state,'ON CPU',1,1))     "TOTAL"
from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id
and dbid=(select dbid from v\$database) and sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
and  sql_id is not null
group by session_id,"SESSION_SERIAL#",username,sql_id,event --,session_state,program,module,action,machine
order by "TOTAL" desc
) where sid = '$P1_' and serial = '$P2_' and rownum<31;
EOF
elif [ -n "$P1_" ]; then
$SP <<EOF >$LOGF
PROMPT "Session from DBA_HIST_ACTIVE_SESS_HISTORY by filter: Last hours: $HHE_  $xrange  for SQL_ID: $P1_ "
$SET_COL
select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action,machine*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM
from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id
and dbid=(select dbid from v\$database) and sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute and sql_id = '$P1_' order by sample_time;
EOF
else
$SP <<EOF >$LOGF
PROMPT "Top 30 SUM of SESSION_STATE from DBA_HIST_ACTIVE_SESS_HISTORY by filter: Last hours: $HHE_  $xrange"
$SET_COL
select * from (
select session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/ /*program,module,action,machine*/  program||' \ '||module||' \ '||action||' \ '||machine PMAM,
 sum(decode(h.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(h.session_state,'WAITING',1,0))    -
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(h.session_state,'ON CPU',1,1))     "TOTAL"
from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id 
and dbid=(select dbid from v\$database) and sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
and  sql_id is not null
group by session_id,"SESSION_SERIAL#",username,sql_id,event,session_state,program,module,action,machine
order by "TOTAL" desc
) where rownum<31;
EOF
fi
;;
where)
FIELD_=`echo $* | awk '{print $2}'`
if [ -z "$FIELD_" ]; then FIELD_="program"; fi
PRG_=`echo $* | awk '{print $3}'`
COND_="and $FIELD_ like '%$PRG_%'"
$SP <<EOF >$LOGF
PROMPT "Stat top 30 session_state from DBA_HIST_ACTIVE_SESS_HISTORY for last hours: $HHE_  $xrange for condition: $COND_"
$SET_COL
select * from (
select /*session_id sid,"SESSION_SERIAL#" serial,*/ username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/ /*program,module,action,machine*/  program||' \ '||module||' \ '||action||' \ '||machine PMAM,
 sum(decode(h.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(h.session_state,'WAITING',1,0))    -
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(h.session_state,'ON CPU',1,1))     "TOTAL"
from DBA_HIST_ACTIVE_SESS_HISTORY h, dba_users u where h.user_id=u.user_id
and dbid=(select dbid from v\$database) and sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
and  sql_id is not null 
$COND_
--and program like '%$PRG_%'
group by /*session_id,"SESSION_SERIAL#",*/ username,sql_id,event,session_state,program,module,action,machine
order by "TOTAL" desc
) where rownum<31;
EOF
;;
sql)
SQL_ID_=`echo $* | awk '{print $2}'`
SQL_TEXT_=`shift; echo $* | tr '[:lower:]' '[:upper:]'`
if [ -z "$SQL_ID_" ]; then
$SP <<EOF >$LOGF
PROMPT "Top 10 SQL from DBA_HIST_ACTIVE_SESS_HISTORY by last $HHE_ hours  $xrange"
set lines 250 pages 70
set long 1000000000 longc 1000000000
col type for a7
col "CPU" for 999999.9
col "IO" for 999999.9
col "SQL_TEXT" for a80
select /*+ LEADING(H_TXT) */ s.*, h_txt.sql_text from (
select * from (
select
     ash.SQL_ID , ash.SQL_PLAN_HASH_VALUE Plan_hash, aud.name type,
     sum(decode(ash.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(ash.session_state,'WAITING',1,0))    -
     sum(decode(ash.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(ash.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(ash.session_state,'ON CPU',1,1))     "TOTAL"
from dba_hist_active_sess_history ash,
     audit_actions aud
where ash.SQL_ID is not NULL
   and ash.sql_opcode=aud.action
    and ash.sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and ash.sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
     and dbid=(select dbid from v\$database)
group by ash.sql_id, SQL_PLAN_HASH_VALUE   , aud.name
 order by sum(decode(session_state,'ON CPU',1,1))   desc
-- order by 7 desc
) where rownum < 11) s, DBA_HIST_SQLTEXT h_txt where s.sql_id=h_txt.sql_id
/
EOF
else
LEN_=`expr length $SQL_ID_`
SQL_ID__=`echo $SQL_ID_ | tr -d '[:digit:][:lower:]'`
if [ -z "$SQL_ID__" -a $LEN_ -eq 13 ] ; then
# SQL_="select sql_id,sql_text from DBA_HIST_SQLTEXT where dbid=(select dbid from v\$database) and sql_id='$SQL_ID_';"
 SQL_="select cast(h.sample_time as date) sample_time, s.sql_id, sql_plan_hash_value, s.sql_text from DBA_HIST_SQLTEXT s, dba_hist_active_sess_history h where s.sql_id=h.sql_id and s.dbid=(select dbid from v\$database) and s.sql_id = '$SQL_ID_' and h.sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and h.sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute and rownum<21 order by sample_time;"
 PROMPT_="20 SQL_ID = $SQL_ID_"
else
# SQL_="select sql_id,sql_text from DBA_HIST_SQLTEXT where dbid=(select dbid from v\$database) and upper(sql_text) like '%$SQL_TEXT_%';"
 SQL_="select cast(h.sample_time as date) sample_time, s.sql_id, sql_plan_hash_value, s.sql_text from DBA_HIST_SQLTEXT s, dba_hist_active_sess_history h where s.sql_id=h.sql_id and s.dbid=(select dbid from v\$database) and upper(s.sql_text) like '%$SQL_TEXT_%' and h.sample_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and h.sample_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute and rownum<21 order by sample_time;"
 PROMPT_="20 SQL_TEXT like $SQL_TEXT_"
fi
$SP <<EOF >$LOGF
PROMPT "SQL from DBA_HIST_SQLTEXT by $PROMPT_  $xrange"
set lines 250 pages 50
set long 1000000000 longc 1000000000
column sample_time for a10 heading "sample_time"
column sql_text for a100
column sql_id for a15
column plan_hash_value for 9999999999
$SQL_
EOF
fi
;;
plan)
SQL_ID_=`echo $* | awk '{print $2}'`
FMT_=`echo $* | awk '{print $3}'`
$SP <<EOF >$LOGF
PROMPT "Avilable SNAP_ID from  WRM\$_SNAPSHOT_DETAILS and dba_hist_active_sess_history by last $HHE_ hours  $xrange  for sql_id: $SQL_ID_ :"
set lines 250 pages 60 feedback off
col SQL_EXEC_START for a15
select to_char(SQL_EXEC_START,'dd/mm/yyyy') SQL_EXEC_START,sql_id,sql_plan_hash_value,min(snap_id),max(snap_id) from dba_hist_active_sess_history 
where dbid=(select dbid from v\$database) and snap_id > (select min(snap_id) from WRM\$_SNAPSHOT_DETAILS where 
begin_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and end_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute )
and sql_id='$SQL_ID_'
and sql_exec_start >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and sql_exec_start <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
--and sql_exec_start>sysdate-25 
group by to_char(SQL_EXEC_START,'dd/mm/yyyy'),sql_id,sql_plan_hash_value order by  min(snap_id);

PROMPT
PROMPT "Plans from DBA_HIST_SQL_PLAN (dbms_xplan.display_awr) for sql_id: $SQL_ID_ "
BREAK ON timestamp ON sql_id ON plan_hash_value SKIP 1 NODUPLICATES
column timestamp for a20 wrap
column id for 99
column OBJECT_OWNER for a15
column operation for a20
column options for a30
column OBJECT_NAME for a30
column OBJECT_TYPE for a20
column cost for 9999999
column plan_hash_value for 9999999999
--select unique timestamp,sql_id,plan_hash_value from DBA_HIST_SQL_PLAN where sql_id = '$SQL_ID_'  ;
select unique p.timestamp,p.sql_id,p.plan_hash_value, s.snap_id from DBA_HIST_SQL_PLAN p, DBA_HIST_SNAPSHOT s
where p.sql_id = '$SQL_ID_' and p.timestamp between s.begin_interval_time and s.end_interval_time order by p.timestamp;

set pages 0
/* select plan_hash_value,id,operation,options,object_owner,object_name,object_type,cost,cardinality,bytes
from DBA_HIST_SQL_PLAN where sql_id = '$SQL_ID_' order by plan_hash_value, id; */

--select * from table(dbms_xplan.display_awr('$SQL_ID_','',format => '-predicate +outline'));
select * from table(dbms_xplan.display_awr('$SQL_ID_','',format => '$FMT_'));
EOF
;;
sqlstat)
SQL_ID_=`echo $* | awk '{print $2}'`
$SP <<EOF >$LOGF
PROMPT "SQLStats from DBA_HIST_SQL_PLAN  for sql_id: $SQL_ID_ by last: $HHE_ hours  $xrange"
set lines 250 pages 60 feedback off

column snap_id for 999999
#column end_interval_time for a9 heading "END_TIME"
column end_interval_time for a17 heading "END_TIME"
column sql_id for a13
column plan_hash_value for 9999999999 heading "PLAN_HASH_V"
column optimizer_cost for 999999999999 heading "COST"
column module for a17
column action for a10
column parsing_schema_name for a15 heading "SCHEMA"
column fetches_delta for 999,999 heading "FCH\EX"
column sorts_delta for 999,999 heading "SORT\EX"
column executions_delta for 999,999,999 heading "EXEC"
column pio_per_exec for 999,999,999 heading "PIO\EX"
column lio_per_exec for 99,999,999,999 heading "LIO\EX"
column rows_processed_delta for 999,999,999 heading "ROWS_PR\EX"
column cpu_time_delta for 999,999.9999 heading "CPU_TIME\EX"
column elapsed_time_delta for 999,999.9999 heading "ELA_TIME\EX"
column iowait_delta for 999,999,999 heading "IOWAIT\EX"

select hs.snap_id,to_char(hs.end_interval_time,'dd/mm/yy hh24:mi:ss') end_interval_time,
sql_id,plan_hash_value,optimizer_cost,module,action,
parsing_schema_name,
trunc(fetches_delta / decode(executions_delta, 0, 1, executions_delta)) fetches_delta,
trunc(sorts_delta / decode(executions_delta, 0, 1, executions_delta)) sorts_delta,
executions_delta,
trunc(DISK_READS_DELTA / decode(executions_delta, 0, 1, executions_delta)) PIO_PER_EXEC,
(buffer_gets_delta / decode(nvl(executions_delta, 0), 0, 1, executions_delta)) LIO_PER_EXEC,
trunc(rows_processed_delta / decode(executions_delta, 0, 1, executions_delta)) rows_processed_delta,
decode(EXECUTIONS_delta, 0, cpu_time_delta/1000000, round(cpu_time_delta/EXECUTIONS_delta/1000000, 4)) cpu_time_delta,
(elapsed_time_delta / decode(nvl(executions_delta, 0), 0, 1, executions_delta)) / 1000000 elapsed_time_delta,
decode(EXECUTIONS_delta, 0, iowait_delta/1000000, round(iowait_delta/EXECUTIONS_delta/1000000, 4)) iowait_delta
from dba_hist_sqlstat st, dba_hist_snapshot hs
where st.snap_id=hs.snap_id and sql_id = '$SQL_ID_' and st.instance_number = hs.instance_number and
hs.snap_id in (select snap_id from DBA_HIST_SNAPSHOT where begin_interval_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and end_interval_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute )
and hs.dbid = (select dbid from v\$database)
and executions_delta > 0
order by snap_id, end_interval_time;
EOF
;;
growseg)
TBS=`echo $* | awk '{print $2}'`
SEG=`echo $* | awk '{print $3}'`
if [ -z "$SEG" ]; then
$SP <<EOF >$LOGF
PROMPT "DBA_HIST_SEG_STAT: Most segments growth in the last: $HHE_ hours  $xrange"
set lines 250 pages 80
column owner for a20
column TABLESPACE for a20
column OBJECT_NAME for a30
column SUBOBJECT_NAME for a46
column OBJECT_TYPE for a18
column TABLESPACE for a20
BREAK ON REPORT
COMPUTE SUM LABEL 'SUM' OF "Growth in MB" on report
COMPUTE SUM LABEL 'SUM' OF "Total Size(GB)" on report
select * from (SELECT o.OWNER , o.OBJECT_NAME , o.SUBOBJECT_NAME , o.OBJECT_TYPE ,
    t.NAME "Tablespace", round(s.growth/(1024*1024),2) "Growth in MB",
    (SELECT round(sum(bytes)/(1024*1024*1024),2)
    FROM dba_segments
    WHERE segment_name=o.object_name) "Total Size(GB)"
FROM DBA_OBJECTS o,
    ( SELECT TS#,OBJ#,
        SUM(SPACE_ALLOCATED_DELTA) growth
   FROM DBA_HIST_SEG_STAT where snap_id in (select snap_id from DBA_HIST_SNAPSHOT where begin_interval_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and end_interval_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute )
    GROUP BY TS#,OBJ#
    HAVING SUM(SPACE_ALLOCATED_DELTA) > 0
    ORDER BY 2 DESC ) s,
    v\$tablespace t 
WHERE s.OBJ# = o.OBJECT_ID
AND s.TS# = t.TS# and t.name like nvl(trim('$TBS'),'%')
ORDER BY 6 DESC) where rownum<=6000;
EOF
else
$SP <<EOF >$LOGF
PROMPT "DBA_HIST_SEG_STAT: $SEG segment growth in the last: $HHE_ hours  $xrange"
set lines 250 pages 80
column owner for a20
column SEGMENT_NAME for a30
column TABLESPACE for a20
column SUBOBJECT_NAME for a46
column end_interval_time for a13 heading "end_interval_time"
column space_used_delta for 999999999 heading "Space grows (MB)"
column usage for 999.99 heading "% of total Disk Usage"
BREAK ON REPORT
COMPUTE SUM LABEL 'SUM' OF space_used_delta on report
select * from (select to_char(end_interval_time, 'DD/MM/YYYY HH24') end_interval_time, c.owner, c.segment_name, b.SUBOBJECT_NAME, c.tablespace_name,
round(sum(space_used_delta) / 1024 / 1024, 2) space_used_delta,
trunc(sum(c.bytes) / 1024 / 1024) "Total Object Size (MB)",
round(sum(space_used_delta) / sum(c.bytes) * 100, 2) usage
from dba_hist_snapshot sn, dba_hist_seg_stat a, dba_objects b, dba_segments c
where begin_interval_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and end_interval_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
and sn.snap_id = a.snap_id
and b.object_id = a.obj#
and b.owner = c.owner
and b.object_name = c.segment_name
and c.segment_name = '$SEG' and c.tablespace_name like nvl(trim('$TBS'),'%')
group by to_char(end_interval_time, 'DD/MM/YYYY HH24'), c.owner, c.segment_name, b.SUBOBJECT_NAME, c.tablespace_name
having sum(space_used_delta) > 0 )
order by owner, segment_name, to_date(end_interval_time, 'DD/MM/YYYY HH24');
EOF
fi
;;
segstat)
OBJTYPE_=`echo $* | awk '{print $2}' | tr '[:lower:]' '[:upper:]'`
if [ $(is_number ${OBJTYPE_}) -eq 1 ]; then
 SIZE_=$OBJTYPE_
 OBJTYPE_=''
else
 SIZE_=`echo $* | awk '{print $3}'`
 if [ -z "$SIZE_" ]; then SIZE_=0; fi
fi
$SP <<EOF >$LOGF
PROMPT "Segment statistics for OBJECTS with max BLOCK_CHANGED from AWR for last hours: $HHE_  $xrange" for OBJTYPE: $OBJTYPE_  and SUM(db_block_changes_delta) > $SIZE_
$SET_COL
set pages 1000
col SNAP_TIME for a15
BREAK ON REPORT
COMPUTE SUM LABEL 'SUM' OF block_changed on report
SELECT   TO_CHAR (begin_interval_time, 'yyyy/mm/dd hh24') snap_time,
           dhso.owner, dhso.object_name, dhso.object_type,
           SUM (db_block_changes_delta) block_changed
   FROM   dba_hist_seg_stat dhss,
           dba_hist_seg_stat_obj dhso,
           dba_hist_snapshot dhs
   WHERE       dhs.snap_id = dhss.snap_id
           AND dhs.instance_number = dhss.instance_number
           AND dhss.obj# = dhso.obj#
           AND dhss.dataobj# = dhso.dataobj#
	   AND begin_interval_time >= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') and begin_interval_time <= to_date('$DD_ $HHB_','dd/mm/yyyy hh24') + interval '$HHE_' hour + interval '1' minute
	   and object_type like nvl(trim('$OBJTYPE_'),'%')
GROUP BY   TO_CHAR (begin_interval_time, 'yyyy/mm/dd hh24'), dhso.owner, dhso.object_name, dhso.object_type
  HAVING   SUM (db_block_changes_delta) > nvl(trim('$SIZE_'), 0)
ORDER BY   snap_time;
EOF
;;
temp)
       P1_=`echo $* | awk '{print $2}'`
       awr_tempusage dba_hist_active_sess_history $P1_
;;
*) echo "Nothing..." ;;
esac
fi

logf
}



ash()
{
case "$(db_version)" in
8|9)  echo "Current Oracle Version doesn't have AWR..." ; exit ;;
10) MACHINE_="" ;;
*)  MACHINE_="machine" ;;
esac

if [ -z "$*" ]; then
$SP <<EOF >$LOGF
set echo off
set feedback off
set lines 180 
PROMPT
PROMPT "Avilable period at V\$ACTIVE_SESSION_HISTORY:"
select to_char(min(sample_time),'dd/mm/yyyy hh24:mi:ss') min_sample_time, to_char(max(sample_time),'dd/mm/yyyy hh24:mi:ss') max_sample_time from V\$ACTIVE_SESSION_HISTORY;
EOF

else

type_=`echo $* | awk '{print $1}' | tr '[:upper:]' '[:lower:]'`
P1_=`echo $* | awk '{print $2}'`
P2_=`echo $* | awk '{print $3}'`
P3_=`echo $* | awk '{print $4}'`
#echo "type_="$type_
#echo "P1_="$P1_
#echo "P2_="$P2_
#echo "P3_="$P3_

SET_COL='set lines 250 pages 60
#column TIME for a9
column TIME for a17
column SID for 99999
column SERIAL for 999999
column USERNAME for a20
column EVENT for a30
column OBJ# for 99999999
column FILE# for 999
column BLOCK# for 9999999
column BLSID for 99999
column BLSERIAL for 999999
column BLSTATUS for a11
column PROGRAM for a41
column MODULE for a20
column ACTION for a16
column MACHINE for a20
#column PMAM for a85 heading "PROGRAM \ MODULE \ ACTION \ MACHINE"
column PMAM for a77 heading "PROGRAM \ MODULE \ ACTION \ MACHINE"
column CPU for 999999
column WAIT for 999999
column IO for 999999
column TOTAL for 999999'

case $type_ in
event)
if [ -z "$P1_" ]; then
$SP <<EOF >$LOGF
PROMPT "Top 20 events from V\$ACTIVE_SESSION_HISTORY by last time"
set lines 180 pages 45
select * from ( select nvl(EVENT, 'ON CPU') EVENT, count(*) from V\$ACTIVE_SESSION_HISTORY
where sample_time > sysdate - 1 group by EVENT order by count(*) desc ) where rownum<21;

PROMPT
PROMPT "Top 50 SQL TIME_WAITED from V\$ACTIVE_SESSION_HISTORY by last time"
set lines 250 pages 60
set long 1000000000 longc 1000000000
col entry_name for a45
col proc_name for a45
col sql_id for a14
col sql_plan_hash_value for 9999999999 heading "PLAN_HASH_V"
col module for a45
col event for a40
col time_waited for 999999.99
col cnt for 9999999
select * from (
select   e.object_name || decode(e.object_name,'','','.') || e.procedure_name entry_name, p.object_name || decode(p.object_name,'','','.') || p.procedure_name proc_name,
x.sql_id, x.sql_plan_hash_value, /*x.module,*/  x.event, x.time_waited, x.cnt
from      dba_procedures    e, dba_procedures    p,
           (select    plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
--                      module,
                      sql_id,
                      sql_plan_hash_value,
                      nvl(event,'ON CPU') event,
                      sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
                      count(*) cnt
            from      v\$active_session_history
where     sample_time >= sysdate-1
and       sample_time < sysdate
and       sql_id is not null
            group by  plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
--                      module,
                      sql_id,
                      sql_plan_hash_value,
                      event) x
where     e.object_id (+) = x.plsql_entry_object_id
and       e.subprogram_id (+) = x.plsql_entry_subprogram_id
and       p.object_id (+) = x.plsql_object_id
and       p.subprogram_id (+) = x.plsql_subprogram_id
--order by   x.cnt desc, 1, 2, 3, 4 )
order by   x.cnt * x.time_waited desc, 1, 2, 3, 4 )
where rownum<51 ;
EOF
elif [ "$P1_" = "all" ]; then
shift
shift
PP_="$*"
$SP <<EOF >$LOGF
PROMPT
PROMPT "Events from V\$ACTIVE_SESSION_HISTORY by filter: $PP_ "
PROMPT
$SET_COL
select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action, $MACHINE_ */ program||' \ '||module||' \ '||action||' \ '|| $MACHINE_ PMAM
from v\$active_session_history h, dba_users u where h.user_id=u.user_id and event like '%$PP_%' order by sample_time;
EOF
else
shift
PP_="$*"
$SP <<EOF >$LOGF
PROMPT "Top 50 SESSIONS TIME_WAITED from V\$ACTIVE_SESSION_HISTORY by last time, event: $PP_ "
set lines 250 pages 80
col entry_name for a45
col sql_id for a14
col sql_plan_hash_value for 9999999999 heading "PLAN_HASH_V"
col module for a45
col event for a40
col time_waited for 999999.99
col cnt for 999999
select * from (
select  session_id, "SESSION_SERIAL#",  e.object_name || decode(e.object_name,'','','.') || e.procedure_name entry_name,
x.sql_id, x.sql_plan_hash_value, /*x.module,*/  x.event, x.time_waited, x.cnt
from      dba_procedures    e,
           (select    session_id, "SESSION_SERIAL#",
                      plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
--                      module,
                      sql_id,
                      sql_plan_hash_value,
                      nvl(event,'ON CPU') event,
                      sum(decode(session_state, 'ON CPU', wait_time, time_waited))/1000000 time_waited,
                      count(*) cnt
            from      v\$active_session_history
where     sample_time >= sysdate-1
and       sample_time < sysdate
and       event like '%$PP_%'
--and       sql_id is not null
            group by  session_id, "SESSION_SERIAL#",
                      plsql_entry_object_id,
                      plsql_entry_subprogram_id,
                      plsql_object_id,
                      plsql_subprogram_id,
--                      module,
                      sql_id,
                      sql_plan_hash_value,
                      event) x
where     e.object_id (+) = x.plsql_entry_object_id
and       e.subprogram_id (+) = x.plsql_entry_subprogram_id
order by   x.cnt desc, 1, 2, 3, 4 )
where rownum<51 ;
EOF
fi
;;
sess)
if [ -n "$P1_"  -a -n "$P2_" -a "$P3_" = "all" ]; then
$SP <<EOF >$LOGF
PROMPT
PROMPT "Session from V\$ACTIVE_SESSION_HISTORY by filter: SID: $P1_  SERIAL: $P2_"
PROMPT
$SET_COL
select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action, $MACHINE_ */ program||' \ '||module||' \ '||action||' \ '|| $MACHINE_ PMAM
from v\$active_session_history h, dba_users u where h.user_id=u.user_id and session_id = '$P1_' and "SESSION_SERIAL#" = '$P2_' order by sample_time;
EOF
elif [ -n "$P1_" -a -n "$P2_" -a "$P3_" = "nosqlid" ]; then
$SP <<EOF >$LOGF
PROMPT
PROMPT "Top 30 ON CPU Session from V\$ACTIVE_SESSION_HISTORY for sid = '$P1_' and serial = '$P2_' "
PROMPT
$SET_COL
select * from (
select session_id sid,"SESSION_SERIAL#" serial,username,nvl(event,'ON CPU') event, --session_state, /*program,module,action,machine,*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM,
 sum(decode(h.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(h.session_state,'WAITING',1,0))    -
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(h.session_state,'ON CPU',1,1))     "TOTAL"
from v\$active_session_history h, dba_users u where h.user_id=u.user_id
and sql_id is not null
group by session_id,"SESSION_SERIAL#",username,event --,session_state,program,module,action,machine
order by sum(decode(h.session_state,'ON CPU',1,1)) desc
) where sid = '$P1_' and serial = '$P2_' and rownum < 31;
EOF
elif [ -n "$P1_" -a -n "$P2_" ]; then
$SP <<EOF >$LOGF
PROMPT
PROMPT "Top 30 ON CPU Session from V\$ACTIVE_SESSION_HISTORY for sid = '$P1_' and serial = '$P2_' "
PROMPT
$SET_COL
select * from (
select session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event, --session_state, /*program,module,action,machine,*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM,
 sum(decode(h.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(h.session_state,'WAITING',1,0))    -
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(h.session_state,'ON CPU',1,1))     "TOTAL"
from v\$active_session_history h, dba_users u where h.user_id=u.user_id
and sql_id is not null
group by session_id,"SESSION_SERIAL#",username,sql_id,event --,session_state,program,module,action,machine
order by sum(decode(h.session_state,'ON CPU',1,1)) desc
--order by sum(decode(h.session_state,'WAITING',1,0)) - sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) desc
) where sid = '$P1_' and serial = '$P2_' and rownum < 31;
EOF
elif [ -n "$P1_" ]; then 
$SP <<EOF >$LOGF
PROMPT
PROMPT "Session from V\$ACTIVE_SESSION_HISTORY by filter: SQL_ID: $P1_ "
PROMPT
$SET_COL
select to_char(sample_time,'DD/MM/YY HH24:MI:SS')time,session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event,/*session_state,*/"CURRENT_OBJ#" OBJ#,"CURRENT_FILE#" FILE#,"CURRENT_BLOCK#" BLOCK#,
blocking_session_status BLSTATUS,blocking_session BLSID,"BLOCKING_SESSION_SERIAL#" BLSERIAL,/*program,module,action, $MACHINE_ */ program||' \ '||module||' \ '||action||' \ '|| $MACHINE_ PMAM
from v\$active_session_history h, dba_users u where h.user_id=u.user_id and sql_id = '$P1_' order by sample_time;
EOF
else
$SP <<EOF >$LOGF
PROMPT
PROMPT "Top 30 ON CPU Session from V\$ACTIVE_SESSION_HISTORY "
PROMPT
$SET_COL
select * from (
select session_id sid,"SESSION_SERIAL#" serial,username,sql_id,nvl(event,'ON CPU') event, /* session_state,*/ /*program,module,action,machine,*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM,
 sum(decode(h.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(h.session_state,'WAITING',1,0))    -
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(h.session_state,'ON CPU',1,1))     "TOTAL"
from v\$active_session_history h, dba_users u where h.user_id=u.user_id 
and sql_id is not null
group by session_id,"SESSION_SERIAL#",username,sql_id,event,session_state,program,module,action,machine
order by sum(decode(h.session_state,'ON CPU',1,1)) desc
) where rownum<31;
EOF
fi
;;
where)
FIELD_=`echo $* | awk '{print $2}'`
if [ -z "$FIELD_" ]; then FIELD_="program"; fi
PRG_=`echo $* | awk '{print $3}'`
COND_="and $FIELD_ like '%$PRG_%'"
$SP <<EOF >$LOGF
PROMPT
PROMPT "Stat top 30 session_state from V\$ACTIVE_SESSION_HISTORY for condition: $COND_"
PROMPT
$SET_COL
select * from (
select /*session_id sid,"SESSION_SERIAL#" serial,*/username,sql_id,nvl(event,'ON CPU') event, /* program, session_state, */ /*program,module,action,machine,*/ program||' \ '||module||' \ '||action||' \ '||machine PMAM,
 sum(decode(h.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(h.session_state,'WAITING',1,0))    -
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(h.session_state,'ON CPU',1,1))     "TOTAL"
from v\$active_session_history h, dba_users u where h.user_id=u.user_id
and sql_id is not null 
$COND_
--and program like '%$PRG_%'
--and module like '%$PRG_%'
--and action like '%$PRG_%'
--group by /*session_id,"SESSION_SERIAL#",*/ username,sql_id,event,program --,session_state,program,module,action,machine
group by /*session_id,"SESSION_SERIAL#",*/ username,sql_id,event,program,module,action,machine
order by sum(decode(h.session_state,'ON CPU',1,1)) desc
--order by sum(decode(h.session_state,'WAITING',1,0)) - sum(decode(h.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) desc
) where rownum < 31;
EOF
;;
sql)
SQL_ID_=`echo $* | awk '{print $2}'`
SQL_TEXT_=`shift; echo $* | tr '[:lower:]' '[:upper:]'`
#echo "SQL_TEXT_="$SQL_TEXT_
if [ -z "$SQL_ID_" ]; then
$SP <<EOF >$LOGF
PROMPT
PROMPT "Top 20 SQL, CALL from V\$ACTIVE_SESSION_HISTORY by last time"
set lines 180 pages 45
set long 1000000000 longc 1000000000
col type for a7
col "CPU" for 999999.9
col "IO" for 999999.9
col "SQL_TEXT" for a80
BREAK ON SQL_ID ON PLAN_HASH ON TYPE ON CPU ON WAIT ON IO ON TOTAL SKIP 1 NODUPLICATES
select /*+ LEADING(H_TXT) */ s.*, h_txt.sql_text from (
select * from (
select
     ash.SQL_ID , ash.SQL_PLAN_HASH_VALUE Plan_hash, aud.name type,
     sum(decode(ash.session_state,'ON CPU',1,0))     "CPU",
     sum(decode(ash.session_state,'WAITING',1,0))    -
     sum(decode(ash.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "WAIT" ,
     sum(decode(ash.session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0))    "IO" ,
     sum(decode(ash.session_state,'ON CPU',1,1))     "TOTAL"
from V\$ACTIVE_SESSION_HISTORY ash,
     audit_actions aud
where ash.SQL_ID is not NULL
   and ash.sql_opcode=aud.action
    and ash.sample_time >  sysdate - 1
group by ash.sql_id, SQL_PLAN_HASH_VALUE   , aud.name
-- order by sum(decode(session_state,'ON CPU',1,1))   desc
order by 7 desc
) where rownum < 11) s, V\$SQLTEXT h_txt where s.sql_id=h_txt.sql_id order by total desc, s.SQL_ID, s.Plan_hash, h_txt.piece
/
EOF
else
LEN_=`expr length $P1_`
P1__=`echo $P1_ | tr -d '[:digit:][:lower:]'`
if [ -z "$P1__" -a $LEN_ -eq 13 ] ; then
 SQL_="SELECT ash.sql_id, a.plan_hash_value, a.sql_text,a.executions,round(a.disk_reads/decode(a.executions, 0, 1, a.executions),0) pio_per_exec,round(a.buffer_gets /decode(a.executions, 0, 1, a.executions),0) lio_per_exec, round(decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/EXECUTIONS/1000000, 4)),4) cpu_time, round(((elapsed_time / decode(executions, 0, 1, executions)) / 1000000),4) elapsed_time, decode(EXECUTIONS, 0, user_io_wait_time/1000000, round(user_io_wait_time/decode(executions, 0, 1, executions)/1000000, 4)) iowait FROM v\$active_session_history ash, v\$sqlarea a WHERE ash.sql_id = a.sql_id and ash.sql_plan_hash_value=a.plan_hash_value AND ash.sql_id = '$P1_' AND rownum=1;"
 PROMPT_="SQL_ID = $SQL_ID_"
else
 SQL_="SELECT ash.sql_id, a.plan_hash_value, a.sql_text,a.executions,round(a.disk_reads/decode(a.executions, 0, 1, a.executions),0) pio_per_exec,round(a.buffer_gets /decode(a.executions, 0, 1, a.executions),0) lio_per_exec, round(decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/EXECUTIONS/1000000, 4)),4) cpu_time, round(((elapsed_time / decode(executions, 0, 1, executions)) / 1000000),4) elapsed_time, decode(EXECUTIONS, 0, user_io_wait_time/1000000, round(user_io_wait_time/decode(executions, 0, 1, executions)/1000000, 4)) iowait FROM v\$active_session_history ash, v\$sqlarea a WHERE ash.sql_id = a.sql_id and ash.sql_plan_hash_value=a.plan_hash_value AND upper(a.sql_text) like '%$SQL_TEXT_%' AND rownum=1;"
 PROMPT_="SQL_TEXT like $SQL_TEXT_"
fi
$SP <<EOF >$LOGF
PROMPT
PROMPT "SQL from V\$ACTIVE_SESSION_HISTORY by $PROMPT_"
PROMPT
set lines 250 pages 50
set long 1000000000 longc 1000000000
column sql_text for a100
column executions for 999,999,999 
column pio_per_exec for 999,999,999 heading "PIO\EX"
column lio_per_exec for 99,999,999,999 heading "LIO\EX"
column cpu_time for 999,999.9999 heading "CPU_TIME\EX"
column elapsed_time for 999,999.9999 heading "ELA_TIME\EX"
column iowait for 999,999,999 heading "IOWAIT\EX"
$SQL_
EOF
fi
;;
plan)
$SP <<EOF >$LOGF
PROMPT
PROMPT "Current Plan from V\$SQL_PLAN and V\$ACTIVE_SESSION_HISTORY (dbms_xplan.display_cursor) for sql_id: $P1_"
PROMPT
set lines 250 pages 0 feedback off
column plan_hash_value for 9999999999
column OBJECT_NAME for a30
BREAK ON plan_hash_value SKIP 1 NODUPLICATES

-- select plan_table_output from table(dbms_xplan.display_cursor('$P1_',null,'typical +outline last')) ;
select plan_table_output from table(dbms_xplan.display_cursor('$P1_','',format=>nvl('$P2_', '-predicate') ));
EOF
;;
sqlstat)
$SP <<EOF >$LOGF
set lines 250 pages 70 feedback off
PROMPT
PROMPT "After change plan do not forget purge the old statistics:"
col cmd for a70 heading "COMMAND TO PURGE SQL STATEMENT"
col sql_id for a15
col address for a20
col hash_value for 9999999999 
col executions for 999,999,999
col loads for 999999999
col version_count for 999999
col PARSE_CALLS for 999,999,999
col invalidations for 999,999
select 'exec dbms_shared_pool.purge ('''||address||','||hash_value||''',''C'');' cmd, sql_id,address, hash_value, executions, loads, version_count, invalidations, parse_calls from v\$sqlarea where sql_id  = '$P1_';
select sql_id,users_opening,users_executing,open_versions from v\$sql where sql_id = '$P1_';

PROMPT
PROMPT "SQLStats from V\$SQLSTATS  for sql_id: $P1_"
col sql_id for a15
col plan_hash_value for 999999999999 heading "PLAN_HASH_VALUE"
col PARSE_CALLS for 999,999,999
col invalidations for 999,999
col fetches for 999,999 heading "FCH\EX"
col sorts for 999,999 heading "SORT\EX"
col executions for 999,999,999 heading "EXEC"
col pio_per_exec for 999,999,999 heading "PIO\EX"
col lio_per_exec for 99,999,999,999 heading "LIO\EX"
col rows_processed for 999,999,999 heading "ROWS_PR\EX"
col cpu_time for 999,999.9999 heading "CPU_TIME\EX"
col elapsed_time for 999,999.9999 heading "ELA_TIME\EX"
col iowait for 999999999 heading "IOWAIT\EX"

select sql_id,plan_hash_value,last_active_time,parse_calls,invalidations,
trunc(fetches / decode(executions, 0, 1, executions)) fetches,
trunc(sorts / decode(executions, 0, 1, executions)) sorts,
executions,
trunc(DISK_READS / decode(executions, 0, 1, executions)) PIO_PER_EXEC,
(buffer_gets / decode(nvl(executions, 0), 0, 1, executions)) LIO_PER_EXEC,
trunc(rows_processed / decode(executions, 0, 1, executions)) rows_processed,
decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/EXECUTIONS/1000000, 4)) cpu_time,
(elapsed_time / decode(nvl(executions, 0), 0, 1, executions)) / 1000000 elapsed_time,
decode(EXECUTIONS, 0, user_io_wait_time/1000000, round(user_io_wait_time/EXECUTIONS/1000000, 4)) iowait,
sharable_mem
FROM V\$SQLSTATS WHERE sql_id = '$P1_';
EOF
;;
temp) awr_tempusage v\$active_session_history $P1_
;;
*) echo "Nothing..." ;;
esac
fi

logf
}


spm()
{
type_=`echo $* | awk '{print $1}' | tr '[:upper:]' '[:lower:]'`

case $type_ in
 *[0-9])  DAYS=$type_ ;;
 *)       DAYS=7 ;;
esac

$SP <<EOF >$LOGF
set lines 230
set feedback off
set echo off feed on veri off tab off pages 400
PROMPT
PROMPT Current records in dba_sql_plan_baselines by last days: $DAYS
PROMPT
column SQL_NAME for a30 heading "SQL_HANDLE \ PLAN_NAME"
column SQL_HANDLE for a20
column PLAN_NAME for a30
column creator for a10
column origin for a12
column parsing_schema_name for a10
column created for a10
column last_modified for a10
column last_executed for a10
column enabled for a3
column accepted for a3
column fixed for a3
column optimizer_cost for 9999999 heading COST
column module for a12
column executions for 999999999 heading EXEC
column elapsed_time for 99999.00000 heading ELA_T\EX
column cpu_time for 99999.00000 heading CPU_T\EX
column buffer_gets for 99999999999 heading BUFGETS\EX
column disk_reads for 999999999 heading DISKR\EX
column rows_processed for 999999999 heading ROWS\EX
--ttitle left "View dba_sql_plan_baselines:"
select sql_handle||chr(10)||plan_name sql_name,creator,origin,parsing_schema_name,
cast(created as date) created, cast(last_modified as date) last_modified, cast(last_executed as date) last_executed,
enabled, accepted, fixed, optimizer_cost, module, executions, 
decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/decode(executions, 0, 1, executions)/1000000, 4)) cpu_time, 
(elapsed_time / decode(executions, 0, 1, executions)) / 1000000 elapsed_time, 
trunc(buffer_gets/decode(executions, 0, 1, executions)) buffer_gets,
trunc(disk_reads/decode(executions, 0, 1, executions)) disk_reads,
trunc(rows_processed/decode(executions, 0, 1, executions)) rows_processed 
from dba_sql_plan_baselines where created > sysdate-$DAYS order by cast(created as date), sql_handle;

set serveroutput on
set feedback off
declare
 v_sqlid VARCHAR2(13);
 v_num number;
 cnt integer;
BEGIN
 cnt:=0;
 dbms_output.put_line('SQL_ID       '||' '|| 'PLAN_HASH_VA'||' '||'SQL_HANDLE          '||' '||'PLAN_NAME                     '||' '||'CREATED            '||' '||'LAST_MODIFIED      '
                    ||' '||'LAST_EXECUTED      '||' '||'ENA'||' '||'ACC'||' '||'FIX'||' '||'   COST'||' '||'     EXEC'||' '||'CPU_T/EX'||' '||'ELA_T/EX'||' '||'BUFGETS/EX'||' '||'DISKR/EX'||' '||'ROWS/EX');
 dbms_output.put_line('-------------'||' '|| '------------'||' '||'--------------------'||' '||'------------------------------'||' '||'-------------------'||' '||'-------------------'
                    ||' '||'-------------------'||' '||'---'||' '||'---'||' '||'---'||' '||'-------'||' '||'---------'||' '||'--------'||' '||'--------'||' '||'----------'||' '||'--------'||' '||'-------');
 for a in (select sql_handle, plan_name, trim(substr(g.PLAN_TABLE_OUTPUT,instr(g.PLAN_TABLE_OUTPUT,':')+1)) plan_hash_value, sql_text, 
            created,last_modified,last_executed,enabled,accepted,fixed,optimizer_cost,module,executions,
             decode(EXECUTIONS, 0, cpu_time/1000000, round(cpu_time/decode(executions, 0, 1, executions)/1000000, 4)) cpu_time,
             (elapsed_time / decode(executions, 0, 1, executions)) / 1000000 elapsed_time,
             trunc(buffer_gets/decode(executions, 0, 1, executions)) buffer_gets,
             trunc(disk_reads/decode(executions, 0, 1, executions)) disk_reads,
             trunc(rows_processed/decode(executions, 0, 1, executions)) rows_processed
                 from (select t.*, c.* from dba_sql_plan_baselines c, table(dbms_xplan.DISPLAY_SQL_PLAN_BASELINE(c.sql_handle, c.plan_name)) t
                 /* where c.sql_handle = 'SQL_0b27795a43a131fa' */) g
                 where PLAN_TABLE_OUTPUT like 'Plan hash value%' and created>sysdate-$DAYS order by created) loop
    v_num := to_number(sys.UTL_RAW.reverse(sys.UTL_RAW.SUBSTR(sys.dbms_crypto.hash(src => UTL_I18N.string_to_raw(a.sql_text || chr(0),'AL32UTF8'), typ => 2),9,4)) || 
             sys.UTL_RAW.reverse(sys.UTL_RAW.SUBSTR(sys.dbms_crypto.hash(src => UTL_I18N.string_to_raw(a.sql_text || chr(0),'AL32UTF8'), typ => 2),13,4)),RPAD('x', 16, 'x'));
    v_sqlid := '';
    FOR i IN 0 .. FLOOR(LN(v_num) / LN(32))
    LOOP
        v_sqlid := SUBSTR('0123456789abcdfghjkmnpqrstuvwxyz',FLOOR(MOD(v_num / POWER(32, i), 32)) + 1,1) || v_sqlid;
    END LOOP;
    dbms_output.put_line(lpad(v_sqlid, 13, '0')||' '||rpad(a.plan_hash_value,12)||' '||rpad(a.sql_handle,20)||' '||rpad(a.plan_name,30)||' '||rpad(cast(a.created as date),19)||' '||
     rpad(cast(a.last_modified as date),19)||' '||rpad(nvl(rpad(cast(a.last_executed as date),19),' '),19)||' '||rpad(a.enabled,3)||' '||rpad(a.accepted,3)||' '||rpad(a.fixed,3)||' '||
     lpad(a.optimizer_cost,7)||' '||lpad(a.executions,9)||' '||lpad(a.cpu_time,8)||' '||lpad(a.elapsed_time,8)||' '||lpad(a.buffer_gets,10)||' '||lpad(a.disk_reads,8)||' '||lpad(a.rows_processed,7)
     );
   cnt:=cnt+1;
 end loop;
 dbms_output.put_line(chr(10)||cnt||' rows selected.');
end;
/
EOF


case $type_ in
blplan)
sql_handle="$2"
plan_name="$3"
if [ "$sql_handle" = null ]; then sql_handle=""; fi
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 400
ttitle left "DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE(sql_handle=>'$sql_handle',plan_name=>'$plan_name',format=>'-predicate +outline'):"
select * from table(DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE(sql_handle=>'$sql_handle',plan_name=>'$plan_name',format=>'-predicate +outline'));
EOF
;;
blexec)
param=$2
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 400
column SQL_HANDLE for a20
column PLAN_NAME for a30
column PARSING_SCHEMA_NAME for a20
column optimizer_cost for 999999 heading COST
column origin for a20
column created for a10
column last_exec for a10
column last_executed for a11 heading "LAST_EXEC"
column executions for 999999999
ttitle left "Join views v\$sql, dba_sql_plan_baselines where baselines.executions >= nvl('$param',1) :"
select distinct s.sql_id, s.plan_hash_value, b.sql_handle, b.plan_name, b.parsing_schema_name, b.optimizer_cost, b.origin, b.enabled, b.accepted, b.fixed, b.autopurge,
cast(b.created as date) created,cast(b.last_executed as date) last_exec, b.executions
from v\$sql s, dba_sql_plan_baselines b where s.exact_matching_signature = b.signature and b.executions >= nvl('$param',1)
order by created, last_exec;
EOF
;;
bllpfcc)
sql_id="$2"
plan_hash_value="$3"
sql_handle="$4"
if [ -n "$sql_handle" ]; then
 SQL_=", fixed => 'YES', sql_handle => '$sql_handle'"
fi
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 400
PROMPT Load the sql_id into the SQL Basesile: DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE( sql_id => '$sql_id', PLAN_HASH_VALUE => '$plan_hash_value', sql_handle => '$sql_handle');
DECLARE
 my_plans pls_integer;
BEGIN
 my_plans := DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(
 sql_id => '$sql_id',
 PLAN_HASH_VALUE => '$plan_hash_value'
 $SQL_ ); 
dbms_output.put_line('Value is '||my_plans);
END;
/
EOF
;;
bllpfawr)
sql_id="$2"
plan_hash_value="$3"
begin_snap="$4"
end_snap="$5"
sqlset="tpi-$sql_id-`date +%d-%m-%Y`"
echo "sqlset="$sqlset
$SP <<EOF >$LOGF
set lines 230
exec DBMS_SQLTUNE.CREATE_SQLSET(sqlset_name=>'$sqlset');

column name for a30
column owner for a30
ttitle left "View dba_sqlset before load SQL_ID=$sql_id into SQLSET_NAME=$sqlset: last 15 days"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET where CREATED>sysdate-15;
ttitle off

prompt "Load SQL from AWR to SQLSET:"
declare
 baseline_ref_cursor DBMS_SQLTUNE.SQLSET_CURSOR;
begin
 open baseline_ref_cursor for
 select VALUE(p) from table(DBMS_SQLTUNE.SELECT_WORKLOAD_REPOSITORY($begin_snap,$end_snap,'sql_id='||CHR(39)||'$sql_id'||CHR(39)||' and plan_hash_value=$plan_hash_value',NULL,NULL,NULL,NULL,NULL,NULL,'ALL')) p;
 DBMS_SQLTUNE.LOAD_SQLSET(sqlset_name=>'$sqlset', populate_cursor=>baseline_ref_cursor);
end;
/

column name for a30
column owner for a30
ttitle left "View dba_sqlset after load SQL_ID=$sql_id into SQLSET_NAME=$sqlset: last 15 days"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET where CREATED>sysdate-15;
ttitle off

--Verify the execution Plan of a SQL_ID in the STS for an user sql
set pages 200
ttitle left "Verify the execution Plan of a SQL_ID=$sql_id in the STS=$sqlset for an user sql:"
SELECT * FROM table (DBMS_XPLAN.DISPLAY_SQLSET('$sqlset','$sql_id'));
ttitle off

--Load the Sql Plan Baseline from STS
prompt "Load the SQL Plan into baseline from SQLSET_NAME=$sqlset:"
set serveroutput on
declare
 my_integer pls_integer;
begin
 my_integer := dbms_spm.load_plans_from_sqlset(sqlset_name => '$sqlset', sqlset_owner => 'SYS', fixed => 'NO', enabled => 'YES');
 DBMS_OUTPUT.PUT_line(my_integer);
end;
/
EOF
;;
blchattr)
sql_handle="$2"
plan_name="$3"
attr_name="$4"
attr_value="$5"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
SET SERVEROUTPUT ON
set lines 180 long 1000 pages 100
--Enable\Disable  a specific sql baseline plan attributes
PROMPT Enable\Disable a specific sql baseline plan attributes: "enabled" YES\NO   "fixed" YES\NO   "autopurge" YES\NO
set serveroutput on
declare
  v_sql_plan_id  pls_integer;
begin
  v_sql_plan_id := dbms_spm.alter_sql_plan_baseline(
    sql_handle      => '$sql_handle',
    plan_name       => '$plan_name',
    attribute_name  => '$attr_name',
    attribute_value => '$attr_value');
end;
/
EOF
;;
blchplan)
sql_id="$2"
plan_hash_value="$3"
sql_handle="$4"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
SET SERVEROUTPUT ON
set lines 180 long 1000 pages 100
PROMPT Change baseline plan:  dbms_spm.load_plans_from_cursor_cache(sql_id => '$sql_id', plan_hash_value => '$plan_hash_value', fixed => 'YES', sql_handle => '$sql_handle', enabled => 'YES')
begin
  dbms_output.put_line(dbms_spm.load_plans_from_cursor_cache(sql_id => '$sql_id', plan_hash_value => '$plan_hash_value', fixed => 'YES', sql_handle => '$sql_handle', enabled => 'YES'));
end;
/
EOF
;;
sqlset_list)
sqlset_name="$2"
sqlset_owner="$3"
echo "sqlset_name="$sqlset_name
echo "sqlset_owner="$sqlset_owner
$SP <<EOF >$LOGF
set echo off feed off veri off tab off pages 200
set lines 230 
set long 1000
SET SERVEROUTPUT ON
set feed off

column name for a30
column owner for a30
ttitle left "View dba_sqlset:"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET order by CREATED;
ttitle off

COLUMN SQL_ID FORMAT a13
COLUMN SQL_TEXT FORMAT a80
COLUMN SCHEMA FORMAT a20
COLUMN ELAPSED FORMAT 99999999999
column plan_hash_value for 9999999999
column optimizer_cost for 9999999 heading COST
column module for a12
column executions for 999999999
column buffer_gets for 99999999999
column disk_reads for 999999999
column rows_processed for 9999999999
column fetches for 99999999
ttitle left "Select details from TABLE( DBMS_SQLTUNE.SELECT_SQLSET( '$sqlset_name' ):"
SELECT SQL_ID,PLAN_HASH_VALUE, PARSING_SCHEMA_NAME AS "SCHEMA", SQL_TEXT, ELAPSED_TIME AS "ELAPSED", BUFFER_GETS,disk_reads,rows_processed,fetches,executions,optimizer_cost
FROM TABLE( DBMS_SQLTUNE.SELECT_SQLSET( sqlset_name => '$sqlset_name',  sqlset_owner => '$sqlset_owner' ) );
EOF
;;
sqlset_plan)
sqlset_name="$2"
sqlset_sql_id="$3"
sqlset_phv="$4"
$SP <<EOF >$LOGF
set lines 230 echo off feed off veri off tab off pages 200
SELECT * FROM table(DBMS_XPLAN.DISPLAY_SQLSET(sqlset_name=>'$sqlset_name',sql_id=>'$sqlset_sql_id',plan_hash_value=>'$sqlset_phv',format => 'typical'));
EOF
;;
sqlset_drop)
sqlset_name="$2"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
SET SERVEROUTPUT ON
column name for a30
column owner for a30
ttitle left "View dba_sqlset before drop DBMS_SQLTUNE.DROP_SQLSET:"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET;
ttitle off

begin
  DBMS_SQLTUNE.DROP_SQLSET ( sqlset_name=>'$sqlset_name' );
end;
/

column name for a30
column owner for a30
ttitle left "View dba_sqlset after drop DBMS_SQLTUNE.DROP_SQLSET:"
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET;
ttitle off
EOF
;;
bldrop)
sql_handle="$2"
plan_name="$3"
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 400
SET SERVEROUTPUT ON
PROMPT "Drop DBMS_SPM.drop_sql_plan_baseline(sql_handle => '$sql_handle', plan_name  => '$plan_name'):"
DECLARE
  l_plans_dropped  PLS_INTEGER;
BEGIN
  l_plans_dropped := DBMS_SPM.drop_sql_plan_baseline (
    sql_handle => '$sql_handle',
    plan_name  => '$plan_name');
  DBMS_OUTPUT.put_line(l_plans_dropped);
END;
/
EOF
;;
usage)
sql_id="$2"
$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 400
ttitle left "Usage baselines in view gv\$sql sql_id = $sql_id:"
column SQL_PROFILE for a30
column SQL_PATCH for a20
column SQL_PLAN_BASELINE for a30
column LAST_LOAD_TIME for a22
select INST_ID, SQL_ID, CHILD_NUMBER, PLAN_HASH_VALUE, SQL_PROFILE, SQL_PATCH, SQL_PLAN_BASELINE, LAST_LOAD_TIME, LAST_ACTIVE_TIME
from GV\$SQL
where SQL_ID in ('$sql_id') and (sql_plan_baseline is not null or sql_profile is not null)
order by SQL_ID,LAST_ACTIVE_TIME;
EOF
;;
sqltune)
case "$2" in
awr|AWR) 
sql_id="$3"
begin_snap="$4"
end_snap="$5"
task_name="tpi-${sql_id}-`date +%d%m%y-%H%M`"
SQL_="
PROMPT Creating DBMS_SQLTUNE.CREATE_TUNING_TASK for sql_id=$sql_id begin_snap=$begin_snap end_snap=$end_snap task_name=$task_name from the AWR
SET SERVEROUTPUT ON SIZE UNLIMITED;
DECLARE
  task_name  VARCHAR2(100);
BEGIN
  task_name := DBMS_SQLTUNE.create_tuning_task (
                 begin_snap  => $begin_snap,
                 end_snap    => $end_snap,
                 sql_id      => '$sql_id',
                 scope       => DBMS_SQLTUNE.scope_comprehensive,
                 time_limit  => 240,
                 task_name   => '$task_name',
                 description => 'tpi tuning task for statement $sql_id in AWR.');
  DBMS_OUTPUT.PUT_LINE('Task Name: ''' || task_name || ''' Tuning Task Created');
END;
/
"
;;
*)
sql_id="$2"
task_name="tpi-${sql_id}-`date +%d%m%y-%H%M`"
 SQL_="
PROMPT Creating DBMS_SQLTUNE.CREATE_TUNING_TASK for sql_id=$sql_id task_name=$task_name from the cursor cache
SET SERVEROUTPUT ON SIZE UNLIMITED;
DECLARE
  task_name VARCHAR2(30);
BEGIN
  task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK ( sql_id => '$sql_id', scope => 'COMPREHENSIVE', time_limit => 120, task_name => '$task_name');
--  task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK ( sql_id => '$sql_id', scope => 'LIMITED', time_limit => 60, task_name => '$task_name');
  DBMS_OUTPUT.PUT_LINE('Task Name: ''' || task_name || ''' Tuning Task Created');
END;
/
"
;;
esac

$SP <<EOF >$LOGF
set lines 230
--set echo off feed off veri off tab off pages 400
$SQL_
PROMPT Executing DBMS_SQLTUNE.EXECUTE_TUNING_TASK for task_name=$task_name
BEGIN
  DBMS_SQLTUNE.EXECUTE_TUNING_TASK ( task_name => '$task_name');
END;
/
PROMPT Executing DBMS_SQLTUNE.REPORT_TUNING_TASK for task_name=$task_name
SET LONG 2000
SET LONGCHUNKSIZE 2000
SET LINESIZE 10000
DECLARE
    dat clob;
 PROCEDURE DISPLAY_CLOB (P_CLOB IN CLOB) IS
  l_amt NUMBER DEFAULT 32000;
  l_offset NUMBER DEFAULT 1;
  l_length NUMBER DEFAULT NVL (DBMS_LOB.getlength (p_clob), 0);
  x varchar2(32760);
 BEGIN
  WHILE (l_offset < l_length) LOOP
   dbms_lob.read (p_clob, l_amt, l_offset, x);
   l_offset := l_offset + l_amt;
   DBMS_OUTPUT.PUT_LINE(X);
  END LOOP;
 END DISPLAY_CLOB;
BEGIN
    dat := DBMS_SQLTUNE.REPORT_TUNING_TASK ( task_name => '$task_name' , type => 'TEXT' , level => 'TYPICAL' , section => 'ALL' );
    DISPLAY_CLOB(dat);
    dat :=  DBMS_SQLTUNE.SCRIPT_TUNING_TASK('$task_name');
    DISPLAY_CLOB(dat);
END;
/
EOF
;;
sqltune_report)
task_name="$2"
echo $task_name
$SP <<EOF >$LOGF
set lines 200
PROMPT Executing DBMS_SQLTUNE.REPORT_TUNING_TASK for task_name=$task_name
SET SERVEROUTPUT ON SIZE 1000000 FOR WRAPPED
SET LONG 20000
SET LONGCHUNKSIZE 20000
SET LINESIZE 32000
DECLARE
    dat clob;
 PROCEDURE DISPLAY_CLOB (P_CLOB IN CLOB) IS
  l_amt NUMBER DEFAULT 32000;
  l_offset NUMBER DEFAULT 1;
  l_length NUMBER DEFAULT NVL (DBMS_LOB.getlength (p_clob), 0);
  x varchar2(32760);
 BEGIN
  WHILE (l_offset < l_length) LOOP
   dbms_lob.read (p_clob, l_amt, l_offset, x);
   l_offset := l_offset + l_amt;
   DBMS_OUTPUT.PUT_LINE(X);
  END LOOP;
 END DISPLAY_CLOB;
BEGIN
    dat := DBMS_SQLTUNE.REPORT_TUNING_TASK ( task_name => '$task_name' , type => 'TEXT' , level => 'TYPICAL' , section => 'ALL' );
    DISPLAY_CLOB(dat);

    dat :=  DBMS_SQLTUNE.SCRIPT_TUNING_TASK('$task_name');
    DISPLAY_CLOB(dat);
END;
/
EOF
;;
sqltune_accept)
task_name="$2"
echo $task_name
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT Accepting sql_profile by  dbms_sqltune.accept_sql_profile 
--exec dbms_sqltune.accept_sql_profile(task_name => '$task_name', task_owner => 'SYS', replace => TRUE, name => '$task_name',profile_type => DBMS_SQLTUNE.PX_PROFILE);
exec dbms_sqltune.accept_sql_profile(task_name => '$task_name', task_owner => 'SYS', replace => TRUE, name => '$task_name');
EOF
;;
sqltune_create_plan_bl)
task_name="$2"
owner="$3"
plan_hash_value="$4"
echo "task_name="$task_name" owner="$owner" plan_hash_value="$plan_hash_value
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT Accepting sql_profile by  dbms_sqltune.accept_sql_profile
exec dbms_sqltune.create_sql_plan_baseline(task_name => '$task_name', owner_name => '$owner', plan_hash_value => $plan_hash_value);
EOF
;;
sqltune_list)
task_name="$2"
cnt="$3"
if [ -z "$cnt" ]; then
 cnt=30
fi
$SP <<EOF >$LOGF
set lines 200
set echo off feed off veri off tab off pages 400
set feed on
column task_id for 999999
column owner for a15
column task_name for a30
column created for a19
column last_modified for a19
column execution_start for a19
column execution_end for a19
column status for a12
ttitle left "List last $cnt tasks from DBA_ADVISOR_TASKS where TASK_NAME like %${task_name}%"
select * from ( SELECT owner, task_id,task_name, created,last_modified,execution_start,execution_end,status FROM DBA_ADVISOR_TASKS WHERE task_name like  '%${task_name}%' order by created ) where rownum <= $cnt;
EOF
;;
sqltune_drop)
task_name="$2"
echo $task_name
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT Drop tuning task:  DBMS_SQLTUNE.DROP_TUNING_TASK( $task_name );
exec DBMS_SQLTUNE.DROP_TUNING_TASK(task_name => '$task_name');
EOF
;;
sql_profiles)
$SP <<EOF >$LOGF
set lines 230
set echo off feed on veri off tab off pages 400
set long 100000
column name for a30
column sql_profile_name for a30
column category for a15
column sql_id for a14
column plan_hash_value for 9999999999
column created for a19
column type for a6
column status for a9
column force_matching for a10
column task_id for 999999
column task_exec_name for a16
column sql_text  for a70 word_wrapped
ttitle left "Join Views DBA_SQL_PROFILES, DBA_HIST_SQLSTAT:"
select distinct p.name sql_profile_name, p.category, s.sql_id,s.plan_hash_value,cast(p.created as date) created,p.type,p.status,p.force_matching,p.task_id,p.task_exec_name
from dba_sql_profiles p,DBA_HIST_SQLSTAT s
where p.name=s.sql_profile(+)
order by created,sql_id,plan_hash_value;
EOF
;;
sql_profile_chattr)
name="$2"
attribute_name="$3"
value="$4"
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT Change attributes for SQL_PROFILE (STATUS=ENABLED\DISABLED, NAME, DESCRIPTION, CATEGORY).  DBMS_SQLTUNE.ALTER_SQL_PROFILE ( name=>'$name', attribute_name=>'$attribute_name', value=>'$value');
exec DBMS_SQLTUNE.ALTER_SQL_PROFILE ( name=>'$name', attribute_name=>'$attribute_name', value=>'$value');
EOF
;;
sql_profile_drop)
name="$2"
echo $name
$SP <<EOF >$LOGF
set lines 200
set echo off feed on veri off tab off pages 400
PROMPT DBMS_SQLTUNE.DROP_SQL_PROFILE( name=$name )
exec DBMS_SQLTUNE.DROP_SQL_PROFILE(name=>'$name');
EOF
;;
report_sql_monitor)
sql_id="$2"
echo $name
$SP <<EOF >$LOGF
set lines 230 
set echo off feed on veri off tab off pages 400
set long 1000000000 longc 1000000000
--PROMPT DBMS_SQLTUNE.report_sql_monitor(sql_id=>'$sql_id', report_level=>'all')
SELECT DBMS_SQLTUNE.report_sql_monitor(sql_id=>'$sql_id', report_level=>'all') from dual;
EOF
;;
*) :  ;;
esac

logf
}




trace()
{
P1_=`echo $ALL | awk '{print $1}'`
P2_=`echo $ALL | awk '{print $2}'`

SID_="$P1_"
SERIAL_="$P2_"
LEVEL_=`echo $ALL | awk '{print $3}'`

case "$P1_" in
 db)  case "$P2_" in
        on) SQL1_="execute dbms_monitor.database_trace_enable(waits=>TRUE, binds=>TRUE, instance_name=> '&instance');" ;;
        off) SQL1_="execute dbms_monitor.database_trace_disable(instance_name=> '&instance');" ;;
      esac
      $SP <<EOF >$LOGF
        set lines 230
        set echo off feed off veri off tab off pages 60
        column instance_name new_value instance noprint
        select instance_name from v\$instance;
        prompt $SQL1_
        $SQL1_
        col TRACE_TYPE for a20
        col PRIMARY_ID for a20
        col QUALIFIER_ID1 for a20
        col QUALIFIER_ID2 for a20
        select * from dba_enabled_traces;
EOF
 ;;
 *)
if [ -n "$SID_" -a -n "$SERIAL_" -a -n "$LEVEL_" ]; then
 echo "SID: "$SID_"  SERIAL: "$SERIAL_"  LEVEL: "$LEVEL_
 DB_VER_=$(db_version)

 case $DB_VER_ in
  8|9|10)       CMD1_="select u_dump.value || '/' || db_name.value || '_ora_' || v\$process.spid||nvl2(v\$process.traceid, '_' || v\$process.traceid, null )||'.trc' \"Trace File\" from v\$parameter u_dump cross join   v\$parameter db_name cross join v\$process join v\$session on v\$process.addr = v\$session.paddr where u_dump.name in ('user_dump_dest','background_dump_dest') and  db_name.name = 'db_name' and v\$session.sid=$SID_;"  ;;
  *)  #CMD1_="SELECT VALUE||'/'||'$ORACLE_SID'||'_ora_'||&&SPID||'.trc' \"Trace File\" FROM V\$DIAG_INFO WHERE NAME = 'Diag Trace';" 
      CMD1_="select tracefile from v\$process where spid=&&SPID;" ;;
 esac

$SP <<EOF >$LOGF
set lines 230
set echo off feed off veri off tab off pages 60
exec sys.dbms_system.set_ev($SID_, $SERIAL_, 10046, $LEVEL_, '');

column spid format a9
column sid format 9999
column serial# format 99999
column username format a20
column status format a1
column osuser format a15
column machine format a20
column terminal format a20
column program format a30
column module format a26
select p.spid, s.sid, s.serial#, s.username, decode(s.status,'ACTIVE','A','INACTIVE','I','KILLED','K','?') status, s.osuser, s.machine, s.terminal, s.program,s.module
from v\$process p, v\$session s where p.addr = s.paddr and s.sid = $SID_ and s.serial# = $SERIAL_;

col SPID new_value SPID noprint
select p.spid SPID from v\$process p, v\$session s where p.addr = s.paddr and s.sid = $SID_ and s.serial# = $SERIAL_;

column "Trace File" for a150
$CMD1_
EOF
else
  echo "Not enough parameters...  SID: "$SID_"  SERIAL: "$SERIAL_"  LEVEL: "$LEVEL_
fi
;;
esac
touch $LOGF
logf
}


alert()
{
NUM_=`echo $ALL | awk '{print $1}'`
if [ -z "$NUM_" ]; then
 NUM_=100
fi

VALUEP=`$SP <<'END'
set pagesize 0 feedback off verify off heading off echo off timing off
select substr(platform_name,1,instr(platform_name,' ',1,1)) from v$database;
END`
VALUEP=`echo $VALUEP | tr -d '\r'`
DB_VER_=$(db_version)
case $VALUEP in
  Microsoft*) slash='\'
      case $DB_VER_ in
        8|9|10)  CMD1_="select value from v\$parameter where name='background_dump_dest';" ;;
        *)       CMD1_="select value from V\$DIAG_INFO where name='Diag Trace';" ;;
      esac ;;
  *)          slash='/'
      case $DB_VER_ in
         8|9|10)  CMD1_="select value||'$slash'||'alert_$ORACLE_SID.log' from v\$parameter where name='background_dump_dest';" ;;
         *)       CMD1_="select value||'$slash'||'alert_$ORACLE_SID.log' from V\$DIAG_INFO where name='Diag Trace';" ;;
      esac ;;
esac

case $VALUEP in
  Microsoft*) 
$SP <<EOF >$LOGF
set lines 220 timing off
set echo off feed off veri off tab off termout off pages 0
col value new_value value
col db_name new_value db_name
$CMD1_
select INSTANCE_NAME db_name from v\$instance;

create or replace directory alert_log_dir as '&&value';
drop TABLE alert_log_table ;
CREATE TABLE alert_log_table (TEXT VARCHAR2(400))
ORGANIZATION EXTERNAL (
 TYPE oracle_loader
 DEFAULT DIRECTORY alert_log_dir
 ACCESS PARAMETERS (
  RECORDS DELIMITED BY NEWLINE
  NOBADFILE NODISCARDFILE NOLOGFILE
  FIELDS TERMINATED BY '0x0A'
  MISSING FIELD VALUES ARE NULL)
 LOCATION ('alert_&&db_name..log'))
REJECT LIMIT unlimited;

WITH alert_log AS ( SELECT rownum as lineno, text FROM alert_log_table)
SELECT text FROM alert_log WHERE lineno > (SELECT count(*)-$NUM_ FROM alert_log_table)
ORDER BY lineno;
EOF
     ;;
  *) 
VALUE=`$SP <<END
set pagesize 0 feedback off verify off heading off echo off timing off
$CMD1_
END`
VALUE=`echo $VALUE | tr -d '\r'`
echo $VALUE
tail -$NUM_ $VALUE
  ;;
esac
touch $LOGF
logf
}



report()
{
type_=`echo $ALL | awk '{print $1}'`
TXT_=`echo $ALL | awk '{print $2}'`
DAY_=`echo $ALL | awk '{print $3}'`
HH1_=`echo $ALL | awk '{print $4}'`
HH2_=`echo $ALL | awk '{print $5}'`
SQL_ID_=`echo $ALL | awk '{print $6}'`
# DB_VER_=$(db_version)

case "$TXT_" in
  text) EXT_='txt' ;;
  html) EXT_='html' ;;
  *)    EXT_='txt' ;;
esac

case "$type_" in 
 ash)  RPT_="define report_type = '$TXT_'; -- 'html' for HTML, 'text' for TXT
        define begin_time  = '$DAY_';  -- Can specify both absolute and relative times in minutes. '-60' - One hour ago. Look in ashrpti.sql for syntax.
        define duration    = '';     -- NULL defaults to  'till'  current time
        define report_name = '/tmp/ashrpt.$EXT_';
        @?/rdbms/admin/ashrpt.sql" ;;
 awr)  RPT_="define report_type='$TXT_';
        define num_days=7;
        col min_snap_id new_value min_snap_id
        col max_snap_id new_value max_snap_id
        select min(snap_id) min_snap_id, max(snap_id) max_snap_id from DBA_HIST_SNAPSHOT where trunc(end_interval_time) = to_date('$DAY_', 'dd/mm/yyyy') and to_number(to_char(end_interval_time,'HH24')) between $HH1_ and $HH2_ order by 1;
        define begin_snap=&&min_snap_id
        define end_snap=&&max_snap_id
        define report_name='/tmp/awrrpt.$EXT_'
        @?/rdbms/admin/awrrpt.sql" ;;
 awrsql)  RPT_="define report_type='$TXT_';
        define num_days=7;
        col min_snap_id new_value min_snap_id
        col max_snap_id new_value max_snap_id
        select min(snap_id) min_snap_id, max(snap_id) max_snap_id from DBA_HIST_SNAPSHOT where trunc(end_interval_time) = to_date('$DAY_', 'dd/mm/yyyy') and to_number(to_char(end_interval_time,'HH24')) between $HH1_ and $HH2_ order by 1;
        define begin_snap=&&min_snap_id
        define end_snap=&&max_snap_id
        define sql_id=$SQL_ID_
        define report_name='/tmp/awrrpt.$EXT_'
        @?/rdbms/admin/awrsqrpt.sql " ;;
 addm)  RPT_="define num_days=7;
        col min_snap_id new_value min_snap_id
        col max_snap_id new_value max_snap_id
        select min(snap_id) min_snap_id, max(snap_id) max_snap_id from DBA_HIST_SNAPSHOT where trunc(end_interval_time) = to_date('$DAY_', 'dd/mm/yyyy') and to_number(to_char(end_interval_time,'HH24')) between $HH1_ and $HH2_ order by 1;
        define begin_snap=&&min_snap_id
        define end_snap=&&max_snap_id
        define report_name='/tmp/addmrpt.txt'
        @?/rdbms/admin/addmrpt.sql" ;;
   *)  RPT_="PROMPT UNKNOWN TYPE OF REPORT" ;;
esac

echo "RPT_="$RPT_

$SP <<EOF >$LOGF
$RPT_
EOF

touch $LOGF
logf
}



corrupt()
{
P1_=`echo $ALL | awk '{print $1}' | tr '[:lower:]' '[:upper:]'`
P2_=`echo $ALL | awk '{print $2}'`
P3_=`echo $ALL | awk '{print $3}'`
DB_VER=$(db_version)

case "$P1_" in
DBA)
$SP <<EOF >>$LOGF
set lines 180
set echo off feed off veri off tab off pages 40
column file new_value file for 9999
column block new_value block for 999999999
select dbms_utility.data_block_address_file($P2_) "file", dbms_utility.data_block_address_block($P2_) "block" from dual;
column owner for a15
column segment_name for a30
column PARTITION_NAME for a20
column segment_type for a10
column tablespace_name for a22
select * from dba_extents where file_id=&&file and &&block between block_id and block_id+blocks-1;
EOF
;;
FB)
$SP <<EOF >>$LOGF
set lines 180
set echo off feed off veri off tab off pages 40
column owner for a15
column segment_name for a30
column PARTITION_NAME for a20
column segment_type for a10
column tablespace_name for a22
ttitle left "View dba_extents"
select * from dba_extents where file_id=$P2_ and $P3_ between block_id and block_id+blocks-1;
ttitle off
EOF
;;
*)
$SP <<EOF >$LOGF
set lines 180
set echo off feed off veri off tab off pages 50
column CORRUPTION_CHANGE# for 999999999999999
prompt  View v\$database_block_corruption
select * from v\$database_block_corruption order by file#, block#;
EOF
 case "$DB_VER" in
 8|9|10|11) : ;;
 *)
$SP <<EOF >>$LOGF
set lines 180
set echo off feed off veri off tab off pages 40
column FILE# for 9999
column NONLOGGED_START_CHANGE# for 999999999999999
column NONLOGGED_END_CHANGE# for 999999999999999
column RESETLOGS_CHANGE# for 999999999999999
column OBJECT# for a12
prompt View v\$nonlogged_block
select * from v\$nonlogged_block order by file#,block#;
EOF
;;
 esac
;;
esac
logf
}

export TERM=xterm
U=`uname | awk -F_ '{print $1}'`
case "$U" in
 CYGWIN)  echo -n "DB="$sid"   "`date +%d-%m-%Y" "%H:%M:%S`"   " ;;
 AIX)     echo "DB="$sid"   "`date +%d-%m-%Y" "%H:%M:%S`"   " \\c ;;
 *)
 red=`tput setaf 1`
 green=`tput setaf 2`
 yellow=`tput setaf 3`
 blue=`tput setaf 4`
 magneta=`tput setaf 5`
 cyan=`tput setaf 6`
 reset=`tput sgr0`
 echo -n ${green}"DB="$sid"   "`date +%d-%m-%Y" "%H:%M:%S`"   "
 ;;
esac


case "$ID" in
""|a|access)  echo $a__ ${reset}; active_sessions $ALL ;;
lock)   echo $lock__ ${reset}; lock $ALL ;;
p|ph|services|dir)   echo $p__ ", parameters like: "$ALL ${reset}; parameters $ALL ;;
db)  echo $db__ ${reset}; db ;;
health)  shift ; ALL=$* ; echo $health__ ${reset}; health $ALL ;;
oratop)  shift ; ALL=$* ; echo $oratop__ ${reset}; oratop $ALL ;;
sga)  echo $sga__ ${reset}; sga ;;
pga)  echo $pga__ ${reset}; pga ;;
size) echo $size__ ${reset}; size $ALL ;;
arch) echo $arch__ ${reset}; arch $ALL ;;
tbs)  shift; ALL=$*; echo $size__ ${reset}; tbs $ALL ;;
df) shift; ALL=$*; echo $size__ ${reset}; df $ALL ;;
maxseg) shift; echo $size__ ", (TABLESPACE NAME = '"$ALL"'):" ${reset}; maxseg $ALL ;;
fra) echo $size__ ${reset}; fra ;;
redo) shift ; ALL=$* ; echo $redo__ ${reset}; redo $ALL ;;
undo) shift ; ALL=$* ; echo $undo__ ${reset}; undo $ALL ;;
sesstat)  shift; ALL=$*;  echo $sesstat__ ", STATNAME = " $ALL ${reset}; sesstat $ALL ;;
topseg) echo $topseg__ ${reset}; topseg ;;
o)   shift; ALL=$*; echo $o__ ", OBJECT_NAME = " $ALL ${reset}; object $ALL ;;
s)   shift; ALL=$*; echo $s__ ", SEGMENT_NAME = " $ALL ${reset}; segment $ALL ;;
t)   shift ; echo $t__ ", PARAMETERS = " $ALL ${reset}; table "$ALL" ;;
i)   shift ; echo $i__ ", INDEX_NAME = " $ALL ${reset}; index $ALL ;;
l)   shift; ALL=$*; echo $l__ ", LOB_NAME = " $ALL ${reset}; lob $ALL ;;
c)   echo $c__ ", PARAMETERS = " $ALL ${reset}; constraint $ALL ;;
u)   shift; ALL=$*; echo $u__ ", USERNAME = " $ALL ${reset}; user $ALL ;;
invalid) shift; ALL=$* ; echo $invalid__  ${reset}; invalid $ALL ;;
profile) shift; ALL=$* ; echo $profile__  ${reset}; profile $ALL ;;
links)   echo $links__ ${reset} ; links ;;
latch)   echo $latch__ ${reset} ; latch ;;
bind) shift ; ALL=$* ; echo $bind__ ", SQL like " $ALL ${reset}; bind $ALL ;;
pipe) shift ; ALL=$* ; echo $pipe__ ", PIPE = " $ALL ${reset}; pipe $ALL ;;
longops)  echo $longops__ ${reset}; longops $ALL ;;
scheduler) shift; ALL=$*; echo $scheduler__ ${reset}; scheduler $ALL ;;
job)  shift; ALL=$*; echo $job__ ${reset}; job $ALL ;;
get_ddl) shift ; ALL=$*; echo $get_ddl__ ", for: "$ALL ${reset} ; get_ddl $ALL  ;;
trace) shift; ALL=$*; echo $trace__ ${reset}; trace $ALL ;;
alert) shift; ALL=$*; echo $alert__ ${reset}; alert $ALL ;;
report) shift; ALL=$*; echo $report__ ${reset}; report $ALL ;;
corrupt) shift; ALL=$*; echo $corrupt__ ${reset}; corrupt $ALL ;;
sql) shift; ALL=$*; echo $sql__ ", for: "$ALL  ${reset}; psql $ALL  ;;
ash) shift; ALL=$*; echo $ash__ ", for: "$ALL  ${reset}; ash $ALL ; echo $ash__ ;;
dhash) shift; ALL=$*; echo $dhash__ ", for: "$ALL ${reset}; dhash $ALL ; echo $dhash__ ;;
spm) shift; ALL=$*;  echo $spm__ ", Now: "$ALL ${reset}  ; spm $ALL ; echo $spm__ ;;
*)   echo echo $a__  "process_info"${reset}; process_info $ALL ;; 
esac


